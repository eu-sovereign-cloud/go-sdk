// Package regions provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package regions

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for RegionKind.
const (
	RegionKindRegion RegionKind = "region"
)

// Error A generic error response
type Error struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error400 defines model for Error400.
type Error400 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error401 defines model for Error401.
type Error401 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error403 defines model for Error403.
type Error403 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error404 defines model for Error404.
type Error404 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error500 defines model for Error500.
type Error500 struct {
	Errors []ErrorDetail `json:"errors"`
}

// ErrorDetail A detailed error response
type ErrorDetail struct {
	// Code An application-specific error code, expressed as a string value.
	Code string `json:"code"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Source An object containing references to the source of the error.
	Source *struct {
		// Parameter A string indicating which URI query parameter caused the error.
		Parameter *string `json:"parameter,omitempty"`

		// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
		Pointer *string `json:"pointer,omitempty"`
	} `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem.
	Title string `json:"title"`
}

// GlobalResourceMetadata defines model for GlobalResourceMetadata.
type GlobalResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels *map[string]interface{} `json:"labels,omitempty"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name *string `json:"name,omitempty"`
}

// Provider defines model for Provider.
type Provider struct {
	Name    *string `json:"name,omitempty"`
	Url     *string `json:"url,omitempty"`
	Version *string `json:"version,omitempty"`
}

// Region defines model for Region.
type Region struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *RegionKind             `json:"kind,omitempty"`
	Metadata *GlobalResourceMetadata `json:"metadata,omitempty"`
	Spec     *struct {
		AvailableZones *[]string   `json:"availableZones,omitempty"`
		Providers      *[]Provider `json:"providers,omitempty"`
	} `json:"spec,omitempty"`

	// Status Current status of the resource
	Status *Status `json:"status,omitempty"`
}

// RegionKind Type of the resource
type RegionKind string

// ResourceMetadata Base metadata for all resources, with optional location references
type ResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels *map[string]interface{} `json:"labels,omitempty"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name *string `json:"name,omitempty"`
}

// Status Current status of the resource
type Status struct {
	// Conditions Conditions represent the latest available observations of a resource's current state.
	// Conditions are provider-specific and can represent different states depending on the
	// resource type and provider implementation.
	Conditions *StatusConditions `json:"conditions,omitempty"`
}

// StatusConditions Conditions represent the latest available observations of a resource's current state.
// Conditions are provider-specific and can represent different states depending on the
// resource type and provider implementation.
type StatusConditions = []struct {
	// LastTransitionTime LastTransitionTime is the last time the condition transitioned from one
	// status to another. This should be when the underlying condition changed.
	// If that is not known, then using the time when the API field changed is
	// acceptable.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message A human-readable message indicating details about the transition.
	Message *string `json:"message,omitempty"`

	// Reason The reason for the condition's last transition in CamelCase.
	// The specific set of reason values is provider-specific and should be
	// documented by the provider.
	Reason *string `json:"reason,omitempty"`

	// Status Status of the condition.
	Status string `json:"status"`

	// Type Type of condition. The condition type is provider-specific and should
	// reflect the specific states relevant to your resource.
	Type string `json:"type"`
}

// AcceptHeader defines model for acceptHeader.
type AcceptHeader = string

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// TenantID defines model for tenantID.
type TenantID = string

// ListRegionsParams defines parameters for ListRegions.
type ListRegionsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - application/json: Returns only non-deleted resources
	// - application/json; deleted=true: Returns both deleted and non-deleted resources
	// - application/json; deleted=only: Returns only deleted resources
	Accept *AcceptHeader `json:"Accept,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListRegions request
	ListRegions(ctx context.Context, id TenantID, params *ListRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegion request
	GetRegion(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListRegions(ctx context.Context, id TenantID, params *ListRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRegionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegion(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegionRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListRegionsRequest generates requests for ListRegions
func NewListRegionsRequest(server string, id TenantID, params *ListRegionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/regions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewGetRegionRequest generates requests for GetRegion
func NewGetRegionRequest(server string, id TenantID, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/regions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListRegionsWithResponse request
	ListRegionsWithResponse(ctx context.Context, id TenantID, params *ListRegionsParams, reqEditors ...RequestEditorFn) (*ListRegionsResponse, error)

	// GetRegionWithResponse request
	GetRegionWithResponse(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*GetRegionResponse, error)
}

type ListRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]Region `json:"items,omitempty"`
		Metadata *struct {
			// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
			SkipToken *string `json:"skipToken,omitempty"`
		} `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Region
	JSON404      *Error404
}

// Status returns HTTPResponse.Status
func (r GetRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListRegionsWithResponse request returning *ListRegionsResponse
func (c *ClientWithResponses) ListRegionsWithResponse(ctx context.Context, id TenantID, params *ListRegionsParams, reqEditors ...RequestEditorFn) (*ListRegionsResponse, error) {
	rsp, err := c.ListRegions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRegionsResponse(rsp)
}

// GetRegionWithResponse request returning *GetRegionResponse
func (c *ClientWithResponses) GetRegionWithResponse(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*GetRegionResponse, error) {
	rsp, err := c.GetRegion(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegionResponse(rsp)
}

// ParseListRegionsResponse parses an HTTP response from a ListRegionsWithResponse call
func ParseListRegionsResponse(rsp *http.Response) (*ListRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]Region `json:"items,omitempty"`
			Metadata *struct {
				// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
				SkipToken *string `json:"skipToken,omitempty"`
			} `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRegionResponse parses an HTTP response from a GetRegionWithResponse call
func ParseGetRegionResponse(rsp *http.Response) (*GetRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Region
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all regions
	// (GET /v1/tenants/{id}/regions)
	ListRegions(ctx echo.Context, id TenantID, params ListRegionsParams) error
	// Get a specific region by name
	// (GET /v1/tenants/{id}/regions/{name})
	GetRegion(ctx echo.Context, id TenantID, name string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListRegions converts echo context to params.
func (w *ServerInterfaceWrapper) ListRegions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRegionsParams
	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", ctx.QueryParams(), &params.Labels)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter labels: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", ctx.QueryParams(), &params.SkipToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skipToken: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept: %s", err))
		}

		params.Accept = &Accept
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRegions(ctx, id, params)
	return err
}

// GetRegion converts echo context to params.
func (w *ServerInterfaceWrapper) GetRegion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRegion(ctx, id, name)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v1/tenants/:id/regions", wrapper.ListRegions)
	router.GET(baseURL+"/v1/tenants/:id/regions/:name", wrapper.GetRegion)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"L0QvAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
