//go:build go1.22

// Package compute provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package compute

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for InstancePlacementStrategyStrategy.
const (
	AntiAffinity InstancePlacementStrategyStrategy = "anti-affinity"
	Auto         InstancePlacementStrategyStrategy = "auto"
	Zone         InstancePlacementStrategyStrategy = "zone"
)

// Defines values for RegionalResourceMetadataKind.
const (
	RegionalResourceMetadataKindActivityLog          RegionalResourceMetadataKind = "activity-log"
	RegionalResourceMetadataKindBlockStorage         RegionalResourceMetadataKind = "block-storage"
	RegionalResourceMetadataKindImage                RegionalResourceMetadataKind = "image"
	RegionalResourceMetadataKindInstance             RegionalResourceMetadataKind = "instance"
	RegionalResourceMetadataKindInstanceSku          RegionalResourceMetadataKind = "instance-sku"
	RegionalResourceMetadataKindLan                  RegionalResourceMetadataKind = "lan"
	RegionalResourceMetadataKindLocation             RegionalResourceMetadataKind = "location"
	RegionalResourceMetadataKindNetworkLoadBalancer  RegionalResourceMetadataKind = "network-load-balancer"
	RegionalResourceMetadataKindNetworkSku           RegionalResourceMetadataKind = "network-sku"
	RegionalResourceMetadataKindNic                  RegionalResourceMetadataKind = "nic"
	RegionalResourceMetadataKindObjectStorageAccount RegionalResourceMetadataKind = "object-storage-account"
	RegionalResourceMetadataKindPublicIp             RegionalResourceMetadataKind = "public-ip"
	RegionalResourceMetadataKindQuota                RegionalResourceMetadataKind = "quota"
	RegionalResourceMetadataKindRegion               RegionalResourceMetadataKind = "region"
	RegionalResourceMetadataKindRole                 RegionalResourceMetadataKind = "role"
	RegionalResourceMetadataKindRoleAssignment       RegionalResourceMetadataKind = "role-assignment"
	RegionalResourceMetadataKindRoutingTable         RegionalResourceMetadataKind = "routing-table"
	RegionalResourceMetadataKindSecurityGroup        RegionalResourceMetadataKind = "security-group"
	RegionalResourceMetadataKindSecurityGroupRule    RegionalResourceMetadataKind = "security-group-rule"
	RegionalResourceMetadataKindStorageSku           RegionalResourceMetadataKind = "storage-sku"
	RegionalResourceMetadataKindSubnet               RegionalResourceMetadataKind = "subnet"
	RegionalResourceMetadataKindWorkspace            RegionalResourceMetadataKind = "workspace"
)

// Defines values for ResourceStatePhase.
const (
	ResourceStatePhaseActive    ResourceStatePhase = "active"
	ResourceStatePhaseCreating  ResourceStatePhase = "creating"
	ResourceStatePhaseDeleting  ResourceStatePhase = "deleting"
	ResourceStatePhaseError     ResourceStatePhase = "error"
	ResourceStatePhasePending   ResourceStatePhase = "pending"
	ResourceStatePhaseSuspended ResourceStatePhase = "suspended"
	ResourceStatePhaseUpdating  ResourceStatePhase = "updating"
)

// Defines values for TypeMetadataKind.
const (
	TypeMetadataKindActivityLog          TypeMetadataKind = "activity-log"
	TypeMetadataKindBlockStorage         TypeMetadataKind = "block-storage"
	TypeMetadataKindImage                TypeMetadataKind = "image"
	TypeMetadataKindInstance             TypeMetadataKind = "instance"
	TypeMetadataKindInstanceSku          TypeMetadataKind = "instance-sku"
	TypeMetadataKindLan                  TypeMetadataKind = "lan"
	TypeMetadataKindLocation             TypeMetadataKind = "location"
	TypeMetadataKindNetworkLoadBalancer  TypeMetadataKind = "network-load-balancer"
	TypeMetadataKindNetworkSku           TypeMetadataKind = "network-sku"
	TypeMetadataKindNic                  TypeMetadataKind = "nic"
	TypeMetadataKindObjectStorageAccount TypeMetadataKind = "object-storage-account"
	TypeMetadataKindPublicIp             TypeMetadataKind = "public-ip"
	TypeMetadataKindQuota                TypeMetadataKind = "quota"
	TypeMetadataKindRegion               TypeMetadataKind = "region"
	TypeMetadataKindRole                 TypeMetadataKind = "role"
	TypeMetadataKindRoleAssignment       TypeMetadataKind = "role-assignment"
	TypeMetadataKindRoutingTable         TypeMetadataKind = "routing-table"
	TypeMetadataKindSecurityGroup        TypeMetadataKind = "security-group"
	TypeMetadataKindSecurityGroupRule    TypeMetadataKind = "security-group-rule"
	TypeMetadataKindStorageSku           TypeMetadataKind = "storage-sku"
	TypeMetadataKindSubnet               TypeMetadataKind = "subnet"
	TypeMetadataKindWorkspace            TypeMetadataKind = "workspace"
)

// Defines values for ZonalResourceMetadataKind.
const (
	ZonalResourceMetadataKindActivityLog          ZonalResourceMetadataKind = "activity-log"
	ZonalResourceMetadataKindBlockStorage         ZonalResourceMetadataKind = "block-storage"
	ZonalResourceMetadataKindImage                ZonalResourceMetadataKind = "image"
	ZonalResourceMetadataKindInstance             ZonalResourceMetadataKind = "instance"
	ZonalResourceMetadataKindInstanceSku          ZonalResourceMetadataKind = "instance-sku"
	ZonalResourceMetadataKindLan                  ZonalResourceMetadataKind = "lan"
	ZonalResourceMetadataKindLocation             ZonalResourceMetadataKind = "location"
	ZonalResourceMetadataKindNetworkLoadBalancer  ZonalResourceMetadataKind = "network-load-balancer"
	ZonalResourceMetadataKindNetworkSku           ZonalResourceMetadataKind = "network-sku"
	ZonalResourceMetadataKindNic                  ZonalResourceMetadataKind = "nic"
	ZonalResourceMetadataKindObjectStorageAccount ZonalResourceMetadataKind = "object-storage-account"
	ZonalResourceMetadataKindPublicIp             ZonalResourceMetadataKind = "public-ip"
	ZonalResourceMetadataKindQuota                ZonalResourceMetadataKind = "quota"
	ZonalResourceMetadataKindRegion               ZonalResourceMetadataKind = "region"
	ZonalResourceMetadataKindRole                 ZonalResourceMetadataKind = "role"
	ZonalResourceMetadataKindRoleAssignment       ZonalResourceMetadataKind = "role-assignment"
	ZonalResourceMetadataKindRoutingTable         ZonalResourceMetadataKind = "routing-table"
	ZonalResourceMetadataKindSecurityGroup        ZonalResourceMetadataKind = "security-group"
	ZonalResourceMetadataKindSecurityGroupRule    ZonalResourceMetadataKind = "security-group-rule"
	ZonalResourceMetadataKindStorageSku           ZonalResourceMetadataKind = "storage-sku"
	ZonalResourceMetadataKindSubnet               ZonalResourceMetadataKind = "subnet"
	ZonalResourceMetadataKindWorkspace            ZonalResourceMetadataKind = "workspace"
)

// Defines values for AcceptHeader.
const (
	AcceptHeaderApplicationjson            AcceptHeader = "application/json"
	AcceptHeaderApplicationjsonDeletedOnly AcceptHeader = "application/json; deleted=only"
	AcceptHeaderApplicationjsonDeletedTrue AcceptHeader = "application/json; deleted=true"
)

// Defines values for ListComputeQuotasParamsAccept.
const (
	ListComputeQuotasParamsAcceptApplicationjson            ListComputeQuotasParamsAccept = "application/json"
	ListComputeQuotasParamsAcceptApplicationjsonDeletedOnly ListComputeQuotasParamsAccept = "application/json; deleted=only"
	ListComputeQuotasParamsAcceptApplicationjsonDeletedTrue ListComputeQuotasParamsAccept = "application/json; deleted=true"
)

// Defines values for ListSkusParamsAccept.
const (
	ListSkusParamsAcceptApplicationjson            ListSkusParamsAccept = "application/json"
	ListSkusParamsAcceptApplicationjsonDeletedOnly ListSkusParamsAccept = "application/json; deleted=only"
	ListSkusParamsAcceptApplicationjsonDeletedTrue ListSkusParamsAccept = "application/json; deleted=true"
)

// Defines values for ListInstancesParamsAccept.
const (
	ListInstancesParamsAcceptApplicationjson            ListInstancesParamsAccept = "application/json"
	ListInstancesParamsAcceptApplicationjsonDeletedOnly ListInstancesParamsAccept = "application/json; deleted=only"
	ListInstancesParamsAcceptApplicationjsonDeletedTrue ListInstancesParamsAccept = "application/json; deleted=true"
)

// Error A generic error response
type Error struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error400 defines model for Error400.
type Error400 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error401 defines model for Error401.
type Error401 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error403 defines model for Error403.
type Error403 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error404 defines model for Error404.
type Error404 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error412 defines model for Error412.
type Error412 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error422 defines model for Error422.
type Error422 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error500 defines model for Error500.
type Error500 struct {
	Errors []ErrorDetail `json:"errors"`
}

// ErrorDetail A detailed error response
type ErrorDetail struct {
	// Code An application-specific error code, expressed as a string value.
	Code string `json:"code"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta map[string]interface{} `json:"meta"`

	// Source An object containing references to the source of the error.
	Source *ErrorSource `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem.
	Title string `json:"title"`
}

// ErrorSource An object containing references to the source of the error.
type ErrorSource struct {
	// Parameter A string indicating which URI query parameter caused the error.
	Parameter string `json:"parameter"`

	// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
	Pointer string `json:"pointer"`
}

// Instance defines model for Instance.
type Instance struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	Labels   *map[string]string     `json:"labels,omitempty"`
	Metadata *ZonalResourceMetadata `json:"metadata,omitempty"`
	Spec     InstanceSpec           `json:"spec"`
	Status   *InstanceStatus        `json:"status,omitempty"`
}

// InstanceNetwork defines model for InstanceNetwork.
type InstanceNetwork struct {
	// OtherNics Additional NICs attached to this instance
	OtherNics *[]InstanceNicRef `json:"otherNics,omitempty"`

	// PrimaryNicRef Reference to the primary NIC for this instance
	PrimaryNicRef *string `json:"primaryNicRef,omitempty"`
}

// InstanceNicRef defines model for InstanceNicRef.
type InstanceNicRef struct {
	NicRef *string `json:"nicRef,omitempty"`
	Slot   *int    `json:"slot,omitempty"`
}

// InstancePlacementStrategy defines model for InstancePlacementStrategy.
type InstancePlacementStrategy struct {
	AntiAffinityGroup *string                            `json:"antiAffinityGroup,omitempty"`
	Strategy          *InstancePlacementStrategyStrategy `json:"strategy,omitempty"`
	Zone              *string                            `json:"zone,omitempty"`
}

// InstancePlacementStrategyStrategy defines model for InstancePlacementStrategy.Strategy.
type InstancePlacementStrategyStrategy string

// InstanceSku Represents a Stock Keeping Unit (SKU) for compute instances.
//
// Properties, capabilites and extensions can also be found in the metadata.labels sections for filtering.
type InstanceSku struct {
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`
	Spec     *InstanceSkuSpec          `json:"spec,omitempty"`

	// Status Current status of the resource
	Status *Status `json:"status,omitempty"`
}

// InstanceSkuCapability Instance performance capabilities
type InstanceSkuCapability struct {
	BenchmarkPoints *int `json:"benchmarkPoints,omitempty"`
	RamGB           *int `json:"ramGB,omitempty"`
	VCPU            *int `json:"vCPU,omitempty"`
}

// InstanceSkuSpec defines model for InstanceSkuSpec.
type InstanceSkuSpec struct {
	// Capabilities Instance performance capabilities
	Capabilities *InstanceSkuCapability `json:"capabilities,omitempty"`
	Description  *string                `json:"description,omitempty"`

	// Extensions Additional instance feature extensions
	Extensions *[]string `json:"extensions,omitempty"`

	// MandatoryParameters Mandatory parameters for block storage resources
	MandatoryParameters *[]string `json:"mandatoryParameters,omitempty"`

	// Provider Provider namespace for instance SKUs
	Provider *string `json:"provider,omitempty"`
	Tier     *string `json:"tier,omitempty"`
}

// InstanceSpec defines model for InstanceSpec.
type InstanceSpec struct {
	Network         *InstanceNetwork `json:"network,omitempty"`
	OperatingSystem *struct {
		CloudInitData *struct {
			// SshKeyExternalRef Provider-specific references to SSH keys used in cloud-init vendorData.
			// These references are used to inject SSH public keys during instance initialization
			// through cloud-init's vendor data configuration.
			SshKeyExternalRef *[]string `json:"sshKeyExternalRef,omitempty"`

			// UserData Cloud-init user data for instance initialization
			// Example cloud-init user configuration with SSH key:
			// ```yaml
			// #cloud-config
			// packages:
			//   - nginx
			// ```
			UserData *string `json:"userData,omitempty"`
		} `json:"cloudInitData,omitempty"`

		// OsBlockStorageRef Represents a connection between a Block Storage and a device
		OsBlockStorageRef *VolumeAttachment `json:"osBlockStorageRef,omitempty"`
	} `json:"operatingSystem,omitempty"`
	Profile *struct {
		// InstanceSkuRef Reference to the SKU used for this instance
		InstanceSkuRef *string        `json:"instanceSkuRef,omitempty"`
		SkuExtensions  *SkuExtensions `json:"skuExtensions,omitempty"`
	} `json:"profile,omitempty"`
	Storage *struct {
		DataBlockStorageRef *[]VolumeAttachment `json:"dataBlockStorageRef,omitempty"`
	} `json:"storage,omitempty"`
}

// InstanceStatus defines model for InstanceStatus.
type InstanceStatus struct {
	Conditions          *[]StatusCondition         `json:"conditions,omitempty"`
	DataBlockStorageRef *[]string                  `json:"dataBlockStorageRef,omitempty"`
	Network             *InstanceNetwork           `json:"network,omitempty"`
	Placement           *InstancePlacementStrategy `json:"placement,omitempty"`

	// State Generic state definition for all resources. All states are optional, but must not have more states.
	// If a provider wants to present fine granular states, please use conditions.
	State *ResourceState `json:"state,omitempty"`
}

// ModificationMetadata Base metadata for all resources with optional location references
type ModificationMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp time.Time `json:"deletionTimestamp"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp time.Time `json:"lastModifiedTimestamp"`
}

// NameMetadata defines model for NameMetadata.
type NameMetadata struct {
	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name string `json:"name"`
}

// RegionalMetadata Metadata for regional resources
type RegionalMetadata struct {
	// Region Reference to the region where the resource is located
	Region string `json:"region"`

	// Workspace Workspace identifier
	Workspace *string `json:"workspace,omitempty"`
}

// RegionalResourceMetadata defines model for RegionalResourceMetadata.
type RegionalResourceMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp time.Time `json:"deletionTimestamp"`

	// Kind Type of the resource
	Kind RegionalResourceMetadataKind `json:"kind"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp time.Time `json:"lastModifiedTimestamp"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name string `json:"name"`

	// Region Reference to the region where the resource is located
	Region string `json:"region"`

	// Tenant Tenant identifier
	Tenant string `json:"tenant"`

	// Workspace Workspace identifier
	Workspace *string `json:"workspace,omitempty"`
}

// RegionalResourceMetadataKind Type of the resource
type RegionalResourceMetadataKind string

// ResourceQuota defines model for ResourceQuota.
type ResourceQuota struct {
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`

	// Spec Represents the ResourceQuota for the single ResourceType of the Resource Provider
	Spec   *ResourceQuotaSpec   `json:"spec,omitempty"`
	Status *ResourceQuotaStatus `json:"status,omitempty"`
}

// ResourceQuotaSpec Represents the ResourceQuota for the single ResourceType of the Resource Provider
type ResourceQuotaSpec struct {
	// Value limit number of resourceType instances, set null for unlimited
	Value *int `json:"value"`
}

// ResourceQuotaStatus defines model for ResourceQuotaStatus.
type ResourceQuotaStatus struct {
	Conditions []StatusCondition `json:"conditions"`
	Current    *ResourceQuota    `json:"current,omitempty"`
	Usage      *ResourceQuota    `json:"usage,omitempty"`
}

// ResourceState Generic state definition for all resources. All states are optional, but must not have more states.
// If a provider wants to present fine granular states, please use conditions.
type ResourceState struct {
	// Phase Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	Phase *ResourceStatePhase `json:"phase,omitempty"`
}

// ResourceStatePhase Current phase of the resource:
// - pending: not available, waiting for other resources
// - creating: not available, creation started
// - active: available for data layer usage
// - updating: available for data layer usage
// - deleting: maybe still available for data layer user, can fail any moment
// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
// - error: failed to fulfill the request; would be related to provider issue or customer related input.
type ResourceStatePhase string

// ResponseMetadata defines model for ResponseMetadata.
type ResponseMetadata struct {
	// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
	SkipToken *string `json:"skipToken,omitempty"`
}

// SkuExtensions defines model for SkuExtensions.
type SkuExtensions map[string]interface{}

// Status Current status of the resource
type Status struct {
	Conditions []StatusCondition `json:"conditions"`
}

// StatusCondition StatusCondition describes the state of a resource at a certain point.
// Conditions are provider-specific and can represent different states depending on the
// resource type and provider implementation.
type StatusCondition struct {
	// LastTransitionTime LastTransitionTime is the last time the condition transitioned from one
	// status to another. This should be when the underlying condition changed.
	// If that is not known, then using the time when the API field changed is
	// acceptable.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message A human-readable message indicating details about the transition.
	Message *string `json:"message,omitempty"`

	// Reason The reason for the condition's last transition in CamelCase.
	// The specific set of reason values is provider-specific and should be
	// documented by the provider.
	Reason *string `json:"reason,omitempty"`

	// Status Status of the condition.
	Status string `json:"status"`

	// Type Type of condition. The condition type is provider-specific and should
	// reflect the specific states relevant to your resource.
	Type string `json:"type"`
}

// TenantMetadata Metadata for global resources with tenant constraints
type TenantMetadata struct {
	// Tenant Tenant identifier
	Tenant string `json:"tenant"`
}

// TypeMetadata defines model for TypeMetadata.
type TypeMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// Kind Type of the resource
	Kind TypeMetadataKind `json:"kind"`
}

// TypeMetadataKind Type of the resource
type TypeMetadataKind string

// UserResourceMetadata defines model for UserResourceMetadata.
type UserResourceMetadata struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	Labels *map[string]string `json:"labels,omitempty"`
}

// VolumeAttachment Represents a connection between a Block Storage and a device
type VolumeAttachment struct {
	ObjectRef  *string                     `json:"objectRef,omitempty"`
	Properties *VolumeAttachmentProperties `json:"properties,omitempty"`
}

// VolumeAttachmentProperties defines model for VolumeAttachmentProperties.
type VolumeAttachmentProperties struct {
	// ConnectionType The connection type depends on the type of device and type of block storage.
	ConnectionType *string `json:"connectionType,omitempty"`

	// DeviceKind the type of device a block-storage is connected to. For now only 'instance' possible
	DeviceKind *string `json:"deviceKind,omitempty"`
	DeviceRef  *string `json:"deviceRef,omitempty"`
}

// ZonalMetadata Metadata for zonal resources
type ZonalMetadata struct {
	// Zone Reference to the specific zone where the resource is located
	Zone string `json:"zone"`
}

// ZonalResourceMetadata defines model for ZonalResourceMetadata.
type ZonalResourceMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp time.Time `json:"deletionTimestamp"`

	// Kind Type of the resource
	Kind ZonalResourceMetadataKind `json:"kind"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp time.Time `json:"lastModifiedTimestamp"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name string `json:"name"`

	// Region Reference to the region where the resource is located
	Region string `json:"region"`

	// Tenant Tenant identifier
	Tenant string `json:"tenant"`

	// Workspace Workspace identifier
	Workspace *string `json:"workspace,omitempty"`

	// Zone Reference to the specific zone where the resource is located
	Zone string `json:"zone"`
}

// ZonalResourceMetadataKind Type of the resource
type ZonalResourceMetadataKind string

// AcceptHeader defines model for acceptHeader.
type AcceptHeader string

// IfUnmodifiedSince defines model for ifUnmodifiedSince.
type IfUnmodifiedSince = time.Time

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// ResourceName defines model for resourceName.
type ResourceName = string

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// TenantID defines model for tenantID.
type TenantID = string

// WorkspaceName defines model for workspaceName.
type WorkspaceName = string

// ListComputeQuotasParams defines parameters for ListComputeQuotas.
type ListComputeQuotasParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListComputeQuotasParamsAccept `json:"Accept,omitempty"`
}

// ListComputeQuotasParamsAccept defines parameters for ListComputeQuotas.
type ListComputeQuotasParamsAccept string

// CreateOrUpdateComputeQuotaParams defines parameters for CreateOrUpdateComputeQuota.
type CreateOrUpdateComputeQuotaParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListSkusParams defines parameters for ListSkus.
type ListSkusParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListSkusParamsAccept `json:"Accept,omitempty"`
}

// ListSkusParamsAccept defines parameters for ListSkus.
type ListSkusParamsAccept string

// ListInstancesParams defines parameters for ListInstances.
type ListInstancesParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListInstancesParamsAccept `json:"Accept,omitempty"`
}

// ListInstancesParamsAccept defines parameters for ListInstances.
type ListInstancesParamsAccept string

// CreateOrUpdateInstanceParams defines parameters for CreateOrUpdateInstance.
type CreateOrUpdateInstanceParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateComputeQuotaJSONRequestBody defines body for CreateOrUpdateComputeQuota for application/json ContentType.
type CreateOrUpdateComputeQuotaJSONRequestBody = ResourceQuota

// CreateOrUpdateInstanceJSONRequestBody defines body for CreateOrUpdateInstance for application/json ContentType.
type CreateOrUpdateInstanceJSONRequestBody = Instance

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListComputeQuotas request
	ListComputeQuotas(ctx context.Context, id TenantID, params *ListComputeQuotasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateComputeQuotaWithBody request with any body
	CreateOrUpdateComputeQuotaWithBody(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateComputeQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateComputeQuota(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateComputeQuotaParams, body CreateOrUpdateComputeQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSkus request
	ListSkus(ctx context.Context, id TenantID, params *ListSkusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSku request
	GetSku(ctx context.Context, id TenantID, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInstances request
	ListInstances(ctx context.Context, id TenantID, workspace string, params *ListInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInstance request
	DeleteInstance(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstance request
	GetInstance(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateInstanceWithBody request with any body
	CreateOrUpdateInstanceWithBody(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateInstance(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateInstanceParams, body CreateOrUpdateInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PowerCycleInstance request
	PowerCycleInstance(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PowerOffInstance request
	PowerOffInstance(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PowerOnInstance request
	PowerOnInstance(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListComputeQuotas(ctx context.Context, id TenantID, params *ListComputeQuotasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListComputeQuotasRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateComputeQuotaWithBody(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateComputeQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateComputeQuotaRequestWithBody(c.Server, id, resourceType, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateComputeQuota(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateComputeQuotaParams, body CreateOrUpdateComputeQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateComputeQuotaRequest(c.Server, id, resourceType, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSkus(ctx context.Context, id TenantID, params *ListSkusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSkusRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSku(ctx context.Context, id TenantID, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSkuRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInstances(ctx context.Context, id TenantID, workspace string, params *ListInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInstancesRequest(c.Server, id, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInstance(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInstanceRequest(c.Server, id, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstance(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceRequest(c.Server, id, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateInstanceWithBody(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateInstanceRequestWithBody(c.Server, id, workspace, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateInstance(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateInstanceParams, body CreateOrUpdateInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateInstanceRequest(c.Server, id, workspace, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PowerCycleInstance(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPowerCycleInstanceRequest(c.Server, id, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PowerOffInstance(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPowerOffInstanceRequest(c.Server, id, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PowerOnInstance(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPowerOnInstanceRequest(c.Server, id, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListComputeQuotasRequest generates requests for ListComputeQuotas
func NewListComputeQuotasRequest(server string, id TenantID, params *ListComputeQuotasParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/quotas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewCreateOrUpdateComputeQuotaRequest calls the generic CreateOrUpdateComputeQuota builder with application/json body
func NewCreateOrUpdateComputeQuotaRequest(server string, id TenantID, resourceType string, params *CreateOrUpdateComputeQuotaParams, body CreateOrUpdateComputeQuotaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateComputeQuotaRequestWithBody(server, id, resourceType, params, "application/json", bodyReader)
}

// NewCreateOrUpdateComputeQuotaRequestWithBody generates requests for CreateOrUpdateComputeQuota with any type of body
func NewCreateOrUpdateComputeQuotaRequestWithBody(server string, id TenantID, resourceType string, params *CreateOrUpdateComputeQuotaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/quotas/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewListSkusRequest generates requests for ListSkus
func NewListSkusRequest(server string, id TenantID, params *ListSkusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/skus", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewGetSkuRequest generates requests for GetSku
func NewGetSkuRequest(server string, id TenantID, name ResourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/skus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInstancesRequest generates requests for ListInstances
func NewListInstancesRequest(server string, id TenantID, workspace string, params *ListInstancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteInstanceRequest generates requests for DeleteInstance
func NewDeleteInstanceRequest(server string, id TenantID, workspace WorkspaceName, name ResourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstanceRequest generates requests for GetInstance
func NewGetInstanceRequest(server string, id TenantID, workspace WorkspaceName, name ResourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateInstanceRequest calls the generic CreateOrUpdateInstance builder with application/json body
func NewCreateOrUpdateInstanceRequest(server string, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateInstanceParams, body CreateOrUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateInstanceRequestWithBody(server, id, workspace, name, params, "application/json", bodyReader)
}

// NewCreateOrUpdateInstanceRequestWithBody generates requests for CreateOrUpdateInstance with any type of body
func NewCreateOrUpdateInstanceRequestWithBody(server string, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateInstanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewPowerCycleInstanceRequest generates requests for PowerCycleInstance
func NewPowerCycleInstanceRequest(server string, id TenantID, workspace WorkspaceName, name ResourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances/%s/power-cycle", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPowerOffInstanceRequest generates requests for PowerOffInstance
func NewPowerOffInstanceRequest(server string, id TenantID, workspace WorkspaceName, name ResourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances/%s/power-off", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPowerOnInstanceRequest generates requests for PowerOnInstance
func NewPowerOnInstanceRequest(server string, id TenantID, workspace WorkspaceName, name ResourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances/%s/power-on", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListComputeQuotasWithResponse request
	ListComputeQuotasWithResponse(ctx context.Context, id TenantID, params *ListComputeQuotasParams, reqEditors ...RequestEditorFn) (*ListComputeQuotasResponse, error)

	// CreateOrUpdateComputeQuotaWithBodyWithResponse request with any body
	CreateOrUpdateComputeQuotaWithBodyWithResponse(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateComputeQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateComputeQuotaResponse, error)

	CreateOrUpdateComputeQuotaWithResponse(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateComputeQuotaParams, body CreateOrUpdateComputeQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateComputeQuotaResponse, error)

	// ListSkusWithResponse request
	ListSkusWithResponse(ctx context.Context, id TenantID, params *ListSkusParams, reqEditors ...RequestEditorFn) (*ListSkusResponse, error)

	// GetSkuWithResponse request
	GetSkuWithResponse(ctx context.Context, id TenantID, name ResourceName, reqEditors ...RequestEditorFn) (*GetSkuResponse, error)

	// ListInstancesWithResponse request
	ListInstancesWithResponse(ctx context.Context, id TenantID, workspace string, params *ListInstancesParams, reqEditors ...RequestEditorFn) (*ListInstancesResponse, error)

	// DeleteInstanceWithResponse request
	DeleteInstanceWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*DeleteInstanceResponse, error)

	// GetInstanceWithResponse request
	GetInstanceWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*GetInstanceResponse, error)

	// CreateOrUpdateInstanceWithBodyWithResponse request with any body
	CreateOrUpdateInstanceWithBodyWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateInstanceResponse, error)

	CreateOrUpdateInstanceWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateInstanceParams, body CreateOrUpdateInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateInstanceResponse, error)

	// PowerCycleInstanceWithResponse request
	PowerCycleInstanceWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*PowerCycleInstanceResponse, error)

	// PowerOffInstanceWithResponse request
	PowerOffInstanceWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*PowerOffInstanceResponse, error)

	// PowerOnInstanceWithResponse request
	PowerOnInstanceWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*PowerOnInstanceResponse, error)
}

type ListComputeQuotasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]ResourceQuota  `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListComputeQuotasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListComputeQuotasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateComputeQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateComputeQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateComputeQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSkusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]InstanceSku    `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListSkusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSkusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSkuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstanceSku
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetSkuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSkuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]Instance       `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Instance
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PowerCycleInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r PowerCycleInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PowerCycleInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PowerOffInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r PowerOffInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PowerOffInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PowerOnInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r PowerOnInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PowerOnInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListComputeQuotasWithResponse request returning *ListComputeQuotasResponse
func (c *ClientWithResponses) ListComputeQuotasWithResponse(ctx context.Context, id TenantID, params *ListComputeQuotasParams, reqEditors ...RequestEditorFn) (*ListComputeQuotasResponse, error) {
	rsp, err := c.ListComputeQuotas(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListComputeQuotasResponse(rsp)
}

// CreateOrUpdateComputeQuotaWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateComputeQuotaResponse
func (c *ClientWithResponses) CreateOrUpdateComputeQuotaWithBodyWithResponse(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateComputeQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateComputeQuotaResponse, error) {
	rsp, err := c.CreateOrUpdateComputeQuotaWithBody(ctx, id, resourceType, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateComputeQuotaResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateComputeQuotaWithResponse(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateComputeQuotaParams, body CreateOrUpdateComputeQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateComputeQuotaResponse, error) {
	rsp, err := c.CreateOrUpdateComputeQuota(ctx, id, resourceType, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateComputeQuotaResponse(rsp)
}

// ListSkusWithResponse request returning *ListSkusResponse
func (c *ClientWithResponses) ListSkusWithResponse(ctx context.Context, id TenantID, params *ListSkusParams, reqEditors ...RequestEditorFn) (*ListSkusResponse, error) {
	rsp, err := c.ListSkus(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSkusResponse(rsp)
}

// GetSkuWithResponse request returning *GetSkuResponse
func (c *ClientWithResponses) GetSkuWithResponse(ctx context.Context, id TenantID, name ResourceName, reqEditors ...RequestEditorFn) (*GetSkuResponse, error) {
	rsp, err := c.GetSku(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSkuResponse(rsp)
}

// ListInstancesWithResponse request returning *ListInstancesResponse
func (c *ClientWithResponses) ListInstancesWithResponse(ctx context.Context, id TenantID, workspace string, params *ListInstancesParams, reqEditors ...RequestEditorFn) (*ListInstancesResponse, error) {
	rsp, err := c.ListInstances(ctx, id, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInstancesResponse(rsp)
}

// DeleteInstanceWithResponse request returning *DeleteInstanceResponse
func (c *ClientWithResponses) DeleteInstanceWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*DeleteInstanceResponse, error) {
	rsp, err := c.DeleteInstance(ctx, id, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInstanceResponse(rsp)
}

// GetInstanceWithResponse request returning *GetInstanceResponse
func (c *ClientWithResponses) GetInstanceWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*GetInstanceResponse, error) {
	rsp, err := c.GetInstance(ctx, id, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceResponse(rsp)
}

// CreateOrUpdateInstanceWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateInstanceResponse
func (c *ClientWithResponses) CreateOrUpdateInstanceWithBodyWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateInstanceResponse, error) {
	rsp, err := c.CreateOrUpdateInstanceWithBody(ctx, id, workspace, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateInstanceWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateInstanceParams, body CreateOrUpdateInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateInstanceResponse, error) {
	rsp, err := c.CreateOrUpdateInstance(ctx, id, workspace, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateInstanceResponse(rsp)
}

// PowerCycleInstanceWithResponse request returning *PowerCycleInstanceResponse
func (c *ClientWithResponses) PowerCycleInstanceWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*PowerCycleInstanceResponse, error) {
	rsp, err := c.PowerCycleInstance(ctx, id, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePowerCycleInstanceResponse(rsp)
}

// PowerOffInstanceWithResponse request returning *PowerOffInstanceResponse
func (c *ClientWithResponses) PowerOffInstanceWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*PowerOffInstanceResponse, error) {
	rsp, err := c.PowerOffInstance(ctx, id, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePowerOffInstanceResponse(rsp)
}

// PowerOnInstanceWithResponse request returning *PowerOnInstanceResponse
func (c *ClientWithResponses) PowerOnInstanceWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*PowerOnInstanceResponse, error) {
	rsp, err := c.PowerOnInstance(ctx, id, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePowerOnInstanceResponse(rsp)
}

// ParseListComputeQuotasResponse parses an HTTP response from a ListComputeQuotasWithResponse call
func ParseListComputeQuotasResponse(rsp *http.Response) (*ListComputeQuotasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListComputeQuotasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]ResourceQuota  `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateComputeQuotaResponse parses an HTTP response from a CreateOrUpdateComputeQuotaWithResponse call
func ParseCreateOrUpdateComputeQuotaResponse(rsp *http.Response) (*CreateOrUpdateComputeQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateComputeQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSkusResponse parses an HTTP response from a ListSkusWithResponse call
func ParseListSkusResponse(rsp *http.Response) (*ListSkusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSkusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]InstanceSku    `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSkuResponse parses an HTTP response from a GetSkuWithResponse call
func ParseGetSkuResponse(rsp *http.Response) (*GetSkuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSkuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstanceSku
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListInstancesResponse parses an HTTP response from a ListInstancesWithResponse call
func ParseListInstancesResponse(rsp *http.Response) (*ListInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]Instance       `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInstanceResponse parses an HTTP response from a DeleteInstanceWithResponse call
func ParseDeleteInstanceResponse(rsp *http.Response) (*DeleteInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInstanceResponse parses an HTTP response from a GetInstanceWithResponse call
func ParseGetInstanceResponse(rsp *http.Response) (*GetInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Instance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateInstanceResponse parses an HTTP response from a CreateOrUpdateInstanceWithResponse call
func ParseCreateOrUpdateInstanceResponse(rsp *http.Response) (*CreateOrUpdateInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePowerCycleInstanceResponse parses an HTTP response from a PowerCycleInstanceWithResponse call
func ParsePowerCycleInstanceResponse(rsp *http.Response) (*PowerCycleInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PowerCycleInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePowerOffInstanceResponse parses an HTTP response from a PowerOffInstanceWithResponse call
func ParsePowerOffInstanceResponse(rsp *http.Response) (*PowerOffInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PowerOffInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePowerOnInstanceResponse parses an HTTP response from a PowerOnInstanceWithResponse call
func ParsePowerOnInstanceResponse(rsp *http.Response) (*PowerOnInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PowerOnInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List current Compute Provider Resource Quotas
	// (GET /v1/tenants/{id}/quotas)
	ListComputeQuotas(w http.ResponseWriter, r *http.Request, id TenantID, params ListComputeQuotasParams)
	// Create or update the resource quota for the Compute Resource Provider
	// (PUT /v1/tenants/{id}/quotas/{resourceType})
	CreateOrUpdateComputeQuota(w http.ResponseWriter, r *http.Request, id TenantID, resourceType string, params CreateOrUpdateComputeQuotaParams)
	// List available SKUs for compute instances
	// (GET /v1/tenants/{id}/skus)
	ListSkus(w http.ResponseWriter, r *http.Request, id TenantID, params ListSkusParams)
	// Get details of a specific SKU
	// (GET /v1/tenants/{id}/skus/{name})
	GetSku(w http.ResponseWriter, r *http.Request, id TenantID, name ResourceName)
	// List all instances
	// (GET /v1/tenants/{id}/workspaces/{workspace}/instances)
	ListInstances(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, params ListInstancesParams)
	// Delete a specific instance
	// (DELETE /v1/tenants/{id}/workspaces/{workspace}/instances/{name})
	DeleteInstance(w http.ResponseWriter, r *http.Request, id TenantID, workspace WorkspaceName, name ResourceName)
	// Get a specific instance
	// (GET /v1/tenants/{id}/workspaces/{workspace}/instances/{name})
	GetInstance(w http.ResponseWriter, r *http.Request, id TenantID, workspace WorkspaceName, name ResourceName)
	// Create or update a specific instance
	// (PUT /v1/tenants/{id}/workspaces/{workspace}/instances/{name})
	CreateOrUpdateInstance(w http.ResponseWriter, r *http.Request, id TenantID, workspace WorkspaceName, name ResourceName, params CreateOrUpdateInstanceParams)
	// Power cycle a specific instance
	// (POST /v1/tenants/{id}/workspaces/{workspace}/instances/{name}/power-cycle)
	PowerCycleInstance(w http.ResponseWriter, r *http.Request, id TenantID, workspace WorkspaceName, name ResourceName)
	// Power off a specific instance
	// (POST /v1/tenants/{id}/workspaces/{workspace}/instances/{name}/power-off)
	PowerOffInstance(w http.ResponseWriter, r *http.Request, id TenantID, workspace WorkspaceName, name ResourceName)
	// Power on a specific instance
	// (POST /v1/tenants/{id}/workspaces/{workspace}/instances/{name}/power-on)
	PowerOnInstance(w http.ResponseWriter, r *http.Request, id TenantID, workspace WorkspaceName, name ResourceName)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListComputeQuotas operation middleware
func (siw *ServerInterfaceWrapper) ListComputeQuotas(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListComputeQuotasParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListComputeQuotasParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListComputeQuotas(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateComputeQuota operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateComputeQuota(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "resourceType" -------------
	var resourceType string

	err = runtime.BindStyledParameterWithOptions("simple", "resourceType", r.PathValue("resourceType"), &resourceType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "resourceType", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateComputeQuotaParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateComputeQuota(w, r, id, resourceType, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListSkus operation middleware
func (siw *ServerInterfaceWrapper) ListSkus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSkusParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListSkusParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSkus(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSku operation middleware
func (siw *ServerInterfaceWrapper) GetSku(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSku(w, r, id, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListInstances operation middleware
func (siw *ServerInterfaceWrapper) ListInstances(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListInstancesParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListInstancesParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListInstances(w, r, id, workspace, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteInstance operation middleware
func (siw *ServerInterfaceWrapper) DeleteInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceName

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteInstance(w, r, id, workspace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetInstance operation middleware
func (siw *ServerInterfaceWrapper) GetInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceName

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInstance(w, r, id, workspace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateInstance operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceName

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateInstanceParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateInstance(w, r, id, workspace, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PowerCycleInstance operation middleware
func (siw *ServerInterfaceWrapper) PowerCycleInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceName

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PowerCycleInstance(w, r, id, workspace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PowerOffInstance operation middleware
func (siw *ServerInterfaceWrapper) PowerOffInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceName

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PowerOffInstance(w, r, id, workspace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PowerOnInstance operation middleware
func (siw *ServerInterfaceWrapper) PowerOnInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceName

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PowerOnInstance(w, r, id, workspace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/quotas", wrapper.ListComputeQuotas)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/quotas/{resourceType}", wrapper.CreateOrUpdateComputeQuota)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/skus", wrapper.ListSkus)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/skus/{name}", wrapper.GetSku)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/instances", wrapper.ListInstances)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/instances/{name}", wrapper.DeleteInstance)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/instances/{name}", wrapper.GetInstance)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/instances/{name}", wrapper.CreateOrUpdateInstance)
	m.HandleFunc("POST "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/instances/{name}/power-cycle", wrapper.PowerCycleInstance)
	m.HandleFunc("POST "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/instances/{name}/power-off", wrapper.PowerOffInstance)
	m.HandleFunc("POST "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/instances/{name}/power-on", wrapper.PowerOnInstance)

	return m
}
