//go:build go1.22

// Package loadbalancer provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package loadbalancer

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for LoadBalancerTargetAlgorithm.
const (
	ROUNDROBIN LoadBalancerTargetAlgorithm = "ROUND_ROBIN"
)

// Defines values for LoadBalancerTargetProtocol.
const (
	LoadBalancerTargetProtocolTCP LoadBalancerTargetProtocol = "TCP"
	LoadBalancerTargetProtocolUDP LoadBalancerTargetProtocol = "UDP"
)

// Defines values for NetworkLoadBalancerFrontendProtocol.
const (
	NetworkLoadBalancerFrontendProtocolTCP NetworkLoadBalancerFrontendProtocol = "TCP"
	NetworkLoadBalancerFrontendProtocolUDP NetworkLoadBalancerFrontendProtocol = "UDP"
)

// Defines values for RegionalResourceMetadataKind.
const (
	RegionalResourceMetadataKindActivityLog          RegionalResourceMetadataKind = "activity-log"
	RegionalResourceMetadataKindBlockStorage         RegionalResourceMetadataKind = "block-storage"
	RegionalResourceMetadataKindImage                RegionalResourceMetadataKind = "image"
	RegionalResourceMetadataKindInstance             RegionalResourceMetadataKind = "instance"
	RegionalResourceMetadataKindInstanceSku          RegionalResourceMetadataKind = "instance-sku"
	RegionalResourceMetadataKindLan                  RegionalResourceMetadataKind = "lan"
	RegionalResourceMetadataKindLocation             RegionalResourceMetadataKind = "location"
	RegionalResourceMetadataKindNetworkLoadBalancer  RegionalResourceMetadataKind = "network-load-balancer"
	RegionalResourceMetadataKindNetworkSku           RegionalResourceMetadataKind = "network-sku"
	RegionalResourceMetadataKindNic                  RegionalResourceMetadataKind = "nic"
	RegionalResourceMetadataKindObjectStorageAccount RegionalResourceMetadataKind = "object-storage-account"
	RegionalResourceMetadataKindPublicIp             RegionalResourceMetadataKind = "public-ip"
	RegionalResourceMetadataKindQuota                RegionalResourceMetadataKind = "quota"
	RegionalResourceMetadataKindRegion               RegionalResourceMetadataKind = "region"
	RegionalResourceMetadataKindRole                 RegionalResourceMetadataKind = "role"
	RegionalResourceMetadataKindRoleAssignment       RegionalResourceMetadataKind = "role-assignment"
	RegionalResourceMetadataKindRoutingTable         RegionalResourceMetadataKind = "routing-table"
	RegionalResourceMetadataKindSecurityGroup        RegionalResourceMetadataKind = "security-group"
	RegionalResourceMetadataKindSecurityGroupRule    RegionalResourceMetadataKind = "security-group-rule"
	RegionalResourceMetadataKindStorageSku           RegionalResourceMetadataKind = "storage-sku"
	RegionalResourceMetadataKindSubnet               RegionalResourceMetadataKind = "subnet"
	RegionalResourceMetadataKindWorkspace            RegionalResourceMetadataKind = "workspace"
)

// Defines values for ResourceStatePhase.
const (
	ResourceStatePhaseActive    ResourceStatePhase = "active"
	ResourceStatePhaseCreating  ResourceStatePhase = "creating"
	ResourceStatePhaseDeleting  ResourceStatePhase = "deleting"
	ResourceStatePhaseError     ResourceStatePhase = "error"
	ResourceStatePhasePending   ResourceStatePhase = "pending"
	ResourceStatePhaseSuspended ResourceStatePhase = "suspended"
	ResourceStatePhaseUpdating  ResourceStatePhase = "updating"
)

// Defines values for TypeMetadataKind.
const (
	TypeMetadataKindActivityLog          TypeMetadataKind = "activity-log"
	TypeMetadataKindBlockStorage         TypeMetadataKind = "block-storage"
	TypeMetadataKindImage                TypeMetadataKind = "image"
	TypeMetadataKindInstance             TypeMetadataKind = "instance"
	TypeMetadataKindInstanceSku          TypeMetadataKind = "instance-sku"
	TypeMetadataKindLan                  TypeMetadataKind = "lan"
	TypeMetadataKindLocation             TypeMetadataKind = "location"
	TypeMetadataKindNetworkLoadBalancer  TypeMetadataKind = "network-load-balancer"
	TypeMetadataKindNetworkSku           TypeMetadataKind = "network-sku"
	TypeMetadataKindNic                  TypeMetadataKind = "nic"
	TypeMetadataKindObjectStorageAccount TypeMetadataKind = "object-storage-account"
	TypeMetadataKindPublicIp             TypeMetadataKind = "public-ip"
	TypeMetadataKindQuota                TypeMetadataKind = "quota"
	TypeMetadataKindRegion               TypeMetadataKind = "region"
	TypeMetadataKindRole                 TypeMetadataKind = "role"
	TypeMetadataKindRoleAssignment       TypeMetadataKind = "role-assignment"
	TypeMetadataKindRoutingTable         TypeMetadataKind = "routing-table"
	TypeMetadataKindSecurityGroup        TypeMetadataKind = "security-group"
	TypeMetadataKindSecurityGroupRule    TypeMetadataKind = "security-group-rule"
	TypeMetadataKindStorageSku           TypeMetadataKind = "storage-sku"
	TypeMetadataKindSubnet               TypeMetadataKind = "subnet"
	TypeMetadataKindWorkspace            TypeMetadataKind = "workspace"
)

// Defines values for AcceptHeader.
const (
	AcceptHeaderApplicationjson            AcceptHeader = "application/json"
	AcceptHeaderApplicationjsonDeletedOnly AcceptHeader = "application/json; deleted=only"
	AcceptHeaderApplicationjsonDeletedTrue AcceptHeader = "application/json; deleted=true"
)

// Defines values for ListNetworkLoadBalancersParamsAccept.
const (
	ListNetworkLoadBalancersParamsAcceptApplicationjson            ListNetworkLoadBalancersParamsAccept = "application/json"
	ListNetworkLoadBalancersParamsAcceptApplicationjsonDeletedOnly ListNetworkLoadBalancersParamsAccept = "application/json; deleted=only"
	ListNetworkLoadBalancersParamsAcceptApplicationjsonDeletedTrue ListNetworkLoadBalancersParamsAccept = "application/json; deleted=true"
)

// Error A generic error response
type Error struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error400 defines model for Error400.
type Error400 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error401 defines model for Error401.
type Error401 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error403 defines model for Error403.
type Error403 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error404 defines model for Error404.
type Error404 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error412 defines model for Error412.
type Error412 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error422 defines model for Error422.
type Error422 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error500 defines model for Error500.
type Error500 struct {
	Errors []ErrorDetail `json:"errors"`
}

// ErrorDetail A detailed error response
type ErrorDetail struct {
	// Code An application-specific error code, expressed as a string value.
	Code string `json:"code"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta map[string]interface{} `json:"meta"`

	// Source An object containing references to the source of the error.
	Source *ErrorSource `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem.
	Title string `json:"title"`
}

// ErrorSource An object containing references to the source of the error.
type ErrorSource struct {
	// Parameter A string indicating which URI query parameter caused the error.
	Parameter string `json:"parameter"`

	// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
	Pointer string `json:"pointer"`
}

// LoadBalancerHealthCheck Optional port health check. It probes the port with protocol.
type LoadBalancerHealthCheck struct {
	// Interval healthcheck interval in seconds. It means after how many seconds it will take a new check
	Interval *int `json:"interval,omitempty"`

	// Retry healthcheck retry number after considered unhealthy a backend istance
	Retry *int `json:"retry,omitempty"`

	// Timeout healthcheck in seconds. It means after how many seconds the attempt will be considered unhealthy
	Timeout *int `json:"timeout,omitempty"`
}

// LoadBalancerMember defines model for LoadBalancerMember.
type LoadBalancerMember struct {
	// NicRef Nic Reference to the LoadBalancerMember as part of the LoadBalancerTarget
	NicRef *string `json:"nicRef,omitempty"`
}

// LoadBalancerTarget defines model for LoadBalancerTarget.
type LoadBalancerTarget struct {
	// Algorithm LoadBalancer algorithm to take a backend istance
	Algorithm *LoadBalancerTargetAlgorithm `json:"algorithm,omitempty"`

	// Healthcheck Optional port health check. It probes the port with protocol.
	Healthcheck *LoadBalancerHealthCheck `json:"healthcheck,omitempty"`
	Members     *[]LoadBalancerMember    `json:"members,omitempty"`

	// Port A valid network port number.
	Port *int32 `json:"port,omitempty"`

	// Protocol Frontend Protocol to which the load balancer will be listening on
	Protocol *LoadBalancerTargetProtocol `json:"protocol,omitempty"`
}

// LoadBalancerTargetAlgorithm LoadBalancer algorithm to take a backend istance
type LoadBalancerTargetAlgorithm string

// LoadBalancerTargetProtocol Frontend Protocol to which the load balancer will be listening on
type LoadBalancerTargetProtocol string

// ModificationMetadata Base metadata for all resources with optional location references
type ModificationMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp time.Time `json:"deletionTimestamp"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp time.Time `json:"lastModifiedTimestamp"`
}

// NameMetadata defines model for NameMetadata.
type NameMetadata struct {
	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name string `json:"name"`
}

// NetworkLoadBalancer defines model for NetworkLoadBalancer.
type NetworkLoadBalancer struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	Labels   *map[string]string         `json:"labels,omitempty"`
	Metadata *RegionalResourceMetadata  `json:"metadata,omitempty"`
	Spec     NetworkLoadBalancerSpec    `json:"spec"`
	Status   *NetworkLoadBalancerStatus `json:"status,omitempty"`
}

// NetworkLoadBalancerFrontend defines model for NetworkLoadBalancerFrontend.
type NetworkLoadBalancerFrontend struct {
	// NicRef NIC reference to the LoadBalancer. If ipAddressType will be ipv4 or dual-stack or if the LoadBalancer will be internal or external depends on the associated NIC
	NicRef *string `json:"nicRef,omitempty"`

	// Port A valid network port number.
	Port *int32 `json:"port,omitempty"`

	// Protocol Frontend Protocol to which the load balancer will be listening on
	Protocol *NetworkLoadBalancerFrontendProtocol `json:"protocol,omitempty"`
	Target   *LoadBalancerTarget                  `json:"target,omitempty"`
}

// NetworkLoadBalancerFrontendProtocol Frontend Protocol to which the load balancer will be listening on
type NetworkLoadBalancerFrontendProtocol string

// NetworkLoadBalancerSpec defines model for NetworkLoadBalancerSpec.
type NetworkLoadBalancerSpec struct {
	IpConfigurations *[]NetworkLoadBalancerFrontend `json:"ipConfigurations,omitempty"`
	Profile          *struct {
		// NetworkLoadBalancerSkuRef Reference to the SKU used for this network-load-balancer
		NetworkLoadBalancerSkuRef *string `json:"networkLoadBalancerSkuRef,omitempty"`
	} `json:"profile,omitempty"`
}

// NetworkLoadBalancerStatus defines model for NetworkLoadBalancerStatus.
type NetworkLoadBalancerStatus struct {
	Conditions              []StatusCondition              `json:"conditions"`
	IpConfigurations        *[]NetworkLoadBalancerFrontend `json:"ipConfigurations,omitempty"`
	IpConfigurationsHealthy *[]NetworkLoadBalancerFrontend `json:"ipConfigurationsHealthy,omitempty"`

	// State Generic state definition for all resources. All states are optional, but must not have more states.
	// If a provider wants to present fine granular states, please use conditions.
	State *ResourceState `json:"state,omitempty"`
}

// RegionalMetadata Metadata for regional resources
type RegionalMetadata struct {
	// Region Reference to the region where the resource is located
	Region string `json:"region"`

	// Workspace Workspace identifier
	Workspace *string `json:"workspace,omitempty"`
}

// RegionalResourceMetadata defines model for RegionalResourceMetadata.
type RegionalResourceMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp time.Time `json:"deletionTimestamp"`

	// Kind Type of the resource
	Kind RegionalResourceMetadataKind `json:"kind"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp time.Time `json:"lastModifiedTimestamp"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name string `json:"name"`

	// Region Reference to the region where the resource is located
	Region string `json:"region"`

	// Tenant Tenant identifier
	Tenant string `json:"tenant"`

	// Workspace Workspace identifier
	Workspace *string `json:"workspace,omitempty"`
}

// RegionalResourceMetadataKind Type of the resource
type RegionalResourceMetadataKind string

// ResourceState Generic state definition for all resources. All states are optional, but must not have more states.
// If a provider wants to present fine granular states, please use conditions.
type ResourceState struct {
	// Phase Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	Phase *ResourceStatePhase `json:"phase,omitempty"`
}

// ResourceStatePhase Current phase of the resource:
// - pending: not available, waiting for other resources
// - creating: not available, creation started
// - active: available for data layer usage
// - updating: available for data layer usage
// - deleting: maybe still available for data layer user, can fail any moment
// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
// - error: failed to fulfill the request; would be related to provider issue or customer related input.
type ResourceStatePhase string

// ResponseMetadata defines model for ResponseMetadata.
type ResponseMetadata struct {
	// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
	SkipToken *string `json:"skipToken,omitempty"`
}

// Status Current status of the resource
type Status struct {
	Conditions []StatusCondition `json:"conditions"`
}

// StatusCondition StatusCondition describes the state of a resource at a certain point.
// Conditions are provider-specific and can represent different states depending on the
// resource type and provider implementation.
type StatusCondition struct {
	// LastTransitionTime LastTransitionTime is the last time the condition transitioned from one
	// status to another. This should be when the underlying condition changed.
	// If that is not known, then using the time when the API field changed is
	// acceptable.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message A human-readable message indicating details about the transition.
	Message *string `json:"message,omitempty"`

	// Reason The reason for the condition's last transition in CamelCase.
	// The specific set of reason values is provider-specific and should be
	// documented by the provider.
	Reason *string `json:"reason,omitempty"`

	// Status Status of the condition.
	Status string `json:"status"`

	// Type Type of condition. The condition type is provider-specific and should
	// reflect the specific states relevant to your resource.
	Type string `json:"type"`
}

// TenantMetadata Metadata for global resources with tenant constraints
type TenantMetadata struct {
	// Tenant Tenant identifier
	Tenant string `json:"tenant"`
}

// TypeMetadata defines model for TypeMetadata.
type TypeMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// Kind Type of the resource
	Kind TypeMetadataKind `json:"kind"`
}

// TypeMetadataKind Type of the resource
type TypeMetadataKind string

// UserResourceMetadata defines model for UserResourceMetadata.
type UserResourceMetadata struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	Labels *map[string]string `json:"labels,omitempty"`
}

// AcceptHeader defines model for acceptHeader.
type AcceptHeader string

// IfUnmodifiedSince defines model for ifUnmodifiedSince.
type IfUnmodifiedSince = time.Time

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// TenantID defines model for tenantID.
type TenantID = string

// ListNetworkLoadBalancersParams defines parameters for ListNetworkLoadBalancers.
type ListNetworkLoadBalancersParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListNetworkLoadBalancersParamsAccept `json:"Accept,omitempty"`
}

// ListNetworkLoadBalancersParamsAccept defines parameters for ListNetworkLoadBalancers.
type ListNetworkLoadBalancersParamsAccept string

// CreateOrUpdateNetworkLoadBalancerParams defines parameters for CreateOrUpdateNetworkLoadBalancer.
type CreateOrUpdateNetworkLoadBalancerParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateNetworkLoadBalancerJSONRequestBody defines body for CreateOrUpdateNetworkLoadBalancer for application/json ContentType.
type CreateOrUpdateNetworkLoadBalancerJSONRequestBody = NetworkLoadBalancer

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListNetworkLoadBalancers request
	ListNetworkLoadBalancers(ctx context.Context, id TenantID, workspace string, params *ListNetworkLoadBalancersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNetworkLoadBalancer request
	DeleteNetworkLoadBalancer(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkLoadBalancer request
	GetNetworkLoadBalancer(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateNetworkLoadBalancerWithBody request with any body
	CreateOrUpdateNetworkLoadBalancerWithBody(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, params *CreateOrUpdateNetworkLoadBalancerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateNetworkLoadBalancer(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, params *CreateOrUpdateNetworkLoadBalancerParams, body CreateOrUpdateNetworkLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListNetworkLoadBalancers(ctx context.Context, id TenantID, workspace string, params *ListNetworkLoadBalancersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNetworkLoadBalancersRequest(c.Server, id, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNetworkLoadBalancer(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNetworkLoadBalancerRequest(c.Server, id, workspace, networkLoadBalancerName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkLoadBalancer(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkLoadBalancerRequest(c.Server, id, workspace, networkLoadBalancerName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateNetworkLoadBalancerWithBody(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, params *CreateOrUpdateNetworkLoadBalancerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateNetworkLoadBalancerRequestWithBody(c.Server, id, workspace, networkLoadBalancerName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateNetworkLoadBalancer(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, params *CreateOrUpdateNetworkLoadBalancerParams, body CreateOrUpdateNetworkLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateNetworkLoadBalancerRequest(c.Server, id, workspace, networkLoadBalancerName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListNetworkLoadBalancersRequest generates requests for ListNetworkLoadBalancers
func NewListNetworkLoadBalancersRequest(server string, id TenantID, workspace string, params *ListNetworkLoadBalancersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/network-load-balancers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteNetworkLoadBalancerRequest generates requests for DeleteNetworkLoadBalancer
func NewDeleteNetworkLoadBalancerRequest(server string, id TenantID, workspace string, networkLoadBalancerName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "network-load-balancer-name", runtime.ParamLocationPath, networkLoadBalancerName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/network-load-balancers/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetworkLoadBalancerRequest generates requests for GetNetworkLoadBalancer
func NewGetNetworkLoadBalancerRequest(server string, id TenantID, workspace string, networkLoadBalancerName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "network-load-balancer-name", runtime.ParamLocationPath, networkLoadBalancerName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/network-load-balancers/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateNetworkLoadBalancerRequest calls the generic CreateOrUpdateNetworkLoadBalancer builder with application/json body
func NewCreateOrUpdateNetworkLoadBalancerRequest(server string, id TenantID, workspace string, networkLoadBalancerName string, params *CreateOrUpdateNetworkLoadBalancerParams, body CreateOrUpdateNetworkLoadBalancerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateNetworkLoadBalancerRequestWithBody(server, id, workspace, networkLoadBalancerName, params, "application/json", bodyReader)
}

// NewCreateOrUpdateNetworkLoadBalancerRequestWithBody generates requests for CreateOrUpdateNetworkLoadBalancer with any type of body
func NewCreateOrUpdateNetworkLoadBalancerRequestWithBody(server string, id TenantID, workspace string, networkLoadBalancerName string, params *CreateOrUpdateNetworkLoadBalancerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "network-load-balancer-name", runtime.ParamLocationPath, networkLoadBalancerName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/network-load-balancers/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListNetworkLoadBalancersWithResponse request
	ListNetworkLoadBalancersWithResponse(ctx context.Context, id TenantID, workspace string, params *ListNetworkLoadBalancersParams, reqEditors ...RequestEditorFn) (*ListNetworkLoadBalancersResponse, error)

	// DeleteNetworkLoadBalancerWithResponse request
	DeleteNetworkLoadBalancerWithResponse(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, reqEditors ...RequestEditorFn) (*DeleteNetworkLoadBalancerResponse, error)

	// GetNetworkLoadBalancerWithResponse request
	GetNetworkLoadBalancerWithResponse(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, reqEditors ...RequestEditorFn) (*GetNetworkLoadBalancerResponse, error)

	// CreateOrUpdateNetworkLoadBalancerWithBodyWithResponse request with any body
	CreateOrUpdateNetworkLoadBalancerWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, params *CreateOrUpdateNetworkLoadBalancerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateNetworkLoadBalancerResponse, error)

	CreateOrUpdateNetworkLoadBalancerWithResponse(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, params *CreateOrUpdateNetworkLoadBalancerParams, body CreateOrUpdateNetworkLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateNetworkLoadBalancerResponse, error)
}

type ListNetworkLoadBalancersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]NetworkLoadBalancer `json:"items,omitempty"`
		Metadata *ResponseMetadata      `json:"metadata,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListNetworkLoadBalancersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNetworkLoadBalancersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNetworkLoadBalancerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteNetworkLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNetworkLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkLoadBalancerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkLoadBalancer
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetNetworkLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateNetworkLoadBalancerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateNetworkLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateNetworkLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListNetworkLoadBalancersWithResponse request returning *ListNetworkLoadBalancersResponse
func (c *ClientWithResponses) ListNetworkLoadBalancersWithResponse(ctx context.Context, id TenantID, workspace string, params *ListNetworkLoadBalancersParams, reqEditors ...RequestEditorFn) (*ListNetworkLoadBalancersResponse, error) {
	rsp, err := c.ListNetworkLoadBalancers(ctx, id, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNetworkLoadBalancersResponse(rsp)
}

// DeleteNetworkLoadBalancerWithResponse request returning *DeleteNetworkLoadBalancerResponse
func (c *ClientWithResponses) DeleteNetworkLoadBalancerWithResponse(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, reqEditors ...RequestEditorFn) (*DeleteNetworkLoadBalancerResponse, error) {
	rsp, err := c.DeleteNetworkLoadBalancer(ctx, id, workspace, networkLoadBalancerName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNetworkLoadBalancerResponse(rsp)
}

// GetNetworkLoadBalancerWithResponse request returning *GetNetworkLoadBalancerResponse
func (c *ClientWithResponses) GetNetworkLoadBalancerWithResponse(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, reqEditors ...RequestEditorFn) (*GetNetworkLoadBalancerResponse, error) {
	rsp, err := c.GetNetworkLoadBalancer(ctx, id, workspace, networkLoadBalancerName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkLoadBalancerResponse(rsp)
}

// CreateOrUpdateNetworkLoadBalancerWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateNetworkLoadBalancerResponse
func (c *ClientWithResponses) CreateOrUpdateNetworkLoadBalancerWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, params *CreateOrUpdateNetworkLoadBalancerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateNetworkLoadBalancerResponse, error) {
	rsp, err := c.CreateOrUpdateNetworkLoadBalancerWithBody(ctx, id, workspace, networkLoadBalancerName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateNetworkLoadBalancerResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateNetworkLoadBalancerWithResponse(ctx context.Context, id TenantID, workspace string, networkLoadBalancerName string, params *CreateOrUpdateNetworkLoadBalancerParams, body CreateOrUpdateNetworkLoadBalancerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateNetworkLoadBalancerResponse, error) {
	rsp, err := c.CreateOrUpdateNetworkLoadBalancer(ctx, id, workspace, networkLoadBalancerName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateNetworkLoadBalancerResponse(rsp)
}

// ParseListNetworkLoadBalancersResponse parses an HTTP response from a ListNetworkLoadBalancersWithResponse call
func ParseListNetworkLoadBalancersResponse(rsp *http.Response) (*ListNetworkLoadBalancersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNetworkLoadBalancersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]NetworkLoadBalancer `json:"items,omitempty"`
			Metadata *ResponseMetadata      `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteNetworkLoadBalancerResponse parses an HTTP response from a DeleteNetworkLoadBalancerWithResponse call
func ParseDeleteNetworkLoadBalancerResponse(rsp *http.Response) (*DeleteNetworkLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNetworkLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNetworkLoadBalancerResponse parses an HTTP response from a GetNetworkLoadBalancerWithResponse call
func ParseGetNetworkLoadBalancerResponse(rsp *http.Response) (*GetNetworkLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkLoadBalancer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateNetworkLoadBalancerResponse parses an HTTP response from a CreateOrUpdateNetworkLoadBalancerWithResponse call
func ParseCreateOrUpdateNetworkLoadBalancerResponse(rsp *http.Response) (*CreateOrUpdateNetworkLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateNetworkLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all NetworkLoadBalancers
	// (GET /v1/tenants/{id}/workspaces/{workspace}/network-load-balancers)
	ListNetworkLoadBalancers(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, params ListNetworkLoadBalancersParams)
	// Delete a specific NetworkLoadBalancer
	// (DELETE /v1/tenants/{id}/workspaces/{workspace}/network-load-balancers/{network-load-balancer-name})
	DeleteNetworkLoadBalancer(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, networkLoadBalancerName string)
	// Get a Network Load Balancer
	// (GET /v1/tenants/{id}/workspaces/{workspace}/network-load-balancers/{network-load-balancer-name})
	GetNetworkLoadBalancer(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, networkLoadBalancerName string)
	// Create or update a specific Network-Load-Balancer
	// (PUT /v1/tenants/{id}/workspaces/{workspace}/network-load-balancers/{network-load-balancer-name})
	CreateOrUpdateNetworkLoadBalancer(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, networkLoadBalancerName string, params CreateOrUpdateNetworkLoadBalancerParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListNetworkLoadBalancers operation middleware
func (siw *ServerInterfaceWrapper) ListNetworkLoadBalancers(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNetworkLoadBalancersParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListNetworkLoadBalancersParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNetworkLoadBalancers(w, r, id, workspace, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteNetworkLoadBalancer operation middleware
func (siw *ServerInterfaceWrapper) DeleteNetworkLoadBalancer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "network-load-balancer-name" -------------
	var networkLoadBalancerName string

	err = runtime.BindStyledParameterWithOptions("simple", "network-load-balancer-name", r.PathValue("network-load-balancer-name"), &networkLoadBalancerName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "network-load-balancer-name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteNetworkLoadBalancer(w, r, id, workspace, networkLoadBalancerName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetNetworkLoadBalancer operation middleware
func (siw *ServerInterfaceWrapper) GetNetworkLoadBalancer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "network-load-balancer-name" -------------
	var networkLoadBalancerName string

	err = runtime.BindStyledParameterWithOptions("simple", "network-load-balancer-name", r.PathValue("network-load-balancer-name"), &networkLoadBalancerName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "network-load-balancer-name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNetworkLoadBalancer(w, r, id, workspace, networkLoadBalancerName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateNetworkLoadBalancer operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateNetworkLoadBalancer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "network-load-balancer-name" -------------
	var networkLoadBalancerName string

	err = runtime.BindStyledParameterWithOptions("simple", "network-load-balancer-name", r.PathValue("network-load-balancer-name"), &networkLoadBalancerName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "network-load-balancer-name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateNetworkLoadBalancerParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateNetworkLoadBalancer(w, r, id, workspace, networkLoadBalancerName, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/network-load-balancers", wrapper.ListNetworkLoadBalancers)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/network-load-balancers/{network-load-balancer-name}", wrapper.DeleteNetworkLoadBalancer)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/network-load-balancers/{network-load-balancer-name}", wrapper.GetNetworkLoadBalancer)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/network-load-balancers/{network-load-balancer-name}", wrapper.CreateOrUpdateNetworkLoadBalancer)

	return m
}
