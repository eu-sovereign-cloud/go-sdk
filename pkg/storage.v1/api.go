//go:build go1.22

// Package storage provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package storage

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for RegionalResourceMetadataKind.
const (
	RegionalResourceMetadataKindActivityLog          RegionalResourceMetadataKind = "activity-log"
	RegionalResourceMetadataKindBlockStorage         RegionalResourceMetadataKind = "block-storage"
	RegionalResourceMetadataKindImage                RegionalResourceMetadataKind = "image"
	RegionalResourceMetadataKindInstance             RegionalResourceMetadataKind = "instance"
	RegionalResourceMetadataKindInstanceSku          RegionalResourceMetadataKind = "instance-sku"
	RegionalResourceMetadataKindLan                  RegionalResourceMetadataKind = "lan"
	RegionalResourceMetadataKindLocation             RegionalResourceMetadataKind = "location"
	RegionalResourceMetadataKindNetworkLoadBalancer  RegionalResourceMetadataKind = "network-load-balancer"
	RegionalResourceMetadataKindNetworkSku           RegionalResourceMetadataKind = "network-sku"
	RegionalResourceMetadataKindNic                  RegionalResourceMetadataKind = "nic"
	RegionalResourceMetadataKindObjectStorageAccount RegionalResourceMetadataKind = "object-storage-account"
	RegionalResourceMetadataKindPublicIp             RegionalResourceMetadataKind = "public-ip"
	RegionalResourceMetadataKindQuota                RegionalResourceMetadataKind = "quota"
	RegionalResourceMetadataKindRegion               RegionalResourceMetadataKind = "region"
	RegionalResourceMetadataKindRole                 RegionalResourceMetadataKind = "role"
	RegionalResourceMetadataKindRoleAssignment       RegionalResourceMetadataKind = "role-assignment"
	RegionalResourceMetadataKindRoutingTable         RegionalResourceMetadataKind = "routing-table"
	RegionalResourceMetadataKindSecurityGroup        RegionalResourceMetadataKind = "security-group"
	RegionalResourceMetadataKindSecurityGroupRule    RegionalResourceMetadataKind = "security-group-rule"
	RegionalResourceMetadataKindStorageSku           RegionalResourceMetadataKind = "storage-sku"
	RegionalResourceMetadataKindSubnet               RegionalResourceMetadataKind = "subnet"
	RegionalResourceMetadataKindWorkspace            RegionalResourceMetadataKind = "workspace"
)

// Defines values for ResourceStatePhase.
const (
	ResourceStatePhaseActive    ResourceStatePhase = "active"
	ResourceStatePhaseCreating  ResourceStatePhase = "creating"
	ResourceStatePhaseDeleting  ResourceStatePhase = "deleting"
	ResourceStatePhaseError     ResourceStatePhase = "error"
	ResourceStatePhasePending   ResourceStatePhase = "pending"
	ResourceStatePhaseSuspended ResourceStatePhase = "suspended"
	ResourceStatePhaseUpdating  ResourceStatePhase = "updating"
)

// Defines values for TypeMetadataKind.
const (
	TypeMetadataKindActivityLog          TypeMetadataKind = "activity-log"
	TypeMetadataKindBlockStorage         TypeMetadataKind = "block-storage"
	TypeMetadataKindImage                TypeMetadataKind = "image"
	TypeMetadataKindInstance             TypeMetadataKind = "instance"
	TypeMetadataKindInstanceSku          TypeMetadataKind = "instance-sku"
	TypeMetadataKindLan                  TypeMetadataKind = "lan"
	TypeMetadataKindLocation             TypeMetadataKind = "location"
	TypeMetadataKindNetworkLoadBalancer  TypeMetadataKind = "network-load-balancer"
	TypeMetadataKindNetworkSku           TypeMetadataKind = "network-sku"
	TypeMetadataKindNic                  TypeMetadataKind = "nic"
	TypeMetadataKindObjectStorageAccount TypeMetadataKind = "object-storage-account"
	TypeMetadataKindPublicIp             TypeMetadataKind = "public-ip"
	TypeMetadataKindQuota                TypeMetadataKind = "quota"
	TypeMetadataKindRegion               TypeMetadataKind = "region"
	TypeMetadataKindRole                 TypeMetadataKind = "role"
	TypeMetadataKindRoleAssignment       TypeMetadataKind = "role-assignment"
	TypeMetadataKindRoutingTable         TypeMetadataKind = "routing-table"
	TypeMetadataKindSecurityGroup        TypeMetadataKind = "security-group"
	TypeMetadataKindSecurityGroupRule    TypeMetadataKind = "security-group-rule"
	TypeMetadataKindStorageSku           TypeMetadataKind = "storage-sku"
	TypeMetadataKindSubnet               TypeMetadataKind = "subnet"
	TypeMetadataKindWorkspace            TypeMetadataKind = "workspace"
)

// Defines values for ZonalResourceMetadataKind.
const (
	ZonalResourceMetadataKindActivityLog          ZonalResourceMetadataKind = "activity-log"
	ZonalResourceMetadataKindBlockStorage         ZonalResourceMetadataKind = "block-storage"
	ZonalResourceMetadataKindImage                ZonalResourceMetadataKind = "image"
	ZonalResourceMetadataKindInstance             ZonalResourceMetadataKind = "instance"
	ZonalResourceMetadataKindInstanceSku          ZonalResourceMetadataKind = "instance-sku"
	ZonalResourceMetadataKindLan                  ZonalResourceMetadataKind = "lan"
	ZonalResourceMetadataKindLocation             ZonalResourceMetadataKind = "location"
	ZonalResourceMetadataKindNetworkLoadBalancer  ZonalResourceMetadataKind = "network-load-balancer"
	ZonalResourceMetadataKindNetworkSku           ZonalResourceMetadataKind = "network-sku"
	ZonalResourceMetadataKindNic                  ZonalResourceMetadataKind = "nic"
	ZonalResourceMetadataKindObjectStorageAccount ZonalResourceMetadataKind = "object-storage-account"
	ZonalResourceMetadataKindPublicIp             ZonalResourceMetadataKind = "public-ip"
	ZonalResourceMetadataKindQuota                ZonalResourceMetadataKind = "quota"
	ZonalResourceMetadataKindRegion               ZonalResourceMetadataKind = "region"
	ZonalResourceMetadataKindRole                 ZonalResourceMetadataKind = "role"
	ZonalResourceMetadataKindRoleAssignment       ZonalResourceMetadataKind = "role-assignment"
	ZonalResourceMetadataKindRoutingTable         ZonalResourceMetadataKind = "routing-table"
	ZonalResourceMetadataKindSecurityGroup        ZonalResourceMetadataKind = "security-group"
	ZonalResourceMetadataKindSecurityGroupRule    ZonalResourceMetadataKind = "security-group-rule"
	ZonalResourceMetadataKindStorageSku           ZonalResourceMetadataKind = "storage-sku"
	ZonalResourceMetadataKindSubnet               ZonalResourceMetadataKind = "subnet"
	ZonalResourceMetadataKindWorkspace            ZonalResourceMetadataKind = "workspace"
)

// Defines values for AcceptHeader.
const (
	AcceptHeaderApplicationjson            AcceptHeader = "application/json"
	AcceptHeaderApplicationjsonDeletedOnly AcceptHeader = "application/json; deleted=only"
	AcceptHeaderApplicationjsonDeletedTrue AcceptHeader = "application/json; deleted=true"
)

// Defines values for ListImagesParamsAccept.
const (
	ListImagesParamsAcceptApplicationjson            ListImagesParamsAccept = "application/json"
	ListImagesParamsAcceptApplicationjsonDeletedOnly ListImagesParamsAccept = "application/json; deleted=only"
	ListImagesParamsAcceptApplicationjsonDeletedTrue ListImagesParamsAccept = "application/json; deleted=true"
)

// Defines values for ListStorageQuotasParamsAccept.
const (
	ListStorageQuotasParamsAcceptApplicationjson            ListStorageQuotasParamsAccept = "application/json"
	ListStorageQuotasParamsAcceptApplicationjsonDeletedOnly ListStorageQuotasParamsAccept = "application/json; deleted=only"
	ListStorageQuotasParamsAcceptApplicationjsonDeletedTrue ListStorageQuotasParamsAccept = "application/json; deleted=true"
)

// Defines values for ListBlockStorageSkusParamsAccept.
const (
	ListBlockStorageSkusParamsAcceptApplicationjson            ListBlockStorageSkusParamsAccept = "application/json"
	ListBlockStorageSkusParamsAcceptApplicationjsonDeletedOnly ListBlockStorageSkusParamsAccept = "application/json; deleted=only"
	ListBlockStorageSkusParamsAcceptApplicationjsonDeletedTrue ListBlockStorageSkusParamsAccept = "application/json; deleted=true"
)

// Defines values for ListBlockStoragesParamsAccept.
const (
	Applicationjson            ListBlockStoragesParamsAccept = "application/json"
	ApplicationjsonDeletedOnly ListBlockStoragesParamsAccept = "application/json; deleted=only"
	ApplicationjsonDeletedTrue ListBlockStoragesParamsAccept = "application/json; deleted=true"
)

// BlockStorage defines model for BlockStorage.
type BlockStorage struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	Labels   *map[string]string     `json:"labels,omitempty"`
	Metadata *ZonalResourceMetadata `json:"metadata,omitempty"`
	Spec     BlockStorageSpec       `json:"spec"`

	// Status Conditions type `attachment` indicates the status of the volume attachment.
	// The status can be `attached` or `detached`.
	Status *BlockStorageStatus `json:"status,omitempty"`
}

// BlockStorageSpec defines model for BlockStorageSpec.
type BlockStorageSpec struct {
	Origin *struct {
		// SourceImageRef Reference to the source image used as the base for creating this block storage. This cannot be modified.
		SourceImageRef *string `json:"sourceImageRef,omitempty"`
	} `json:"origin,omitempty"`
	Profile *struct {
		SkuExtensions *SkuExtensions `json:"skuExtensions,omitempty"`

		// StorageSkuRef Reference to the SKU used for this block storage
		StorageSkuRef *string `json:"storageSkuRef,omitempty"`
	} `json:"profile,omitempty"`
	SizeGB *int `json:"sizeGB,omitempty"`
}

// BlockStorageStatus Conditions type `attachment` indicates the status of the volume attachment.
// The status can be `attached` or `detached`.
type BlockStorageStatus struct {
	// AttachedTo Represents a connection between a Block Storage and a device
	AttachedTo *VolumeAttachment  `json:"attachedTo,omitempty"`
	Conditions *[]StatusCondition `json:"conditions,omitempty"`
	SizeGB     *int               `json:"sizeGB,omitempty"`

	// State Generic state definition for all resources. All states are optional, but must not have more states.
	// If a provider wants to present fine granular states, please use conditions.
	State *ResourceState `json:"state,omitempty"`
}

// Error A generic error response
type Error struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error400 defines model for Error400.
type Error400 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error401 defines model for Error401.
type Error401 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error403 defines model for Error403.
type Error403 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error404 defines model for Error404.
type Error404 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error412 defines model for Error412.
type Error412 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error422 defines model for Error422.
type Error422 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error500 defines model for Error500.
type Error500 struct {
	Errors []ErrorDetail `json:"errors"`
}

// ErrorDetail A detailed error response
type ErrorDetail struct {
	// Code An application-specific error code, expressed as a string value.
	Code string `json:"code"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta map[string]interface{} `json:"meta"`

	// Source An object containing references to the source of the error.
	Source *ErrorSource `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem.
	Title string `json:"title"`
}

// ErrorSource An object containing references to the source of the error.
type ErrorSource struct {
	// Parameter A string indicating which URI query parameter caused the error.
	Parameter string `json:"parameter"`

	// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
	Pointer string `json:"pointer"`
}

// Image defines model for Image.
type Image struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	Labels   *map[string]string        `json:"labels,omitempty"`
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`
	Spec     *ImageSpec                `json:"spec,omitempty"`

	// Status Current status of the resource
	Status *Status `json:"status,omitempty"`
}

// ImageCapabilities defines model for ImageCapabilities.
type ImageCapabilities struct {
	// Provider keyword to identify the provider
	Provider *string `json:"provider,omitempty"`

	// Tier keyword to identify the product tier
	Tier *string `json:"tier,omitempty"`
}

// ImageSpec defines model for ImageSpec.
type ImageSpec struct {
	Capabilities *ImageCapabilities `json:"capabilities,omitempty"`
	Description  *string            `json:"description,omitempty"`

	// Extensions List of possible extensions for this Image
	Extensions *[]string `json:"extensions,omitempty"`

	// MandatoryParameters List of mandatory parameters for this Image
	MandatoryParameters *[]string `json:"mandatoryParameters,omitempty"`

	// Provider Provider of the Image specification
	Provider *string `json:"provider,omitempty"`

	// Tier Tier of the Image
	Tier *string `json:"tier,omitempty"`
}

// ModificationMetadata Base metadata for all resources with optional location references
type ModificationMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp time.Time `json:"deletionTimestamp"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp time.Time `json:"lastModifiedTimestamp"`
}

// NameMetadata defines model for NameMetadata.
type NameMetadata struct {
	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name string `json:"name"`
}

// RegionalMetadata Metadata for regional resources
type RegionalMetadata struct {
	// Region Reference to the region where the resource is located
	Region string `json:"region"`

	// Workspace Workspace identifier
	Workspace *string `json:"workspace,omitempty"`
}

// RegionalResourceMetadata defines model for RegionalResourceMetadata.
type RegionalResourceMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp time.Time `json:"deletionTimestamp"`

	// Kind Type of the resource
	Kind RegionalResourceMetadataKind `json:"kind"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp time.Time `json:"lastModifiedTimestamp"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name string `json:"name"`

	// Region Reference to the region where the resource is located
	Region string `json:"region"`

	// Tenant Tenant identifier
	Tenant string `json:"tenant"`

	// Workspace Workspace identifier
	Workspace *string `json:"workspace,omitempty"`
}

// RegionalResourceMetadataKind Type of the resource
type RegionalResourceMetadataKind string

// ResourceQuota defines model for ResourceQuota.
type ResourceQuota struct {
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`

	// Spec Represents the ResourceQuota for the single ResourceType of the Resource Provider
	Spec   *ResourceQuotaSpec   `json:"spec,omitempty"`
	Status *ResourceQuotaStatus `json:"status,omitempty"`
}

// ResourceQuotaSpec Represents the ResourceQuota for the single ResourceType of the Resource Provider
type ResourceQuotaSpec struct {
	// Value limit number of resourceType instances, set null for unlimited
	Value *int `json:"value"`
}

// ResourceQuotaStatus defines model for ResourceQuotaStatus.
type ResourceQuotaStatus struct {
	Conditions []StatusCondition `json:"conditions"`
	Current    *ResourceQuota    `json:"current,omitempty"`
	Usage      *ResourceQuota    `json:"usage,omitempty"`
}

// ResourceState Generic state definition for all resources. All states are optional, but must not have more states.
// If a provider wants to present fine granular states, please use conditions.
type ResourceState struct {
	// Phase Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	Phase *ResourceStatePhase `json:"phase,omitempty"`
}

// ResourceStatePhase Current phase of the resource:
// - pending: not available, waiting for other resources
// - creating: not available, creation started
// - active: available for data layer usage
// - updating: available for data layer usage
// - deleting: maybe still available for data layer user, can fail any moment
// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
// - error: failed to fulfill the request; would be related to provider issue or customer related input.
type ResourceStatePhase string

// ResponseMetadata defines model for ResponseMetadata.
type ResponseMetadata struct {
	// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
	SkipToken *string `json:"skipToken,omitempty"`
}

// SkuExtensions defines model for SkuExtensions.
type SkuExtensions map[string]interface{}

// Status Current status of the resource
type Status struct {
	Conditions []StatusCondition `json:"conditions"`
}

// StatusCondition StatusCondition describes the state of a resource at a certain point.
// Conditions are provider-specific and can represent different states depending on the
// resource type and provider implementation.
type StatusCondition struct {
	// LastTransitionTime LastTransitionTime is the last time the condition transitioned from one
	// status to another. This should be when the underlying condition changed.
	// If that is not known, then using the time when the API field changed is
	// acceptable.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message A human-readable message indicating details about the transition.
	Message *string `json:"message,omitempty"`

	// Reason The reason for the condition's last transition in CamelCase.
	// The specific set of reason values is provider-specific and should be
	// documented by the provider.
	Reason *string `json:"reason,omitempty"`

	// Status Status of the condition.
	Status string `json:"status"`

	// Type Type of condition. The condition type is provider-specific and should
	// reflect the specific states relevant to your resource.
	Type string `json:"type"`
}

// StorageSku Represents a Stock Keeping Unit (SKU) for  storage resources.
//
// Storage SKUs define performance tiers for storage IOPS and characteristics.
// Properties, capabilities, and extensions can be found in the metadata.labels sections.
// Searchable with namespaces like "properties.", "capabilities.", and "extensions.".
type StorageSku struct {
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`
	Spec     *StorageSkuSpec           `json:"spec,omitempty"`

	// Status Current status of the resource
	Status *Status `json:"status,omitempty"`
}

// StorageSkuSpec defines model for StorageSkuSpec.
type StorageSkuSpec struct {
	// Capabilities storage performance capabilities
	Capabilities *map[string]interface{} `json:"capabilities,omitempty"`
	Description  *string                 `json:"description,omitempty"`

	// Extensions Additional  storage feature extensions
	Extensions *[]string `json:"extensions,omitempty"`

	// MandatoryParameters Mandatory parameters for  storage resources
	MandatoryParameters *[]string `json:"mandatoryParameters,omitempty"`

	// Provider Provider namespace for  storage SKUs
	Provider *string `json:"provider,omitempty"`

	// Tier storage performance tier
	Tier *string `json:"tier,omitempty"`
}

// TenantMetadata Metadata for global resources with tenant constraints
type TenantMetadata struct {
	// Tenant Tenant identifier
	Tenant string `json:"tenant"`
}

// TypeMetadata defines model for TypeMetadata.
type TypeMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// Kind Type of the resource
	Kind TypeMetadataKind `json:"kind"`
}

// TypeMetadataKind Type of the resource
type TypeMetadataKind string

// UserResourceMetadata defines model for UserResourceMetadata.
type UserResourceMetadata struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	Labels *map[string]string `json:"labels,omitempty"`
}

// VolumeAttachment Represents a connection between a Block Storage and a device
type VolumeAttachment struct {
	ObjectRef  *string                     `json:"objectRef,omitempty"`
	Properties *VolumeAttachmentProperties `json:"properties,omitempty"`
}

// VolumeAttachmentProperties defines model for VolumeAttachmentProperties.
type VolumeAttachmentProperties struct {
	// ConnectionType The connection type depends on the type of device and type of block storage.
	ConnectionType *string `json:"connectionType,omitempty"`

	// DeviceKind the type of device a block-storage is connected to. For now only 'instance' possible
	DeviceKind *string `json:"deviceKind,omitempty"`
	DeviceRef  *string `json:"deviceRef,omitempty"`
}

// ZonalMetadata Metadata for zonal resources
type ZonalMetadata struct {
	// Zone Reference to the specific zone where the resource is located
	Zone string `json:"zone"`
}

// ZonalResourceMetadata defines model for ZonalResourceMetadata.
type ZonalResourceMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp time.Time `json:"deletionTimestamp"`

	// Kind Type of the resource
	Kind ZonalResourceMetadataKind `json:"kind"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp time.Time `json:"lastModifiedTimestamp"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name string `json:"name"`

	// Region Reference to the region where the resource is located
	Region string `json:"region"`

	// Tenant Tenant identifier
	Tenant string `json:"tenant"`

	// Workspace Workspace identifier
	Workspace *string `json:"workspace,omitempty"`

	// Zone Reference to the specific zone where the resource is located
	Zone string `json:"zone"`
}

// ZonalResourceMetadataKind Type of the resource
type ZonalResourceMetadataKind string

// AcceptHeader defines model for acceptHeader.
type AcceptHeader string

// IfUnmodifiedSince defines model for ifUnmodifiedSince.
type IfUnmodifiedSince = time.Time

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// ResourceName defines model for resourceName.
type ResourceName = string

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// TenantID defines model for tenantID.
type TenantID = string

// WorkspaceName defines model for workspaceName.
type WorkspaceName = string

// ListImagesParams defines parameters for ListImages.
type ListImagesParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListImagesParamsAccept `json:"Accept,omitempty"`
}

// ListImagesParamsAccept defines parameters for ListImages.
type ListImagesParamsAccept string

// ListStorageQuotasParams defines parameters for ListStorageQuotas.
type ListStorageQuotasParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListStorageQuotasParamsAccept `json:"Accept,omitempty"`
}

// ListStorageQuotasParamsAccept defines parameters for ListStorageQuotas.
type ListStorageQuotasParamsAccept string

// CreateOrUpdateStorageQuotaParams defines parameters for CreateOrUpdateStorageQuota.
type CreateOrUpdateStorageQuotaParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListBlockStorageSkusParams defines parameters for ListBlockStorageSkus.
type ListBlockStorageSkusParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListBlockStorageSkusParamsAccept `json:"Accept,omitempty"`
}

// ListBlockStorageSkusParamsAccept defines parameters for ListBlockStorageSkus.
type ListBlockStorageSkusParamsAccept string

// ListBlockStoragesParams defines parameters for ListBlockStorages.
type ListBlockStoragesParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListBlockStoragesParamsAccept `json:"Accept,omitempty"`
}

// ListBlockStoragesParamsAccept defines parameters for ListBlockStorages.
type ListBlockStoragesParamsAccept string

// GetBlockStorageParams defines parameters for GetBlockStorage.
type GetBlockStorageParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateBlockStorageParams defines parameters for CreateOrUpdateBlockStorage.
type CreateOrUpdateBlockStorageParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateStorageQuotaJSONRequestBody defines body for CreateOrUpdateStorageQuota for application/json ContentType.
type CreateOrUpdateStorageQuotaJSONRequestBody = ResourceQuota

// CreateOrUpdateBlockStorageJSONRequestBody defines body for CreateOrUpdateBlockStorage for application/json ContentType.
type CreateOrUpdateBlockStorageJSONRequestBody = BlockStorage

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListImages request
	ListImages(ctx context.Context, id TenantID, params *ListImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImage request
	GetImage(ctx context.Context, id TenantID, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStorageQuotas request
	ListStorageQuotas(ctx context.Context, id TenantID, params *ListStorageQuotasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateStorageQuotaWithBody request with any body
	CreateOrUpdateStorageQuotaWithBody(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateStorageQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateStorageQuota(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateStorageQuotaParams, body CreateOrUpdateStorageQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBlockStorageSkus request
	ListBlockStorageSkus(ctx context.Context, id TenantID, params *ListBlockStorageSkusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorageSku request
	GetStorageSku(ctx context.Context, id TenantID, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBlockStorages request
	ListBlockStorages(ctx context.Context, id TenantID, workspace string, params *ListBlockStoragesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBlockStorage request
	DeleteBlockStorage(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockStorage request
	GetBlockStorage(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *GetBlockStorageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateBlockStorageWithBody request with any body
	CreateOrUpdateBlockStorageWithBody(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateBlockStorageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateBlockStorage(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateBlockStorageParams, body CreateOrUpdateBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListImages(ctx context.Context, id TenantID, params *ListImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListImagesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImage(ctx context.Context, id TenantID, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImageRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStorageQuotas(ctx context.Context, id TenantID, params *ListStorageQuotasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStorageQuotasRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateStorageQuotaWithBody(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateStorageQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateStorageQuotaRequestWithBody(c.Server, id, resourceType, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateStorageQuota(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateStorageQuotaParams, body CreateOrUpdateStorageQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateStorageQuotaRequest(c.Server, id, resourceType, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBlockStorageSkus(ctx context.Context, id TenantID, params *ListBlockStorageSkusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBlockStorageSkusRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageSku(ctx context.Context, id TenantID, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStorageSkuRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBlockStorages(ctx context.Context, id TenantID, workspace string, params *ListBlockStoragesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBlockStoragesRequest(c.Server, id, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBlockStorage(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBlockStorageRequest(c.Server, id, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockStorage(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *GetBlockStorageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockStorageRequest(c.Server, id, workspace, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateBlockStorageWithBody(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateBlockStorageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateBlockStorageRequestWithBody(c.Server, id, workspace, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateBlockStorage(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateBlockStorageParams, body CreateOrUpdateBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateBlockStorageRequest(c.Server, id, workspace, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListImagesRequest generates requests for ListImages
func NewListImagesRequest(server string, id TenantID, params *ListImagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewGetImageRequest generates requests for GetImage
func NewGetImageRequest(server string, id TenantID, name ResourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListStorageQuotasRequest generates requests for ListStorageQuotas
func NewListStorageQuotasRequest(server string, id TenantID, params *ListStorageQuotasParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/quotas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewCreateOrUpdateStorageQuotaRequest calls the generic CreateOrUpdateStorageQuota builder with application/json body
func NewCreateOrUpdateStorageQuotaRequest(server string, id TenantID, resourceType string, params *CreateOrUpdateStorageQuotaParams, body CreateOrUpdateStorageQuotaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateStorageQuotaRequestWithBody(server, id, resourceType, params, "application/json", bodyReader)
}

// NewCreateOrUpdateStorageQuotaRequestWithBody generates requests for CreateOrUpdateStorageQuota with any type of body
func NewCreateOrUpdateStorageQuotaRequestWithBody(server string, id TenantID, resourceType string, params *CreateOrUpdateStorageQuotaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/quotas/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewListBlockStorageSkusRequest generates requests for ListBlockStorageSkus
func NewListBlockStorageSkusRequest(server string, id TenantID, params *ListBlockStorageSkusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/skus", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewGetStorageSkuRequest generates requests for GetStorageSku
func NewGetStorageSkuRequest(server string, id TenantID, name ResourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/skus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBlockStoragesRequest generates requests for ListBlockStorages
func NewListBlockStoragesRequest(server string, id TenantID, workspace string, params *ListBlockStoragesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/block-storages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteBlockStorageRequest generates requests for DeleteBlockStorage
func NewDeleteBlockStorageRequest(server string, id TenantID, workspace WorkspaceName, name ResourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/block-storages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockStorageRequest generates requests for GetBlockStorage
func NewGetBlockStorageRequest(server string, id TenantID, workspace WorkspaceName, name ResourceName, params *GetBlockStorageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/block-storages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewCreateOrUpdateBlockStorageRequest calls the generic CreateOrUpdateBlockStorage builder with application/json body
func NewCreateOrUpdateBlockStorageRequest(server string, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateBlockStorageParams, body CreateOrUpdateBlockStorageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateBlockStorageRequestWithBody(server, id, workspace, name, params, "application/json", bodyReader)
}

// NewCreateOrUpdateBlockStorageRequestWithBody generates requests for CreateOrUpdateBlockStorage with any type of body
func NewCreateOrUpdateBlockStorageRequestWithBody(server string, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateBlockStorageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/block-storages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListImagesWithResponse request
	ListImagesWithResponse(ctx context.Context, id TenantID, params *ListImagesParams, reqEditors ...RequestEditorFn) (*ListImagesResponse, error)

	// GetImageWithResponse request
	GetImageWithResponse(ctx context.Context, id TenantID, name ResourceName, reqEditors ...RequestEditorFn) (*GetImageResponse, error)

	// ListStorageQuotasWithResponse request
	ListStorageQuotasWithResponse(ctx context.Context, id TenantID, params *ListStorageQuotasParams, reqEditors ...RequestEditorFn) (*ListStorageQuotasResponse, error)

	// CreateOrUpdateStorageQuotaWithBodyWithResponse request with any body
	CreateOrUpdateStorageQuotaWithBodyWithResponse(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateStorageQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateStorageQuotaResponse, error)

	CreateOrUpdateStorageQuotaWithResponse(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateStorageQuotaParams, body CreateOrUpdateStorageQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateStorageQuotaResponse, error)

	// ListBlockStorageSkusWithResponse request
	ListBlockStorageSkusWithResponse(ctx context.Context, id TenantID, params *ListBlockStorageSkusParams, reqEditors ...RequestEditorFn) (*ListBlockStorageSkusResponse, error)

	// GetStorageSkuWithResponse request
	GetStorageSkuWithResponse(ctx context.Context, id TenantID, name ResourceName, reqEditors ...RequestEditorFn) (*GetStorageSkuResponse, error)

	// ListBlockStoragesWithResponse request
	ListBlockStoragesWithResponse(ctx context.Context, id TenantID, workspace string, params *ListBlockStoragesParams, reqEditors ...RequestEditorFn) (*ListBlockStoragesResponse, error)

	// DeleteBlockStorageWithResponse request
	DeleteBlockStorageWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*DeleteBlockStorageResponse, error)

	// GetBlockStorageWithResponse request
	GetBlockStorageWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *GetBlockStorageParams, reqEditors ...RequestEditorFn) (*GetBlockStorageResponse, error)

	// CreateOrUpdateBlockStorageWithBodyWithResponse request with any body
	CreateOrUpdateBlockStorageWithBodyWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateBlockStorageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateBlockStorageResponse, error)

	CreateOrUpdateBlockStorageWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateBlockStorageParams, body CreateOrUpdateBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateBlockStorageResponse, error)
}

type ListImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]Image          `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Image
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStorageQuotasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]ResourceQuota  `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListStorageQuotasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStorageQuotasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateStorageQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateStorageQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateStorageQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBlockStorageSkusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]StorageSku     `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListBlockStorageSkusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBlockStorageSkusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStorageSkuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageSku
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetStorageSkuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStorageSkuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBlockStoragesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]BlockStorage   `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListBlockStoragesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBlockStoragesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBlockStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteBlockStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBlockStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockStorage
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetBlockStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateBlockStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateBlockStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateBlockStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListImagesWithResponse request returning *ListImagesResponse
func (c *ClientWithResponses) ListImagesWithResponse(ctx context.Context, id TenantID, params *ListImagesParams, reqEditors ...RequestEditorFn) (*ListImagesResponse, error) {
	rsp, err := c.ListImages(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListImagesResponse(rsp)
}

// GetImageWithResponse request returning *GetImageResponse
func (c *ClientWithResponses) GetImageWithResponse(ctx context.Context, id TenantID, name ResourceName, reqEditors ...RequestEditorFn) (*GetImageResponse, error) {
	rsp, err := c.GetImage(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImageResponse(rsp)
}

// ListStorageQuotasWithResponse request returning *ListStorageQuotasResponse
func (c *ClientWithResponses) ListStorageQuotasWithResponse(ctx context.Context, id TenantID, params *ListStorageQuotasParams, reqEditors ...RequestEditorFn) (*ListStorageQuotasResponse, error) {
	rsp, err := c.ListStorageQuotas(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStorageQuotasResponse(rsp)
}

// CreateOrUpdateStorageQuotaWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateStorageQuotaResponse
func (c *ClientWithResponses) CreateOrUpdateStorageQuotaWithBodyWithResponse(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateStorageQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateStorageQuotaResponse, error) {
	rsp, err := c.CreateOrUpdateStorageQuotaWithBody(ctx, id, resourceType, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateStorageQuotaResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateStorageQuotaWithResponse(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateStorageQuotaParams, body CreateOrUpdateStorageQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateStorageQuotaResponse, error) {
	rsp, err := c.CreateOrUpdateStorageQuota(ctx, id, resourceType, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateStorageQuotaResponse(rsp)
}

// ListBlockStorageSkusWithResponse request returning *ListBlockStorageSkusResponse
func (c *ClientWithResponses) ListBlockStorageSkusWithResponse(ctx context.Context, id TenantID, params *ListBlockStorageSkusParams, reqEditors ...RequestEditorFn) (*ListBlockStorageSkusResponse, error) {
	rsp, err := c.ListBlockStorageSkus(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBlockStorageSkusResponse(rsp)
}

// GetStorageSkuWithResponse request returning *GetStorageSkuResponse
func (c *ClientWithResponses) GetStorageSkuWithResponse(ctx context.Context, id TenantID, name ResourceName, reqEditors ...RequestEditorFn) (*GetStorageSkuResponse, error) {
	rsp, err := c.GetStorageSku(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageSkuResponse(rsp)
}

// ListBlockStoragesWithResponse request returning *ListBlockStoragesResponse
func (c *ClientWithResponses) ListBlockStoragesWithResponse(ctx context.Context, id TenantID, workspace string, params *ListBlockStoragesParams, reqEditors ...RequestEditorFn) (*ListBlockStoragesResponse, error) {
	rsp, err := c.ListBlockStorages(ctx, id, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBlockStoragesResponse(rsp)
}

// DeleteBlockStorageWithResponse request returning *DeleteBlockStorageResponse
func (c *ClientWithResponses) DeleteBlockStorageWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, reqEditors ...RequestEditorFn) (*DeleteBlockStorageResponse, error) {
	rsp, err := c.DeleteBlockStorage(ctx, id, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBlockStorageResponse(rsp)
}

// GetBlockStorageWithResponse request returning *GetBlockStorageResponse
func (c *ClientWithResponses) GetBlockStorageWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *GetBlockStorageParams, reqEditors ...RequestEditorFn) (*GetBlockStorageResponse, error) {
	rsp, err := c.GetBlockStorage(ctx, id, workspace, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockStorageResponse(rsp)
}

// CreateOrUpdateBlockStorageWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateBlockStorageResponse
func (c *ClientWithResponses) CreateOrUpdateBlockStorageWithBodyWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateBlockStorageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateBlockStorageResponse, error) {
	rsp, err := c.CreateOrUpdateBlockStorageWithBody(ctx, id, workspace, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateBlockStorageResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateBlockStorageWithResponse(ctx context.Context, id TenantID, workspace WorkspaceName, name ResourceName, params *CreateOrUpdateBlockStorageParams, body CreateOrUpdateBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateBlockStorageResponse, error) {
	rsp, err := c.CreateOrUpdateBlockStorage(ctx, id, workspace, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateBlockStorageResponse(rsp)
}

// ParseListImagesResponse parses an HTTP response from a ListImagesWithResponse call
func ParseListImagesResponse(rsp *http.Response) (*ListImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]Image          `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetImageResponse parses an HTTP response from a GetImageWithResponse call
func ParseGetImageResponse(rsp *http.Response) (*GetImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListStorageQuotasResponse parses an HTTP response from a ListStorageQuotasWithResponse call
func ParseListStorageQuotasResponse(rsp *http.Response) (*ListStorageQuotasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStorageQuotasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]ResourceQuota  `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateStorageQuotaResponse parses an HTTP response from a CreateOrUpdateStorageQuotaWithResponse call
func ParseCreateOrUpdateStorageQuotaResponse(rsp *http.Response) (*CreateOrUpdateStorageQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateStorageQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBlockStorageSkusResponse parses an HTTP response from a ListBlockStorageSkusWithResponse call
func ParseListBlockStorageSkusResponse(rsp *http.Response) (*ListBlockStorageSkusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBlockStorageSkusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]StorageSku     `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStorageSkuResponse parses an HTTP response from a GetStorageSkuWithResponse call
func ParseGetStorageSkuResponse(rsp *http.Response) (*GetStorageSkuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStorageSkuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageSku
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBlockStoragesResponse parses an HTTP response from a ListBlockStoragesWithResponse call
func ParseListBlockStoragesResponse(rsp *http.Response) (*ListBlockStoragesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBlockStoragesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]BlockStorage   `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBlockStorageResponse parses an HTTP response from a DeleteBlockStorageWithResponse call
func ParseDeleteBlockStorageResponse(rsp *http.Response) (*DeleteBlockStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBlockStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBlockStorageResponse parses an HTTP response from a GetBlockStorageWithResponse call
func ParseGetBlockStorageResponse(rsp *http.Response) (*GetBlockStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateBlockStorageResponse parses an HTTP response from a CreateOrUpdateBlockStorageWithResponse call
func ParseCreateOrUpdateBlockStorageResponse(rsp *http.Response) (*CreateOrUpdateBlockStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateBlockStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List Images
	// (GET /v1/tenants/{id}/images)
	ListImages(w http.ResponseWriter, r *http.Request, id TenantID, params ListImagesParams)
	// Get Image
	// (GET /v1/tenants/{id}/images/{name})
	GetImage(w http.ResponseWriter, r *http.Request, id TenantID, name ResourceName)
	// List current Storage Provider Resource Quotas
	// (GET /v1/tenants/{id}/quotas)
	ListStorageQuotas(w http.ResponseWriter, r *http.Request, id TenantID, params ListStorageQuotasParams)
	// Create or update the resource quota for the Storage Resource Provider
	// (PUT /v1/tenants/{id}/quotas/{resourceType})
	CreateOrUpdateStorageQuota(w http.ResponseWriter, r *http.Request, id TenantID, resourceType string, params CreateOrUpdateStorageQuotaParams)
	// List available storage SKUs
	// (GET /v1/tenants/{id}/skus)
	ListBlockStorageSkus(w http.ResponseWriter, r *http.Request, id TenantID, params ListBlockStorageSkusParams)
	// Get details of a specific storage SKU
	// (GET /v1/tenants/{id}/skus/{name})
	GetStorageSku(w http.ResponseWriter, r *http.Request, id TenantID, name ResourceName)
	// List all block storage volumes
	// (GET /v1/tenants/{id}/workspaces/{workspace}/block-storages)
	ListBlockStorages(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, params ListBlockStoragesParams)
	// Delete a specific block storage volume
	// (DELETE /v1/tenants/{id}/workspaces/{workspace}/block-storages/{name})
	DeleteBlockStorage(w http.ResponseWriter, r *http.Request, id TenantID, workspace WorkspaceName, name ResourceName)
	// Get a specific block storage volume
	// (GET /v1/tenants/{id}/workspaces/{workspace}/block-storages/{name})
	GetBlockStorage(w http.ResponseWriter, r *http.Request, id TenantID, workspace WorkspaceName, name ResourceName, params GetBlockStorageParams)
	// Create or update a specific block storage volume
	// (PUT /v1/tenants/{id}/workspaces/{workspace}/block-storages/{name})
	CreateOrUpdateBlockStorage(w http.ResponseWriter, r *http.Request, id TenantID, workspace WorkspaceName, name ResourceName, params CreateOrUpdateBlockStorageParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListImages operation middleware
func (siw *ServerInterfaceWrapper) ListImages(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListImagesParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListImagesParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListImages(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetImage operation middleware
func (siw *ServerInterfaceWrapper) GetImage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetImage(w, r, id, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListStorageQuotas operation middleware
func (siw *ServerInterfaceWrapper) ListStorageQuotas(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListStorageQuotasParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListStorageQuotasParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListStorageQuotas(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateStorageQuota operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateStorageQuota(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "resourceType" -------------
	var resourceType string

	err = runtime.BindStyledParameterWithOptions("simple", "resourceType", r.PathValue("resourceType"), &resourceType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "resourceType", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateStorageQuotaParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateStorageQuota(w, r, id, resourceType, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListBlockStorageSkus operation middleware
func (siw *ServerInterfaceWrapper) ListBlockStorageSkus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBlockStorageSkusParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListBlockStorageSkusParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListBlockStorageSkus(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetStorageSku operation middleware
func (siw *ServerInterfaceWrapper) GetStorageSku(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStorageSku(w, r, id, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListBlockStorages operation middleware
func (siw *ServerInterfaceWrapper) ListBlockStorages(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBlockStoragesParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListBlockStoragesParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListBlockStorages(w, r, id, workspace, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteBlockStorage operation middleware
func (siw *ServerInterfaceWrapper) DeleteBlockStorage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceName

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBlockStorage(w, r, id, workspace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetBlockStorage operation middleware
func (siw *ServerInterfaceWrapper) GetBlockStorage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceName

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockStorageParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBlockStorage(w, r, id, workspace, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateBlockStorage operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateBlockStorage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceName

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateBlockStorageParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateBlockStorage(w, r, id, workspace, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/images", wrapper.ListImages)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/images/{name}", wrapper.GetImage)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/quotas", wrapper.ListStorageQuotas)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/quotas/{resourceType}", wrapper.CreateOrUpdateStorageQuota)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/skus", wrapper.ListBlockStorageSkus)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/skus/{name}", wrapper.GetStorageSku)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/block-storages", wrapper.ListBlockStorages)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/block-storages/{name}", wrapper.DeleteBlockStorage)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/block-storages/{name}", wrapper.GetBlockStorage)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/block-storages/{name}", wrapper.CreateOrUpdateBlockStorage)

	return m
}
