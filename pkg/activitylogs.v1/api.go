// Package activitylogs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package activitylogs

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ActivityLogKind.
const (
	ActivityLogKindActivityLog ActivityLogKind = "activity-log"
)

// Defines values for ActivityLogSpecRequestVerb.
const (
	DELETE ActivityLogSpecRequestVerb = "DELETE"
	GET    ActivityLogSpecRequestVerb = "GET"
	POST   ActivityLogSpecRequestVerb = "POST"
	PUT    ActivityLogSpecRequestVerb = "PUT"
)

// Defines values for LoadBalancerTargetAlgorithm.
const (
	ROUNDROBIN LoadBalancerTargetAlgorithm = "ROUND_ROBIN"
)

// Defines values for LoadBalancerTargetProtocol.
const (
	LoadBalancerTargetProtocolTCP LoadBalancerTargetProtocol = "TCP"
	LoadBalancerTargetProtocolUDP LoadBalancerTargetProtocol = "UDP"
)

// Defines values for NICPropertiesSpecStaticPrivateIPsAdressType.
const (
	NICPropertiesSpecStaticPrivateIPsAdressTypeIPv4 NICPropertiesSpecStaticPrivateIPsAdressType = "IPv4"
)

// Defines values for NetworkLoadBalancerFrontendProtocol.
const (
	NetworkLoadBalancerFrontendProtocolTCP NetworkLoadBalancerFrontendProtocol = "TCP"
	NetworkLoadBalancerFrontendProtocolUDP NetworkLoadBalancerFrontendProtocol = "UDP"
)

// Defines values for PublicIpPropertiesSpecIpVersion.
const (
	PublicIpPropertiesSpecIpVersionIPv4 PublicIpPropertiesSpecIpVersion = "IPv4"
)

// Defines values for PublicIpPropertiesSpecType.
const (
	Dynamic PublicIpPropertiesSpecType = "Dynamic"
	Static  PublicIpPropertiesSpecType = "Static"
)

// Defines values for SecurityGroupRuleKind.
const (
	SecurityGroupRuleKindSecurityGroupRule SecurityGroupRuleKind = "security-group-rule"
)

// Defines values for SecurityGroupRuleSpecDirection.
const (
	Egress  SecurityGroupRuleSpecDirection = "egress"
	Ingress SecurityGroupRuleSpecDirection = "ingress"
)

// Defines values for SecurityGroupRuleSpecProtocol.
const (
	All  SecurityGroupRuleSpecProtocol = "all"
	Icmp SecurityGroupRuleSpecProtocol = "icmp"
	Tcp  SecurityGroupRuleSpecProtocol = "tcp"
	Udp  SecurityGroupRuleSpecProtocol = "udp"
)

// Defines values for SecurityGroupRuleSpecSourceType.
const (
	Cidr           SecurityGroupRuleSpecSourceType = "cidr"
	PublicInternet SecurityGroupRuleSpecSourceType = "publicInternet"
	SecurityGroup  SecurityGroupRuleSpecSourceType = "securityGroup"
)

// Defines values for SubnetPropertiesSpecDefaultGatewayType.
const (
	Auto        SubnetPropertiesSpecDefaultGatewayType = "auto"
	InstanceRef SubnetPropertiesSpecDefaultGatewayType = "instanceRef"
	InternalIp  SubnetPropertiesSpecDefaultGatewayType = "internalIp"
)

// Defines values for SubnetPropertiesSpecDhcpEnabled.
const (
	True SubnetPropertiesSpecDhcpEnabled = true
)

// ActivityLog defines model for ActivityLog.
type ActivityLog struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *ActivityLogKind        `json:"kind,omitempty"`
	Metadata *GlobalResourceMetadata `json:"metadata,omitempty"`
	Spec     *struct {
		Request *struct {
			Body  *ActivityLog_Spec_Request_Body `json:"body,omitempty"`
			Scope *string                        `json:"scope,omitempty"`

			// Verb operation method
			Verb *ActivityLogSpecRequestVerb `json:"verb,omitempty"`
		} `json:"request,omitempty"`
		Response *struct {
			Code *float32 `json:"code,omitempty"`
		} `json:"response,omitempty"`

		// Subject User-JWT executing this query
		Subject *string `json:"subject,omitempty"`
	} `json:"spec,omitempty"`
}

// ActivityLogKind Type of the resource
type ActivityLogKind string

// ActivityLog_Spec_Request_Body defines model for ActivityLog.Spec.Request.Body.
type ActivityLog_Spec_Request_Body struct {
	union json.RawMessage
}

// ActivityLogSpecRequestVerb operation method
type ActivityLogSpecRequestVerb string

// BlockStoragePropertiesSpec defines model for BlockStorage-properties-spec.
type BlockStoragePropertiesSpec struct {
	Origin *struct {
		// SourceImageRef Reference to the source image used as the base for creating this block storage. This cannot be modified.
		SourceImageRef *string `json:"sourceImageRef,omitempty"`
	} `json:"origin,omitempty"`
	Profile *struct {
		SkuExtentions *[]struct {
			Key   *string `json:"key,omitempty"`
			Value *string `json:"value,omitempty"`
		} `json:"skuExtentions,omitempty"`

		// StorageSkuRef Reference to the SKU used for this block storage
		StorageSkuRef *string `json:"storageSkuRef,omitempty"`
	} `json:"profile,omitempty"`
	SizeGB *int `json:"sizeGB,omitempty"`
}

// Error A generic error response
type Error struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error400 defines model for Error400.
type Error400 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error401 defines model for Error401.
type Error401 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error403 defines model for Error403.
type Error403 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error404 defines model for Error404.
type Error404 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error500 defines model for Error500.
type Error500 struct {
	Errors []ErrorDetail `json:"errors"`
}

// ErrorDetail A detailed error response
type ErrorDetail struct {
	// Code An application-specific error code, expressed as a string value.
	Code string `json:"code"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Source An object containing references to the source of the error.
	Source *struct {
		// Parameter A string indicating which URI query parameter caused the error.
		Parameter *string `json:"parameter,omitempty"`

		// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
		Pointer *string `json:"pointer,omitempty"`
	} `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem.
	Title string `json:"title"`
}

// GlobalResourceMetadata defines model for GlobalResourceMetadata.
type GlobalResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels *map[string]interface{} `json:"labels,omitempty"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name *string `json:"name,omitempty"`
}

// InstancePropertiesSpec defines model for Instance-properties-spec.
type InstancePropertiesSpec struct {
	Network *struct {
		// OtherNics Additional NICs attached to this instance
		OtherNics *[]struct {
			// NicRef Reference to the NIC
			NicRef *string `json:"nicRef,omitempty"`

			// Slot Slot number for the NIC
			Slot *int `json:"slot,omitempty"`
		} `json:"otherNics,omitempty"`

		// PrimaryNicRef Reference to the primary NIC for this instance
		PrimaryNicRef *string `json:"primaryNicRef,omitempty"`
	} `json:"network,omitempty"`
	OperatingSystem *struct {
		CloudInitData *struct {
			// SshKeyExternalRef Provider-specific references to SSH keys used in cloud-init vendorData.
			// These references are used to inject SSH public keys during instance initialization
			// through cloud-init's vendor data configuration.
			SshKeyExternalRef *[]string `json:"sshKeyExternalRef,omitempty"`

			// UserData Cloud-init user data for instance initialization
			// Example cloud-init user configuration with SSH key:
			// ```yaml
			// #cloud-config
			// packages:
			//   - nginx
			// ```
			UserData *string `json:"userData,omitempty"`
		} `json:"cloudInitData,omitempty"`

		// OsBlockStorageRef Represents a connection between a Block Storage and a device
		OsBlockStorageRef *VolumeAttachment `json:"osBlockStorageRef,omitempty"`
	} `json:"operatingSystem,omitempty"`
	Profile *struct {
		// InstanceSkuRef Reference to the SKU used for this instance
		InstanceSkuRef *string `json:"instanceSkuRef,omitempty"`
		SkuExtentions  *[]struct {
			Key   *string `json:"key,omitempty"`
			Value *string `json:"value,omitempty"`
		} `json:"skuExtentions,omitempty"`
	} `json:"profile,omitempty"`
	Storage *struct {
		DataBlockStorageRef *[]VolumeAttachment `json:"dataBlockStorageRef,omitempty"`
	} `json:"storage,omitempty"`
}

// InstanceSkuPropertiesSpec defines model for InstanceSku-properties-spec.
type InstanceSkuPropertiesSpec struct {
	// Capabilities Instance performance capabilities
	Capabilities *InstanceSkuPropertiesSpec_Capabilities `json:"capabilities,omitempty"`
	Description  *string                                 `json:"description,omitempty"`

	// Extensions Additional instance feature extensions
	Extensions *[]string `json:"extensions,omitempty"`

	// MandatoryParameters Mandatory parameters for block storage resources
	MandatoryParameters *[]string `json:"mandatoryParameters,omitempty"`

	// Provider Provider namespace for instance SKUs
	Provider *string `json:"provider,omitempty"`
	Tier     *string `json:"tier,omitempty"`
}

// InstanceSkuPropertiesSpec_Capabilities Instance performance capabilities
type InstanceSkuPropertiesSpec_Capabilities struct {
	BenchmarkPoints      *int                   `json:"benchmarkPoints,omitempty"`
	RamGB                *int                   `json:"ramGB,omitempty"`
	VCPU                 *int                   `json:"vCPU,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// LANPropertiesSpec defines model for LAN-properties-spec.
type LANPropertiesSpec struct {
	Profile *struct {
		// NetworkSkuRef Reference to the SKU used for this LAN
		NetworkSkuRef *string `json:"networkSkuRef,omitempty"`
		SkuExtentions *[]struct {
			Key   *string `json:"key,omitempty"`
			Value *string `json:"value,omitempty"`
		} `json:"skuExtentions,omitempty"`
	} `json:"profile,omitempty"`
}

// LoadBalancerMember defines model for LoadBalancerMember.
type LoadBalancerMember struct {
	// NicRef Nic Reference to the LoadBalancerMember as part of the LoadBalancerTarget
	NicRef *string `json:"nicRef,omitempty"`
}

// LoadBalancerTarget defines model for LoadBalancerTarget.
type LoadBalancerTarget struct {
	// Algorithm LoadBalancer algorithm to take a backend istance
	Algorithm *LoadBalancerTargetAlgorithm `json:"algorithm,omitempty"`

	// Healthcheck Optional port health check. It probes the port with protocol.
	Healthcheck *struct {
		// Interval healthcheck interval in seconds. It means after how many seconds it will take a new check
		Interval *int `json:"interval,omitempty"`

		// Retry healthcheck retry number after considered unhealthy a backend istance
		Retry *int `json:"retry,omitempty"`

		// Timeout healthcheck in seconds. It means after how many seconds the attempt will be considered unhealthy
		Timeout *int `json:"timeout,omitempty"`
	} `json:"healthcheck,omitempty"`
	Members *[]LoadBalancerMember `json:"members,omitempty"`

	// Port A valid network port number.
	Port *int32 `json:"port,omitempty"`

	// Protocol Frontend Protocol to which the load balancer will be listening on
	Protocol *LoadBalancerTargetProtocol `json:"protocol,omitempty"`
}

// LoadBalancerTargetAlgorithm LoadBalancer algorithm to take a backend istance
type LoadBalancerTargetAlgorithm string

// LoadBalancerTargetProtocol Frontend Protocol to which the load balancer will be listening on
type LoadBalancerTargetProtocol string

// NICPropertiesSpec Specification of the Network Interface Card
type NICPropertiesSpec struct {
	// PublicIPRef References to public IP addresses associated with this NIC. The IP may be external and not directly visible on the server/NIC itself. Maximum one IP allowed.
	PublicIPRef *string `json:"publicIPRef,omitempty"`

	// StaticPrivateIPs List of static private IP addresses for this NIC. Can only be used when the subnet has dhcpEnabled=false.
	StaticPrivateIPs *[]struct {
		AdressType *NICPropertiesSpecStaticPrivateIPsAdressType `json:"adressType,omitempty"`
		IpAddress  *string                                      `json:"ipAddress,omitempty"`
	} `json:"staticPrivateIPs,omitempty"`

	// SubnetRef Subnet this NIC is connected to
	SubnetRef *string `json:"subnetRef,omitempty"`
}

// NICPropertiesSpecStaticPrivateIPsAdressType defines model for NICPropertiesSpec.StaticPrivateIPs.AdressType.
type NICPropertiesSpecStaticPrivateIPsAdressType string

// NetworkLoadBalancerPropertiesSpec defines model for NetworkLoadBalancer-properties-spec.
type NetworkLoadBalancerPropertiesSpec struct {
	IpConfigurations *[]NetworkLoadBalancerFrontend `json:"ipConfigurations,omitempty"`
	Profile          *struct {
		// NetworkLoadBalancerSkuRef Reference to the SKU used for this network-load-balancer
		NetworkLoadBalancerSkuRef *string `json:"networkLoadBalancerSkuRef,omitempty"`
	} `json:"profile,omitempty"`
}

// NetworkLoadBalancerFrontend defines model for NetworkLoadBalancerFrontend.
type NetworkLoadBalancerFrontend struct {
	// NicRef NIC reference to the LoadBalancer. If ipAddressType will be ipv4 or dual-stack or if the LoadBalancer will be internal or external depends on the associated NIC
	NicRef *string `json:"nicRef,omitempty"`

	// Port A valid network port number.
	Port *int32 `json:"port,omitempty"`

	// Protocol Frontend Protocol to which the load balancer will be listening on
	Protocol *NetworkLoadBalancerFrontendProtocol `json:"protocol,omitempty"`
	Target   *LoadBalancerTarget                  `json:"target,omitempty"`
}

// NetworkLoadBalancerFrontendProtocol Frontend Protocol to which the load balancer will be listening on
type NetworkLoadBalancerFrontendProtocol string

// NetworkSkuPropertiesSpec defines model for NetworkSku-properties-spec.
type NetworkSkuPropertiesSpec struct {
	// Capabilities Network performance capabilities
	Capabilities *map[string]interface{} `json:"capabilities,omitempty"`
	Description  *string                 `json:"description,omitempty"`

	// Extensions Additional network feature extensions
	Extensions *[]string `json:"extensions,omitempty"`

	// MandatoryParameters Mandatory parameters for network resources
	MandatoryParameters *[]string `json:"mandatoryParameters,omitempty"`

	// Provider Provider namespace for network SKUs
	Provider *string `json:"provider,omitempty"`

	// Tier Network performance tier
	Tier *string `json:"tier,omitempty"`
}

// ObjectStoragePropertiesSpec defines model for ObjectStorage-properties-spec.
type ObjectStoragePropertiesSpec struct {
	Profile *struct {
		// ObjectStorageSkuRef Reference to the SKU used for this object-storage
		ObjectStorageSkuRef *string `json:"objectStorageSkuRef,omitempty"`
	} `json:"profile,omitempty"`
}

// PublicIpPropertiesSpec Specification of the public IP
type PublicIpPropertiesSpec struct {
	// AssignedTo References to resources this IP is assigned to
	AssignedTo *[]struct {
		// Kind Kind of resource the IP is assigned to
		Kind *string `json:"kind,omitempty"`

		// Name Name of the resource the IP is assigned to
		Name *string `json:"name,omitempty"`
	} `json:"assignedTo,omitempty"`

	// IpAddress The public IP address
	IpAddress *string `json:"ipAddress,omitempty"`

	// IpVersion IP version of the address (limited to IPv4 for now)
	IpVersion *PublicIpPropertiesSpecIpVersion `json:"ipVersion,omitempty"`

	// Type Type of public IP allocation
	Type *PublicIpPropertiesSpecType `json:"type,omitempty"`
}

// PublicIpPropertiesSpecIpVersion IP version of the address (limited to IPv4 for now)
type PublicIpPropertiesSpecIpVersion string

// PublicIpPropertiesSpecType Type of public IP allocation
type PublicIpPropertiesSpecType string

// RegionalResourceMetadata defines model for RegionalResourceMetadata.
type RegionalResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels *map[string]interface{} `json:"labels,omitempty"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Location Reference to the region where the resource is located
	Location *struct {
		Region string `json:"region"`
	} `json:"location,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name *string `json:"name,omitempty"`
}

// ResourceMetadata Base metadata for all resources, with optional location references
type ResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels *map[string]interface{} `json:"labels,omitempty"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name *string `json:"name,omitempty"`
}

// ResourceQuota Represents the ResourceQuota for the single ResourceType of the Resource Provider
type ResourceQuota struct {
	// Value limit number of resourceType instances, set null for unlimited
	Value *int `json:"value"`
}

// RoleAssignmentPropertiesSpec defines model for RoleAssignment-properties-spec.
type RoleAssignmentPropertiesSpec struct {
	// Roles List of assigned role names
	Roles *[]string `json:"roles,omitempty"`

	// Scopes List of Scopes to whom the roles are assigned
	Scopes *[]string `json:"scopes,omitempty"`

	// Subs List of subject IDs (from JWT) to whom the roles are assigned
	Subs *[]string `json:"subs,omitempty"`
}

// SecurityGroupPropertiesSpec Specification of the security group
type SecurityGroupPropertiesSpec struct {
	// Rules Network access rules defining communication between security groups and external networks.
	//
	// Rule Evaluation:
	// - Rules are processed in order of priority (lower number = higher priority)
	// - First matching rule determines the action (allow/deny)
	// - Default behavior is to deny all traffic not explicitly allowed
	Rules *[]SecurityGroupRule `json:"rules,omitempty"`
}

// SecurityGroupRule Represents a security group rule
type SecurityGroupRule struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *SecurityGroupRuleKind    `json:"kind,omitempty"`
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`
	Spec     *struct {
		// Description Human-readable description of the rule's purpose
		Description *string `json:"description,omitempty"`

		// Direction - ingress: Only incoming traffic is allowed
		// - egress: Only outgoing traffic is allowed
		// - bidirectional: Traffic can flow both ways
		Direction *SecurityGroupRuleSpecDirection `json:"direction,omitempty"`

		// PortRange Specific port or port range for the rule
		PortRange *struct {
			From *int `json:"from,omitempty"`
			To   *int `json:"to,omitempty"`
		} `json:"portRange,omitempty"`

		// Priority Rule priority (lower number = higher priority)
		Priority *int `json:"priority,omitempty"`

		// Protocol Network protocol for the rule
		Protocol *SecurityGroupRuleSpecProtocol `json:"protocol,omitempty"`

		// Source Source of the traffic. Can be a security group, CIDR range, or 'publicInternet'.
		// 'publicInternet' allows explicit control over internet-facing traffic.
		Source *struct {
			Type *SecurityGroupRuleSpecSourceType `json:"type,omitempty"`

			// Value - For securityGroup: name of the source security group
			// - For cidr: IPv4 CIDR range
			// - For publicInternet: 'any' or a IPv4 CIDR Range
			Value *string `json:"value,omitempty"`
		} `json:"source,omitempty"`
	} `json:"spec,omitempty"`

	// Status Current status of the resource
	Status *Status `json:"status,omitempty"`
}

// SecurityGroupRuleKind Type of the resource
type SecurityGroupRuleKind string

// SecurityGroupRuleSpecDirection - ingress: Only incoming traffic is allowed
// - egress: Only outgoing traffic is allowed
// - bidirectional: Traffic can flow both ways
type SecurityGroupRuleSpecDirection string

// SecurityGroupRuleSpecProtocol Network protocol for the rule
type SecurityGroupRuleSpecProtocol string

// SecurityGroupRuleSpecSourceType defines model for SecurityGroupRule.Spec.Source.Type.
type SecurityGroupRuleSpecSourceType string

// Status Current status of the resource
type Status struct {
	// Conditions Conditions represent the latest available observations of a resource's current state.
	// Conditions are provider-specific and can represent different states depending on the
	// resource type and provider implementation.
	Conditions *StatusConditions `json:"conditions,omitempty"`
}

// StatusConditions Conditions represent the latest available observations of a resource's current state.
// Conditions are provider-specific and can represent different states depending on the
// resource type and provider implementation.
type StatusConditions = []struct {
	// LastTransitionTime LastTransitionTime is the last time the condition transitioned from one
	// status to another. This should be when the underlying condition changed.
	// If that is not known, then using the time when the API field changed is
	// acceptable.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message A human-readable message indicating details about the transition.
	Message *string `json:"message,omitempty"`

	// Reason The reason for the condition's last transition in CamelCase.
	// The specific set of reason values is provider-specific and should be
	// documented by the provider.
	Reason *string `json:"reason,omitempty"`

	// Status Status of the condition.
	Status string `json:"status"`

	// Type Type of condition. The condition type is provider-specific and should
	// reflect the specific states relevant to your resource.
	Type string `json:"type"`
}

// StorageSkuPropertiesSpec defines model for StorageSku-properties-spec.
type StorageSkuPropertiesSpec struct {
	// Capabilities storage performance capabilities
	Capabilities *map[string]interface{} `json:"capabilities,omitempty"`
	Description  *string                 `json:"description,omitempty"`

	// Extensions Additional  storage feature extensions
	Extensions *[]string `json:"extensions,omitempty"`

	// MandatoryParameters Mandatory parameters for  storage resources
	MandatoryParameters *[]string `json:"mandatoryParameters,omitempty"`

	// Provider Provider namespace for  storage SKUs
	Provider *string `json:"provider,omitempty"`

	// Tier storage performance tier
	Tier *string `json:"tier,omitempty"`
}

// SubnetPropertiesSpec Specification of the subnet
type SubnetPropertiesSpec struct {
	Cidr *struct {
		// Ipv4Range IPv4 address range for the subnet.
		// Must be unique within the LAN and cannot be modified after creation.
		// Example: '192.168.1.0/24'
		Ipv4Range *string `json:"ipv4Range,omitempty"`
	} `json:"cidr,omitempty"`

	// DefaultGateway Configuration for the subnet's default gateway.
	// Provides flexibility in routing traffic.
	DefaultGateway *struct {
		Type *SubnetPropertiesSpecDefaultGatewayType `json:"type,omitempty"`

		// Value - For 'instanceRef': Name of the compute instance acting as gateway
		// - For 'internalIp': Specific IP address to use as gateway
		Value *string `json:"value,omitempty"`
	} `json:"defaultGateway,omitempty"`

	// DhcpEnabled for now we allow only dhcp enabled
	DhcpEnabled *SubnetPropertiesSpecDhcpEnabled `json:"dhcpEnabled,omitempty"`
	Profile     *struct {
		// NetworkSkuRef Reference to a network SKU defining bandwidth performance.
		// Allows selection of network performance tier.
		// Pattern: '^seca\.(10|100|1000)$'
		NetworkSkuRef *string `json:"networkSkuRef,omitempty"`
	} `json:"profile,omitempty"`
}

// SubnetPropertiesSpecDefaultGatewayType defines model for SubnetPropertiesSpec.DefaultGateway.Type.
type SubnetPropertiesSpecDefaultGatewayType string

// SubnetPropertiesSpecDhcpEnabled for now we allow only dhcp enabled
type SubnetPropertiesSpecDhcpEnabled bool

// VolumeAttachment Represents a connection between a Block Storage and a device
type VolumeAttachment struct {
	ObjectRef  *string `json:"objectRef,omitempty"`
	Properties *struct {
		// ConnectionType The connection type depends on the type of device and type of block storage.
		ConnectionType *string `json:"connectionType,omitempty"`

		// DeviceKind the type of device a block-storage is connected to. For now only 'instance' possible
		DeviceKind *string `json:"deviceKind,omitempty"`
		DeviceRef  *string `json:"deviceRef,omitempty"`
	} `json:"properties,omitempty"`
}

// PropertiesSpec defines model for properties-spec.
type PropertiesSpec struct {
	// Permissions List of permissions granted by this role
	Permissions *[]string `json:"permissions,omitempty"`
}

// Spec Desired state of the workspace
type Spec struct {
	// Description Optional description of the workspace
	Description *string `json:"description,omitempty"`

	// Name Unique name of the workspace within the tenant
	Name string `json:"name"`
}

// AcceptHeader defines model for acceptHeader.
type AcceptHeader = string

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// TenantID defines model for tenantID.
type TenantID = string

// ListAuditLogsParams defines parameters for ListAuditLogs.
type ListAuditLogsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - application/json: Returns only non-deleted resources
	// - application/json; deleted=true: Returns both deleted and non-deleted resources
	// - application/json; deleted=only: Returns only deleted resources
	Accept *AcceptHeader `json:"Accept,omitempty"`
}

// Getter for additional properties for InstanceSkuPropertiesSpec_Capabilities. Returns the specified
// element and whether it was found
func (a InstanceSkuPropertiesSpec_Capabilities) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for InstanceSkuPropertiesSpec_Capabilities
func (a *InstanceSkuPropertiesSpec_Capabilities) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for InstanceSkuPropertiesSpec_Capabilities to handle AdditionalProperties
func (a *InstanceSkuPropertiesSpec_Capabilities) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["benchmarkPoints"]; found {
		err = json.Unmarshal(raw, &a.BenchmarkPoints)
		if err != nil {
			return fmt.Errorf("error reading 'benchmarkPoints': %w", err)
		}
		delete(object, "benchmarkPoints")
	}

	if raw, found := object["ramGB"]; found {
		err = json.Unmarshal(raw, &a.RamGB)
		if err != nil {
			return fmt.Errorf("error reading 'ramGB': %w", err)
		}
		delete(object, "ramGB")
	}

	if raw, found := object["vCPU"]; found {
		err = json.Unmarshal(raw, &a.VCPU)
		if err != nil {
			return fmt.Errorf("error reading 'vCPU': %w", err)
		}
		delete(object, "vCPU")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for InstanceSkuPropertiesSpec_Capabilities to handle AdditionalProperties
func (a InstanceSkuPropertiesSpec_Capabilities) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.BenchmarkPoints != nil {
		object["benchmarkPoints"], err = json.Marshal(a.BenchmarkPoints)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'benchmarkPoints': %w", err)
		}
	}

	if a.RamGB != nil {
		object["ramGB"], err = json.Marshal(a.RamGB)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ramGB': %w", err)
		}
	}

	if a.VCPU != nil {
		object["vCPU"], err = json.Marshal(a.VCPU)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vCPU': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsSpec returns the union data inside the ActivityLog_Spec_Request_Body as a Spec
func (t ActivityLog_Spec_Request_Body) AsSpec() (Spec, error) {
	var body Spec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided Spec
func (t *ActivityLog_Spec_Request_Body) FromSpec(v Spec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided Spec
func (t *ActivityLog_Spec_Request_Body) MergeSpec(v Spec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a PropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsPropertiesSpec() (PropertiesSpec, error) {
	var body PropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided PropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromPropertiesSpec(v PropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided PropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergePropertiesSpec(v PropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRoleAssignmentPropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a RoleAssignmentPropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsRoleAssignmentPropertiesSpec() (RoleAssignmentPropertiesSpec, error) {
	var body RoleAssignmentPropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRoleAssignmentPropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided RoleAssignmentPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromRoleAssignmentPropertiesSpec(v RoleAssignmentPropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRoleAssignmentPropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided RoleAssignmentPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergeRoleAssignmentPropertiesSpec(v RoleAssignmentPropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResourceQuota returns the union data inside the ActivityLog_Spec_Request_Body as a ResourceQuota
func (t ActivityLog_Spec_Request_Body) AsResourceQuota() (ResourceQuota, error) {
	var body ResourceQuota
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResourceQuota overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided ResourceQuota
func (t *ActivityLog_Spec_Request_Body) FromResourceQuota(v ResourceQuota) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResourceQuota performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided ResourceQuota
func (t *ActivityLog_Spec_Request_Body) MergeResourceQuota(v ResourceQuota) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceSkuPropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a InstanceSkuPropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsInstanceSkuPropertiesSpec() (InstanceSkuPropertiesSpec, error) {
	var body InstanceSkuPropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceSkuPropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided InstanceSkuPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromInstanceSkuPropertiesSpec(v InstanceSkuPropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceSkuPropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided InstanceSkuPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergeInstanceSkuPropertiesSpec(v InstanceSkuPropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetworkSkuPropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a NetworkSkuPropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsNetworkSkuPropertiesSpec() (NetworkSkuPropertiesSpec, error) {
	var body NetworkSkuPropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkSkuPropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided NetworkSkuPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromNetworkSkuPropertiesSpec(v NetworkSkuPropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkSkuPropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided NetworkSkuPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergeNetworkSkuPropertiesSpec(v NetworkSkuPropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStorageSkuPropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a StorageSkuPropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsStorageSkuPropertiesSpec() (StorageSkuPropertiesSpec, error) {
	var body StorageSkuPropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStorageSkuPropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided StorageSkuPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromStorageSkuPropertiesSpec(v StorageSkuPropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStorageSkuPropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided StorageSkuPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergeStorageSkuPropertiesSpec(v StorageSkuPropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstancePropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a InstancePropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsInstancePropertiesSpec() (InstancePropertiesSpec, error) {
	var body InstancePropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstancePropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided InstancePropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromInstancePropertiesSpec(v InstancePropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstancePropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided InstancePropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergeInstancePropertiesSpec(v InstancePropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlockStoragePropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a BlockStoragePropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsBlockStoragePropertiesSpec() (BlockStoragePropertiesSpec, error) {
	var body BlockStoragePropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlockStoragePropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided BlockStoragePropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromBlockStoragePropertiesSpec(v BlockStoragePropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlockStoragePropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided BlockStoragePropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergeBlockStoragePropertiesSpec(v BlockStoragePropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsObjectStoragePropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a ObjectStoragePropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsObjectStoragePropertiesSpec() (ObjectStoragePropertiesSpec, error) {
	var body ObjectStoragePropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObjectStoragePropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided ObjectStoragePropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromObjectStoragePropertiesSpec(v ObjectStoragePropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObjectStoragePropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided ObjectStoragePropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergeObjectStoragePropertiesSpec(v ObjectStoragePropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLANPropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a LANPropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsLANPropertiesSpec() (LANPropertiesSpec, error) {
	var body LANPropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLANPropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided LANPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromLANPropertiesSpec(v LANPropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLANPropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided LANPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergeLANPropertiesSpec(v LANPropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubnetPropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a SubnetPropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsSubnetPropertiesSpec() (SubnetPropertiesSpec, error) {
	var body SubnetPropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubnetPropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided SubnetPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromSubnetPropertiesSpec(v SubnetPropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubnetPropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided SubnetPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergeSubnetPropertiesSpec(v SubnetPropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityGroupPropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a SecurityGroupPropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsSecurityGroupPropertiesSpec() (SecurityGroupPropertiesSpec, error) {
	var body SecurityGroupPropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityGroupPropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided SecurityGroupPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromSecurityGroupPropertiesSpec(v SecurityGroupPropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityGroupPropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided SecurityGroupPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergeSecurityGroupPropertiesSpec(v SecurityGroupPropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNICPropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a NICPropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsNICPropertiesSpec() (NICPropertiesSpec, error) {
	var body NICPropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNICPropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided NICPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromNICPropertiesSpec(v NICPropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNICPropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided NICPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergeNICPropertiesSpec(v NICPropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPublicIpPropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a PublicIpPropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsPublicIpPropertiesSpec() (PublicIpPropertiesSpec, error) {
	var body PublicIpPropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPublicIpPropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided PublicIpPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromPublicIpPropertiesSpec(v PublicIpPropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePublicIpPropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided PublicIpPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergePublicIpPropertiesSpec(v PublicIpPropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetworkLoadBalancerPropertiesSpec returns the union data inside the ActivityLog_Spec_Request_Body as a NetworkLoadBalancerPropertiesSpec
func (t ActivityLog_Spec_Request_Body) AsNetworkLoadBalancerPropertiesSpec() (NetworkLoadBalancerPropertiesSpec, error) {
	var body NetworkLoadBalancerPropertiesSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkLoadBalancerPropertiesSpec overwrites any union data inside the ActivityLog_Spec_Request_Body as the provided NetworkLoadBalancerPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) FromNetworkLoadBalancerPropertiesSpec(v NetworkLoadBalancerPropertiesSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkLoadBalancerPropertiesSpec performs a merge with any union data inside the ActivityLog_Spec_Request_Body, using the provided NetworkLoadBalancerPropertiesSpec
func (t *ActivityLog_Spec_Request_Body) MergeNetworkLoadBalancerPropertiesSpec(v NetworkLoadBalancerPropertiesSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ActivityLog_Spec_Request_Body) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ActivityLog_Spec_Request_Body) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAuditLogs request
	ListAuditLogs(ctx context.Context, id TenantID, workspace string, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAuditLogs(ctx context.Context, id TenantID, workspace string, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuditLogsRequest(c.Server, id, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAuditLogsRequest generates requests for ListAuditLogs
func NewListAuditLogsRequest(server string, id TenantID, workspace string, params *ListAuditLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/activity-logs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAuditLogsWithResponse request
	ListAuditLogsWithResponse(ctx context.Context, id TenantID, workspace string, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error)
}

type ListAuditLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]ActivityLog `json:"items,omitempty"`
		Metadata *struct {
			// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
			SkipToken *string `json:"skipToken,omitempty"`
		} `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListAuditLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuditLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAuditLogsWithResponse request returning *ListAuditLogsResponse
func (c *ClientWithResponses) ListAuditLogsWithResponse(ctx context.Context, id TenantID, workspace string, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error) {
	rsp, err := c.ListAuditLogs(ctx, id, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuditLogsResponse(rsp)
}

// ParseListAuditLogsResponse parses an HTTP response from a ListAuditLogsWithResponse call
func ParseListAuditLogsResponse(rsp *http.Response) (*ListAuditLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuditLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]ActivityLog `json:"items,omitempty"`
			Metadata *struct {
				// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
				SkipToken *string `json:"skipToken,omitempty"`
			} `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all Audit Logs
	// (GET /v1/tenants/{id}/workspaces/{workspace}/activity-logs)
	ListAuditLogs(ctx echo.Context, id TenantID, workspace string, params ListAuditLogsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAuditLogs converts echo context to params.
func (w *ServerInterfaceWrapper) ListAuditLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", ctx.Param("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAuditLogsParams
	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", ctx.QueryParams(), &params.Labels)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter labels: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", ctx.QueryParams(), &params.SkipToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skipToken: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept: %s", err))
		}

		params.Accept = &Accept
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAuditLogs(ctx, id, workspace, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v1/tenants/:id/workspaces/:workspace/activity-logs", wrapper.ListAuditLogs)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"8OnhfwIAAP//Zgx0pi9nAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
