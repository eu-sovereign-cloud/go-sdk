//go:build go1.22

// Package activitylogs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package activitylogs

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ActivityLogKind.
const (
	ActivityLogKindActivityLog ActivityLogKind = "activity-log"
)

// Defines values for ActivityLogSpecRequestVerb.
const (
	DELETE ActivityLogSpecRequestVerb = "DELETE"
	GET    ActivityLogSpecRequestVerb = "GET"
	POST   ActivityLogSpecRequestVerb = "POST"
	PUT    ActivityLogSpecRequestVerb = "PUT"
)

// Defines values for LoadBalancerTargetAlgorithm.
const (
	ROUNDROBIN LoadBalancerTargetAlgorithm = "ROUND_ROBIN"
)

// Defines values for LoadBalancerTargetProtocol.
const (
	LoadBalancerTargetProtocolTCP LoadBalancerTargetProtocol = "TCP"
	LoadBalancerTargetProtocolUDP LoadBalancerTargetProtocol = "UDP"
)

// Defines values for NetworkLoadBalancerFrontendProtocol.
const (
	NetworkLoadBalancerFrontendProtocolTCP NetworkLoadBalancerFrontendProtocol = "TCP"
	NetworkLoadBalancerFrontendProtocolUDP NetworkLoadBalancerFrontendProtocol = "UDP"
)

// Defines values for NicPrivateIpAdressType.
const (
	NicPrivateIpAdressTypeIPv4 NicPrivateIpAdressType = "IPv4"
)

// Defines values for PublicIpSpecIpVersion.
const (
	PublicIpSpecIpVersionIPv4 PublicIpSpecIpVersion = "IPv4"
)

// Defines values for PublicIpSpecType.
const (
	Dynamic PublicIpSpecType = "Dynamic"
	Static  PublicIpSpecType = "Static"
)

// Defines values for SecurityGroupRuleKind.
const (
	SecurityGroupRuleKindSecurityGroupRule SecurityGroupRuleKind = "security-group-rule"
)

// Defines values for SecurityGroupRuleSourceType.
const (
	SecurityGroupRuleSourceTypeCidr           SecurityGroupRuleSourceType = "cidr"
	SecurityGroupRuleSourceTypePublicInternet SecurityGroupRuleSourceType = "publicInternet"
	SecurityGroupRuleSourceTypeSecurityGroup  SecurityGroupRuleSourceType = "securityGroup"
)

// Defines values for SecurityGroupRuleSpecDirection.
const (
	Egress  SecurityGroupRuleSpecDirection = "egress"
	Ingress SecurityGroupRuleSpecDirection = "ingress"
)

// Defines values for SecurityGroupRuleSpecProtocol.
const (
	All  SecurityGroupRuleSpecProtocol = "all"
	Icmp SecurityGroupRuleSpecProtocol = "icmp"
	Tcp  SecurityGroupRuleSpecProtocol = "tcp"
	Udp  SecurityGroupRuleSpecProtocol = "udp"
)

// Defines values for SubnetSpecDefaultGatewayType.
const (
	Auto        SubnetSpecDefaultGatewayType = "auto"
	InstanceRef SubnetSpecDefaultGatewayType = "instanceRef"
	InternalIp  SubnetSpecDefaultGatewayType = "internalIp"
)

// Defines values for SubnetSpecDhcpEnabled.
const (
	True SubnetSpecDhcpEnabled = true
)

// Defines values for AcceptHeader.
const (
	AcceptHeaderApplicationjson            AcceptHeader = "application/json"
	AcceptHeaderApplicationjsonDeletedOnly AcceptHeader = "application/json; deleted=only"
	AcceptHeaderApplicationjsonDeletedTrue AcceptHeader = "application/json; deleted=true"
)

// Defines values for ListAuditLogsParamsAccept.
const (
	ListAuditLogsParamsAcceptApplicationjson            ListAuditLogsParamsAccept = "application/json"
	ListAuditLogsParamsAcceptApplicationjsonDeletedOnly ListAuditLogsParamsAccept = "application/json; deleted=only"
	ListAuditLogsParamsAcceptApplicationjsonDeletedTrue ListAuditLogsParamsAccept = "application/json; deleted=true"
)

// ActivityLog defines model for ActivityLog.
type ActivityLog struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *ActivityLogKind       `json:"kind,omitempty"`
	Metadata GlobalResourceMetadata `json:"metadata"`
	Spec     ActivityLogSpec        `json:"spec"`
}

// ActivityLogKind Type of the resource
type ActivityLogKind string

// ActivityLogSpec defines model for ActivityLogSpec.
type ActivityLogSpec struct {
	Request *struct {
		Body  *ActivityLogSpec_Request_Body `json:"body,omitempty"`
		Scope *string                       `json:"scope,omitempty"`

		// Verb operation method
		Verb *ActivityLogSpecRequestVerb `json:"verb,omitempty"`
	} `json:"request,omitempty"`
	Response *struct {
		Code *float32 `json:"code,omitempty"`
	} `json:"response,omitempty"`

	// Subject User-JWT executing this query
	Subject *string `json:"subject,omitempty"`
}

// ActivityLogSpec_Request_Body defines model for ActivityLogSpec.Request.Body.
type ActivityLogSpec_Request_Body struct {
	union json.RawMessage
}

// ActivityLogSpecRequestVerb operation method
type ActivityLogSpecRequestVerb string

// BlockStorageSpec defines model for BlockStorageSpec.
type BlockStorageSpec struct {
	Origin *struct {
		// SourceImageRef Reference to the source image used as the base for creating this block storage. This cannot be modified.
		SourceImageRef *string `json:"sourceImageRef,omitempty"`
	} `json:"origin,omitempty"`
	Profile *struct {
		SkuExtensions *SkuExtensions `json:"skuExtensions,omitempty"`

		// StorageSkuRef Reference to the SKU used for this block storage
		StorageSkuRef *string `json:"storageSkuRef,omitempty"`
	} `json:"profile,omitempty"`
	SizeGB *int `json:"sizeGB,omitempty"`
}

// Error A generic error response
type Error struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error400 defines model for Error400.
type Error400 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error401 defines model for Error401.
type Error401 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error403 defines model for Error403.
type Error403 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error404 defines model for Error404.
type Error404 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error500 defines model for Error500.
type Error500 struct {
	Errors []ErrorDetail `json:"errors"`
}

// ErrorDetail A detailed error response
type ErrorDetail struct {
	// Code An application-specific error code, expressed as a string value.
	Code string `json:"code"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta map[string]interface{} `json:"meta"`

	// Source An object containing references to the source of the error.
	Source *ErrorSource `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem.
	Title string `json:"title"`
}

// ErrorSource An object containing references to the source of the error.
type ErrorSource struct {
	// Parameter A string indicating which URI query parameter caused the error.
	Parameter string `json:"parameter"`

	// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
	Pointer string `json:"pointer"`
}

// GlobalResourceMetadata defines model for GlobalResourceMetadata.
type GlobalResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels map[string]interface{} `json:"labels"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name string `json:"name"`
}

// InstanceNetwork defines model for InstanceNetwork.
type InstanceNetwork struct {
	// OtherNics Additional NICs attached to this instance
	OtherNics *[]InstanceNicRef `json:"otherNics,omitempty"`

	// PrimaryNicRef Reference to the primary NIC for this instance
	PrimaryNicRef *string `json:"primaryNicRef,omitempty"`
}

// InstanceNicRef defines model for InstanceNicRef.
type InstanceNicRef struct {
	NicRef *string `json:"nicRef,omitempty"`
	Slot   *int    `json:"slot,omitempty"`
}

// InstanceSkuCapability Instance performance capabilities
type InstanceSkuCapability struct {
	BenchmarkPoints *int `json:"benchmarkPoints,omitempty"`
	RamGB           *int `json:"ramGB,omitempty"`
	VCPU            *int `json:"vCPU,omitempty"`
}

// InstanceSkuSpec defines model for InstanceSkuSpec.
type InstanceSkuSpec struct {
	// Capabilities Instance performance capabilities
	Capabilities *InstanceSkuCapability `json:"capabilities,omitempty"`
	Description  *string                `json:"description,omitempty"`

	// Extensions Additional instance feature extensions
	Extensions *[]string `json:"extensions,omitempty"`

	// MandatoryParameters Mandatory parameters for block storage resources
	MandatoryParameters *[]string `json:"mandatoryParameters,omitempty"`

	// Provider Provider namespace for instance SKUs
	Provider *string `json:"provider,omitempty"`
	Tier     *string `json:"tier,omitempty"`
}

// InstanceSpec defines model for InstanceSpec.
type InstanceSpec struct {
	Network         *InstanceNetwork `json:"network,omitempty"`
	OperatingSystem *struct {
		CloudInitData *struct {
			// SshKeyExternalRef Provider-specific references to SSH keys used in cloud-init vendorData.
			// These references are used to inject SSH public keys during instance initialization
			// through cloud-init's vendor data configuration.
			SshKeyExternalRef *[]string `json:"sshKeyExternalRef,omitempty"`

			// UserData Cloud-init user data for instance initialization
			// Example cloud-init user configuration with SSH key:
			// ```yaml
			// #cloud-config
			// packages:
			//   - nginx
			// ```
			UserData *string `json:"userData,omitempty"`
		} `json:"cloudInitData,omitempty"`

		// OsBlockStorageRef Represents a connection between a Block Storage and a device
		OsBlockStorageRef *VolumeAttachment `json:"osBlockStorageRef,omitempty"`
	} `json:"operatingSystem,omitempty"`
	Profile *struct {
		// InstanceSkuRef Reference to the SKU used for this instance
		InstanceSkuRef *string        `json:"instanceSkuRef,omitempty"`
		SkuExtensions  *SkuExtensions `json:"skuExtensions,omitempty"`
	} `json:"profile,omitempty"`
	Storage *struct {
		DataBlockStorageRef *[]VolumeAttachment `json:"dataBlockStorageRef,omitempty"`
	} `json:"storage,omitempty"`
}

// LanSpec defines model for LanSpec.
type LanSpec struct {
	Profile *struct {
		// NetworkSkuRef Reference to the SKU used for this LAN
		NetworkSkuRef *string        `json:"networkSkuRef,omitempty"`
		SkuExtensions *SkuExtensions `json:"skuExtensions,omitempty"`
	} `json:"profile,omitempty"`
}

// LoadBalancerHealthCheck Optional port health check. It probes the port with protocol.
type LoadBalancerHealthCheck struct {
	// Interval healthcheck interval in seconds. It means after how many seconds it will take a new check
	Interval *int `json:"interval,omitempty"`

	// Retry healthcheck retry number after considered unhealthy a backend istance
	Retry *int `json:"retry,omitempty"`

	// Timeout healthcheck in seconds. It means after how many seconds the attempt will be considered unhealthy
	Timeout *int `json:"timeout,omitempty"`
}

// LoadBalancerMember defines model for LoadBalancerMember.
type LoadBalancerMember struct {
	// NicRef Nic Reference to the LoadBalancerMember as part of the LoadBalancerTarget
	NicRef *string `json:"nicRef,omitempty"`
}

// LoadBalancerTarget defines model for LoadBalancerTarget.
type LoadBalancerTarget struct {
	// Algorithm LoadBalancer algorithm to take a backend istance
	Algorithm *LoadBalancerTargetAlgorithm `json:"algorithm,omitempty"`

	// Healthcheck Optional port health check. It probes the port with protocol.
	Healthcheck *LoadBalancerHealthCheck `json:"healthcheck,omitempty"`
	Members     *[]LoadBalancerMember    `json:"members,omitempty"`

	// Port A valid network port number.
	Port *int32 `json:"port,omitempty"`

	// Protocol Frontend Protocol to which the load balancer will be listening on
	Protocol *LoadBalancerTargetProtocol `json:"protocol,omitempty"`
}

// LoadBalancerTargetAlgorithm LoadBalancer algorithm to take a backend istance
type LoadBalancerTargetAlgorithm string

// LoadBalancerTargetProtocol Frontend Protocol to which the load balancer will be listening on
type LoadBalancerTargetProtocol string

// NetworkLoadBalancerFrontend defines model for NetworkLoadBalancerFrontend.
type NetworkLoadBalancerFrontend struct {
	// NicRef NIC reference to the LoadBalancer. If ipAddressType will be ipv4 or dual-stack or if the LoadBalancer will be internal or external depends on the associated NIC
	NicRef *string `json:"nicRef,omitempty"`

	// Port A valid network port number.
	Port *int32 `json:"port,omitempty"`

	// Protocol Frontend Protocol to which the load balancer will be listening on
	Protocol *NetworkLoadBalancerFrontendProtocol `json:"protocol,omitempty"`
	Target   *LoadBalancerTarget                  `json:"target,omitempty"`
}

// NetworkLoadBalancerFrontendProtocol Frontend Protocol to which the load balancer will be listening on
type NetworkLoadBalancerFrontendProtocol string

// NetworkLoadBalancerSpec defines model for NetworkLoadBalancerSpec.
type NetworkLoadBalancerSpec struct {
	IpConfigurations *[]NetworkLoadBalancerFrontend `json:"ipConfigurations,omitempty"`
	Profile          *struct {
		// NetworkLoadBalancerSkuRef Reference to the SKU used for this network-load-balancer
		NetworkLoadBalancerSkuRef *string `json:"networkLoadBalancerSkuRef,omitempty"`
	} `json:"profile,omitempty"`
}

// NetworkSkuSpec defines model for NetworkSkuSpec.
type NetworkSkuSpec struct {
	// Capabilities Network performance capabilities
	Capabilities *map[string]interface{} `json:"capabilities,omitempty"`
	Description  *string                 `json:"description,omitempty"`

	// Extensions Additional network feature extensions
	Extensions *[]string `json:"extensions,omitempty"`

	// MandatoryParameters Mandatory parameters for network resources
	MandatoryParameters *[]string `json:"mandatoryParameters,omitempty"`

	// Provider Provider namespace for network SKUs
	Provider *string `json:"provider,omitempty"`

	// Tier Network performance tier
	Tier *string `json:"tier,omitempty"`
}

// NicPrivateIp defines model for NicPrivateIp.
type NicPrivateIp struct {
	AdressType *NicPrivateIpAdressType `json:"adressType,omitempty"`
	IpAddress  *string                 `json:"ipAddress,omitempty"`
}

// NicPrivateIpAdressType defines model for NicPrivateIp.AdressType.
type NicPrivateIpAdressType string

// NicSpec Specification of the Network Interface Card
type NicSpec struct {
	// PublicIPRef References to public IP addresses associated with this NIC. The IP may be external and not directly visible on the server/NIC itself. Maximum one IP allowed.
	PublicIPRef *string `json:"publicIPRef,omitempty"`

	// StaticPrivateIPs List of static private IP addresses for this NIC. Can only be used when the subnet has dhcpEnabled=false.
	StaticPrivateIPs *[]NicPrivateIp `json:"staticPrivateIPs,omitempty"`

	// SubnetRef Subnet this NIC is connected to
	SubnetRef *string `json:"subnetRef,omitempty"`
}

// ObjectStorageSpec defines model for ObjectStorageSpec.
type ObjectStorageSpec struct {
	Profile *struct {
		// ObjectStorageSkuRef Reference to the SKU used for this object-storage
		ObjectStorageSkuRef *string `json:"objectStorageSkuRef,omitempty"`
	} `json:"profile,omitempty"`
}

// PortRange Specific port or port range for the rule
type PortRange struct {
	From *int `json:"from,omitempty"`
	To   *int `json:"to,omitempty"`
}

// PublicIpAssignment defines model for PublicIpAssignment.
type PublicIpAssignment struct {
	// Kind Kind of resource the IP is assigned to
	Kind *string `json:"kind,omitempty"`

	// Name Name of the resource the IP is assigned to
	Name *string `json:"name,omitempty"`
}

// PublicIpSpec Specification of the public IP
type PublicIpSpec struct {
	// AssignedTo References to resources this IP is assigned to
	AssignedTo *[]PublicIpAssignment `json:"assignedTo,omitempty"`

	// IpAddress The public IP address
	IpAddress *string `json:"ipAddress,omitempty"`

	// IpVersion IP version of the address (limited to IPv4 for now)
	IpVersion *PublicIpSpecIpVersion `json:"ipVersion,omitempty"`

	// Type Type of public IP allocation
	Type *PublicIpSpecType `json:"type,omitempty"`
}

// PublicIpSpecIpVersion IP version of the address (limited to IPv4 for now)
type PublicIpSpecIpVersion string

// PublicIpSpecType Type of public IP allocation
type PublicIpSpecType string

// RegionalResourceMetadata defines model for RegionalResourceMetadata.
type RegionalResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels map[string]interface{} `json:"labels"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Location Reference to the region where the resource is located
	Location *struct {
		Region string `json:"region"`
	} `json:"location,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name string `json:"name"`
}

// ResourceMetadata Base metadata for all resources, with optional location references
type ResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels map[string]interface{} `json:"labels"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name string `json:"name"`
}

// ResourceQuotaSpec Represents the ResourceQuota for the single ResourceType of the Resource Provider
type ResourceQuotaSpec struct {
	// Value limit number of resourceType instances, set null for unlimited
	Value *int `json:"value"`
}

// ResponseMetadata defines model for ResponseMetadata.
type ResponseMetadata struct {
	// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
	SkipToken *string `json:"skipToken,omitempty"`
}

// RoleAssignmentSpec defines model for RoleAssignmentSpec.
type RoleAssignmentSpec struct {
	// Roles List of assigned role names
	Roles *[]string `json:"roles,omitempty"`

	// Scopes List of Scopes to whom the roles are assigned
	Scopes *[]string `json:"scopes,omitempty"`

	// Subs List of subject IDs (from JWT) to whom the roles are assigned
	Subs *[]string `json:"subs,omitempty"`
}

// RoleSpec defines model for RoleSpec.
type RoleSpec struct {
	// Permissions List of permissions granted by this role
	Permissions *[]string `json:"permissions,omitempty"`
}

// SecurityGroupRule Represents a security group rule
type SecurityGroupRule struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *SecurityGroupRuleKind    `json:"kind,omitempty"`
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`
	Spec     *SecurityGroupRuleSpec    `json:"spec,omitempty"`

	// Status Current status of the resource
	Status *Status `json:"status,omitempty"`
}

// SecurityGroupRuleKind Type of the resource
type SecurityGroupRuleKind string

// SecurityGroupRuleSource Source of the traffic. Can be a security group, CIDR range, or 'publicInternet'.
// 'publicInternet' allows explicit control over internet-facing traffic.
type SecurityGroupRuleSource struct {
	Type *SecurityGroupRuleSourceType `json:"type,omitempty"`

	// Value - For securityGroup: name of the source security group
	// - For cidr: IPv4 CIDR range
	// - For publicInternet: 'any' or a IPv4 CIDR Range
	Value *string `json:"value,omitempty"`
}

// SecurityGroupRuleSourceType defines model for SecurityGroupRuleSource.Type.
type SecurityGroupRuleSourceType string

// SecurityGroupRuleSpec defines model for SecurityGroupRuleSpec.
type SecurityGroupRuleSpec struct {
	// Description Human-readable description of the rule's purpose
	Description *string `json:"description,omitempty"`

	// Direction - ingress: Only incoming traffic is allowed
	// - egress: Only outgoing traffic is allowed
	// - bidirectional: Traffic can flow both ways
	Direction *SecurityGroupRuleSpecDirection `json:"direction,omitempty"`

	// PortRange Specific port or port range for the rule
	PortRange *PortRange `json:"portRange,omitempty"`

	// Priority Rule priority (lower number = higher priority)
	Priority *int `json:"priority,omitempty"`

	// Protocol Network protocol for the rule
	Protocol *SecurityGroupRuleSpecProtocol `json:"protocol,omitempty"`

	// Source Source of the traffic. Can be a security group, CIDR range, or 'publicInternet'.
	// 'publicInternet' allows explicit control over internet-facing traffic.
	Source *SecurityGroupRuleSource `json:"source,omitempty"`
}

// SecurityGroupRuleSpecDirection - ingress: Only incoming traffic is allowed
// - egress: Only outgoing traffic is allowed
// - bidirectional: Traffic can flow both ways
type SecurityGroupRuleSpecDirection string

// SecurityGroupRuleSpecProtocol Network protocol for the rule
type SecurityGroupRuleSpecProtocol string

// SecurityGroupSpec Specification of the security group
type SecurityGroupSpec struct {
	// Rules Network access rules defining communication between security groups and external networks.
	//
	// Rule Evaluation:
	// - Rules are processed in order of priority (lower number = higher priority)
	// - First matching rule determines the action (allow/deny)
	// - Default behavior is to deny all traffic not explicitly allowed
	Rules *[]SecurityGroupRule `json:"rules,omitempty"`
}

// SkuExtensions defines model for SkuExtensions.
type SkuExtensions map[string]interface{}

// Status Current status of the resource
type Status struct {
	Conditions []StatusCondition `json:"conditions"`
}

// StatusCondition StatusCondition describes the state of a resource at a certain point.
// Conditions are provider-specific and can represent different states depending on the
// resource type and provider implementation.
type StatusCondition struct {
	// LastTransitionTime LastTransitionTime is the last time the condition transitioned from one
	// status to another. This should be when the underlying condition changed.
	// If that is not known, then using the time when the API field changed is
	// acceptable.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message A human-readable message indicating details about the transition.
	Message *string `json:"message,omitempty"`

	// Reason The reason for the condition's last transition in CamelCase.
	// The specific set of reason values is provider-specific and should be
	// documented by the provider.
	Reason *string `json:"reason,omitempty"`

	// Status Status of the condition.
	Status string `json:"status"`

	// Type Type of condition. The condition type is provider-specific and should
	// reflect the specific states relevant to your resource.
	Type string `json:"type"`
}

// StorageSkuSpec defines model for StorageSkuSpec.
type StorageSkuSpec struct {
	// Capabilities storage performance capabilities
	Capabilities *map[string]interface{} `json:"capabilities,omitempty"`
	Description  *string                 `json:"description,omitempty"`

	// Extensions Additional  storage feature extensions
	Extensions *[]string `json:"extensions,omitempty"`

	// MandatoryParameters Mandatory parameters for  storage resources
	MandatoryParameters *[]string `json:"mandatoryParameters,omitempty"`

	// Provider Provider namespace for  storage SKUs
	Provider *string `json:"provider,omitempty"`

	// Tier storage performance tier
	Tier *string `json:"tier,omitempty"`
}

// SubnetSpec Specification of the subnet
type SubnetSpec struct {
	Cidr *Cidr `json:"cidr,omitempty"`

	// DefaultGateway Configuration for the subnet's default gateway.
	// Provides flexibility in routing traffic.
	DefaultGateway *struct {
		Type *SubnetSpecDefaultGatewayType `json:"type,omitempty"`

		// Value - For 'instanceRef': Name of the compute instance acting as gateway
		// - For 'internalIp': Specific IP address to use as gateway
		Value *string `json:"value,omitempty"`
	} `json:"defaultGateway,omitempty"`

	// DhcpEnabled for now we allow only dhcp enabled
	DhcpEnabled *SubnetSpecDhcpEnabled `json:"dhcpEnabled,omitempty"`
	Profile     *struct {
		// NetworkSkuRef Reference to a network SKU defining bandwidth performance.
		// Allows selection of network performance tier.
		// Pattern: '^seca\.(10|100|1000)$'
		NetworkSkuRef *string `json:"networkSkuRef,omitempty"`
	} `json:"profile,omitempty"`
}

// SubnetSpecDefaultGatewayType defines model for SubnetSpec.DefaultGateway.Type.
type SubnetSpecDefaultGatewayType string

// SubnetSpecDhcpEnabled for now we allow only dhcp enabled
type SubnetSpecDhcpEnabled bool

// VolumeAttachment Represents a connection between a Block Storage and a device
type VolumeAttachment struct {
	ObjectRef  *string                     `json:"objectRef,omitempty"`
	Properties *VolumeAttachmentProperties `json:"properties,omitempty"`
}

// VolumeAttachmentProperties defines model for VolumeAttachmentProperties.
type VolumeAttachmentProperties struct {
	// ConnectionType The connection type depends on the type of device and type of block storage.
	ConnectionType *string `json:"connectionType,omitempty"`

	// DeviceKind the type of device a block-storage is connected to. For now only 'instance' possible
	DeviceKind *string `json:"deviceKind,omitempty"`
	DeviceRef  *string `json:"deviceRef,omitempty"`
}

// WorkspaceSpec Desired state of the workspace
type WorkspaceSpec struct {
	// Description Optional description of the workspace
	Description *string `json:"description,omitempty"`

	// Name Unique name of the workspace within the tenant
	Name string `json:"name"`
}

// Cidr defines model for cidr.
type Cidr struct {
	// Ipv4Range IPv4 address range for the subnet.
	// Must be unique within the LAN and cannot be modified after creation.
	// Example: '192.168.1.0/24'
	Ipv4Range *string `json:"ipv4Range,omitempty"`
}

// AcceptHeader defines model for acceptHeader.
type AcceptHeader string

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// TenantID defines model for tenantID.
type TenantID = string

// ListAuditLogsParams defines parameters for ListAuditLogs.
type ListAuditLogsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListAuditLogsParamsAccept `json:"Accept,omitempty"`
}

// ListAuditLogsParamsAccept defines parameters for ListAuditLogs.
type ListAuditLogsParamsAccept string

// AsWorkspaceSpec returns the union data inside the ActivityLogSpec_Request_Body as a WorkspaceSpec
func (t ActivityLogSpec_Request_Body) AsWorkspaceSpec() (WorkspaceSpec, error) {
	var body WorkspaceSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkspaceSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided WorkspaceSpec
func (t *ActivityLogSpec_Request_Body) FromWorkspaceSpec(v WorkspaceSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkspaceSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided WorkspaceSpec
func (t *ActivityLogSpec_Request_Body) MergeWorkspaceSpec(v WorkspaceSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRoleSpec returns the union data inside the ActivityLogSpec_Request_Body as a RoleSpec
func (t ActivityLogSpec_Request_Body) AsRoleSpec() (RoleSpec, error) {
	var body RoleSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRoleSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided RoleSpec
func (t *ActivityLogSpec_Request_Body) FromRoleSpec(v RoleSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRoleSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided RoleSpec
func (t *ActivityLogSpec_Request_Body) MergeRoleSpec(v RoleSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRoleAssignmentSpec returns the union data inside the ActivityLogSpec_Request_Body as a RoleAssignmentSpec
func (t ActivityLogSpec_Request_Body) AsRoleAssignmentSpec() (RoleAssignmentSpec, error) {
	var body RoleAssignmentSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRoleAssignmentSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided RoleAssignmentSpec
func (t *ActivityLogSpec_Request_Body) FromRoleAssignmentSpec(v RoleAssignmentSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRoleAssignmentSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided RoleAssignmentSpec
func (t *ActivityLogSpec_Request_Body) MergeRoleAssignmentSpec(v RoleAssignmentSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResourceQuotaSpec returns the union data inside the ActivityLogSpec_Request_Body as a ResourceQuotaSpec
func (t ActivityLogSpec_Request_Body) AsResourceQuotaSpec() (ResourceQuotaSpec, error) {
	var body ResourceQuotaSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResourceQuotaSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided ResourceQuotaSpec
func (t *ActivityLogSpec_Request_Body) FromResourceQuotaSpec(v ResourceQuotaSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResourceQuotaSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided ResourceQuotaSpec
func (t *ActivityLogSpec_Request_Body) MergeResourceQuotaSpec(v ResourceQuotaSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceSkuSpec returns the union data inside the ActivityLogSpec_Request_Body as a InstanceSkuSpec
func (t ActivityLogSpec_Request_Body) AsInstanceSkuSpec() (InstanceSkuSpec, error) {
	var body InstanceSkuSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceSkuSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided InstanceSkuSpec
func (t *ActivityLogSpec_Request_Body) FromInstanceSkuSpec(v InstanceSkuSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceSkuSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided InstanceSkuSpec
func (t *ActivityLogSpec_Request_Body) MergeInstanceSkuSpec(v InstanceSkuSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetworkSkuSpec returns the union data inside the ActivityLogSpec_Request_Body as a NetworkSkuSpec
func (t ActivityLogSpec_Request_Body) AsNetworkSkuSpec() (NetworkSkuSpec, error) {
	var body NetworkSkuSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkSkuSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided NetworkSkuSpec
func (t *ActivityLogSpec_Request_Body) FromNetworkSkuSpec(v NetworkSkuSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkSkuSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided NetworkSkuSpec
func (t *ActivityLogSpec_Request_Body) MergeNetworkSkuSpec(v NetworkSkuSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStorageSkuSpec returns the union data inside the ActivityLogSpec_Request_Body as a StorageSkuSpec
func (t ActivityLogSpec_Request_Body) AsStorageSkuSpec() (StorageSkuSpec, error) {
	var body StorageSkuSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStorageSkuSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided StorageSkuSpec
func (t *ActivityLogSpec_Request_Body) FromStorageSkuSpec(v StorageSkuSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStorageSkuSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided StorageSkuSpec
func (t *ActivityLogSpec_Request_Body) MergeStorageSkuSpec(v StorageSkuSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceSpec returns the union data inside the ActivityLogSpec_Request_Body as a InstanceSpec
func (t ActivityLogSpec_Request_Body) AsInstanceSpec() (InstanceSpec, error) {
	var body InstanceSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided InstanceSpec
func (t *ActivityLogSpec_Request_Body) FromInstanceSpec(v InstanceSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided InstanceSpec
func (t *ActivityLogSpec_Request_Body) MergeInstanceSpec(v InstanceSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlockStorageSpec returns the union data inside the ActivityLogSpec_Request_Body as a BlockStorageSpec
func (t ActivityLogSpec_Request_Body) AsBlockStorageSpec() (BlockStorageSpec, error) {
	var body BlockStorageSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlockStorageSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided BlockStorageSpec
func (t *ActivityLogSpec_Request_Body) FromBlockStorageSpec(v BlockStorageSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlockStorageSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided BlockStorageSpec
func (t *ActivityLogSpec_Request_Body) MergeBlockStorageSpec(v BlockStorageSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsObjectStorageSpec returns the union data inside the ActivityLogSpec_Request_Body as a ObjectStorageSpec
func (t ActivityLogSpec_Request_Body) AsObjectStorageSpec() (ObjectStorageSpec, error) {
	var body ObjectStorageSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObjectStorageSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided ObjectStorageSpec
func (t *ActivityLogSpec_Request_Body) FromObjectStorageSpec(v ObjectStorageSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObjectStorageSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided ObjectStorageSpec
func (t *ActivityLogSpec_Request_Body) MergeObjectStorageSpec(v ObjectStorageSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLanSpec returns the union data inside the ActivityLogSpec_Request_Body as a LanSpec
func (t ActivityLogSpec_Request_Body) AsLanSpec() (LanSpec, error) {
	var body LanSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLanSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided LanSpec
func (t *ActivityLogSpec_Request_Body) FromLanSpec(v LanSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLanSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided LanSpec
func (t *ActivityLogSpec_Request_Body) MergeLanSpec(v LanSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubnetSpec returns the union data inside the ActivityLogSpec_Request_Body as a SubnetSpec
func (t ActivityLogSpec_Request_Body) AsSubnetSpec() (SubnetSpec, error) {
	var body SubnetSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubnetSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided SubnetSpec
func (t *ActivityLogSpec_Request_Body) FromSubnetSpec(v SubnetSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubnetSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided SubnetSpec
func (t *ActivityLogSpec_Request_Body) MergeSubnetSpec(v SubnetSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityGroupSpec returns the union data inside the ActivityLogSpec_Request_Body as a SecurityGroupSpec
func (t ActivityLogSpec_Request_Body) AsSecurityGroupSpec() (SecurityGroupSpec, error) {
	var body SecurityGroupSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityGroupSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided SecurityGroupSpec
func (t *ActivityLogSpec_Request_Body) FromSecurityGroupSpec(v SecurityGroupSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityGroupSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided SecurityGroupSpec
func (t *ActivityLogSpec_Request_Body) MergeSecurityGroupSpec(v SecurityGroupSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNicSpec returns the union data inside the ActivityLogSpec_Request_Body as a NicSpec
func (t ActivityLogSpec_Request_Body) AsNicSpec() (NicSpec, error) {
	var body NicSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNicSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided NicSpec
func (t *ActivityLogSpec_Request_Body) FromNicSpec(v NicSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNicSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided NicSpec
func (t *ActivityLogSpec_Request_Body) MergeNicSpec(v NicSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPublicIpSpec returns the union data inside the ActivityLogSpec_Request_Body as a PublicIpSpec
func (t ActivityLogSpec_Request_Body) AsPublicIpSpec() (PublicIpSpec, error) {
	var body PublicIpSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPublicIpSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided PublicIpSpec
func (t *ActivityLogSpec_Request_Body) FromPublicIpSpec(v PublicIpSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePublicIpSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided PublicIpSpec
func (t *ActivityLogSpec_Request_Body) MergePublicIpSpec(v PublicIpSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetworkLoadBalancerSpec returns the union data inside the ActivityLogSpec_Request_Body as a NetworkLoadBalancerSpec
func (t ActivityLogSpec_Request_Body) AsNetworkLoadBalancerSpec() (NetworkLoadBalancerSpec, error) {
	var body NetworkLoadBalancerSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkLoadBalancerSpec overwrites any union data inside the ActivityLogSpec_Request_Body as the provided NetworkLoadBalancerSpec
func (t *ActivityLogSpec_Request_Body) FromNetworkLoadBalancerSpec(v NetworkLoadBalancerSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkLoadBalancerSpec performs a merge with any union data inside the ActivityLogSpec_Request_Body, using the provided NetworkLoadBalancerSpec
func (t *ActivityLogSpec_Request_Body) MergeNetworkLoadBalancerSpec(v NetworkLoadBalancerSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ActivityLogSpec_Request_Body) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ActivityLogSpec_Request_Body) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAuditLogs request
	ListAuditLogs(ctx context.Context, id TenantID, workspace string, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAuditLogs(ctx context.Context, id TenantID, workspace string, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuditLogsRequest(c.Server, id, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAuditLogsRequest generates requests for ListAuditLogs
func NewListAuditLogsRequest(server string, id TenantID, workspace string, params *ListAuditLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/activity-logs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAuditLogsWithResponse request
	ListAuditLogsWithResponse(ctx context.Context, id TenantID, workspace string, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error)
}

type ListAuditLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]ActivityLog    `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListAuditLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuditLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAuditLogsWithResponse request returning *ListAuditLogsResponse
func (c *ClientWithResponses) ListAuditLogsWithResponse(ctx context.Context, id TenantID, workspace string, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error) {
	rsp, err := c.ListAuditLogs(ctx, id, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuditLogsResponse(rsp)
}

// ParseListAuditLogsResponse parses an HTTP response from a ListAuditLogsWithResponse call
func ParseListAuditLogsResponse(rsp *http.Response) (*ListAuditLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuditLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]ActivityLog    `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all Audit Logs
	// (GET /v1/tenants/{id}/workspaces/{workspace}/activity-logs)
	ListAuditLogs(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, params ListAuditLogsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListAuditLogs operation middleware
func (siw *ServerInterfaceWrapper) ListAuditLogs(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAuditLogsParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListAuditLogsParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListAuditLogs(w, r, id, workspace, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/activity-logs", wrapper.ListAuditLogs)

	return m
}
