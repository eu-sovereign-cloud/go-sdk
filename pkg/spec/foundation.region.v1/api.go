//go:build go1.22

// Package region provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package region

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for GlobalResourceMetadataKind.
const (
	GlobalResourceMetadataKindActivityLog          GlobalResourceMetadataKind = "activity-log"
	GlobalResourceMetadataKindBlockStorage         GlobalResourceMetadataKind = "block-storage"
	GlobalResourceMetadataKindImage                GlobalResourceMetadataKind = "image"
	GlobalResourceMetadataKindInstance             GlobalResourceMetadataKind = "instance"
	GlobalResourceMetadataKindInstanceSku          GlobalResourceMetadataKind = "instance-sku"
	GlobalResourceMetadataKindInternetGateway      GlobalResourceMetadataKind = "internet-gateway"
	GlobalResourceMetadataKindNetwork              GlobalResourceMetadataKind = "network"
	GlobalResourceMetadataKindNetworkLoadBalancer  GlobalResourceMetadataKind = "network-load-balancer"
	GlobalResourceMetadataKindNetworkSku           GlobalResourceMetadataKind = "network-sku"
	GlobalResourceMetadataKindNic                  GlobalResourceMetadataKind = "nic"
	GlobalResourceMetadataKindObjectStorageAccount GlobalResourceMetadataKind = "object-storage-account"
	GlobalResourceMetadataKindPublicIp             GlobalResourceMetadataKind = "public-ip"
	GlobalResourceMetadataKindRegion               GlobalResourceMetadataKind = "region"
	GlobalResourceMetadataKindRole                 GlobalResourceMetadataKind = "role"
	GlobalResourceMetadataKindRoleAssignment       GlobalResourceMetadataKind = "role-assignment"
	GlobalResourceMetadataKindRoutingTable         GlobalResourceMetadataKind = "routing-table"
	GlobalResourceMetadataKindSecurityGroup        GlobalResourceMetadataKind = "security-group"
	GlobalResourceMetadataKindSecurityGroupRule    GlobalResourceMetadataKind = "security-group-rule"
	GlobalResourceMetadataKindStorageSku           GlobalResourceMetadataKind = "storage-sku"
	GlobalResourceMetadataKindSubnet               GlobalResourceMetadataKind = "subnet"
	GlobalResourceMetadataKindWorkspace            GlobalResourceMetadataKind = "workspace"
)

// Defines values for TypeMetadataKind.
const (
	TypeMetadataKindActivityLog          TypeMetadataKind = "activity-log"
	TypeMetadataKindBlockStorage         TypeMetadataKind = "block-storage"
	TypeMetadataKindImage                TypeMetadataKind = "image"
	TypeMetadataKindInstance             TypeMetadataKind = "instance"
	TypeMetadataKindInstanceSku          TypeMetadataKind = "instance-sku"
	TypeMetadataKindInternetGateway      TypeMetadataKind = "internet-gateway"
	TypeMetadataKindNetwork              TypeMetadataKind = "network"
	TypeMetadataKindNetworkLoadBalancer  TypeMetadataKind = "network-load-balancer"
	TypeMetadataKindNetworkSku           TypeMetadataKind = "network-sku"
	TypeMetadataKindNic                  TypeMetadataKind = "nic"
	TypeMetadataKindObjectStorageAccount TypeMetadataKind = "object-storage-account"
	TypeMetadataKindPublicIp             TypeMetadataKind = "public-ip"
	TypeMetadataKindRegion               TypeMetadataKind = "region"
	TypeMetadataKindRole                 TypeMetadataKind = "role"
	TypeMetadataKindRoleAssignment       TypeMetadataKind = "role-assignment"
	TypeMetadataKindRoutingTable         TypeMetadataKind = "routing-table"
	TypeMetadataKindSecurityGroup        TypeMetadataKind = "security-group"
	TypeMetadataKindSecurityGroupRule    TypeMetadataKind = "security-group-rule"
	TypeMetadataKindStorageSku           TypeMetadataKind = "storage-sku"
	TypeMetadataKindSubnet               TypeMetadataKind = "subnet"
	TypeMetadataKindWorkspace            TypeMetadataKind = "workspace"
)

// Defines values for AcceptHeader.
const (
	AcceptHeaderApplicationjson            AcceptHeader = "application/json"
	AcceptHeaderApplicationjsonDeletedOnly AcceptHeader = "application/json; deleted=only"
	AcceptHeaderApplicationjsonDeletedTrue AcceptHeader = "application/json; deleted=true"
)

// Defines values for ListRegionsParamsAccept.
const (
	ListRegionsParamsAcceptApplicationjson            ListRegionsParamsAccept = "application/json"
	ListRegionsParamsAcceptApplicationjsonDeletedOnly ListRegionsParamsAccept = "application/json; deleted=only"
	ListRegionsParamsAcceptApplicationjsonDeletedTrue ListRegionsParamsAccept = "application/json; deleted=true"
)

// Error A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta    *map[string]interface{} `json:"meta,omitempty"`
	Sources *[]ErrorSource          `json:"sources,omitempty"`

	// Status The HTTP status type ([http://secapi.eu/errors/-rfc7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem
	// type.  It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`

	// Type The type of error, expressed as a URI.
	Type string `json:"type"`
}

// Error400 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error400 = Error

// Error401 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error401 = Error

// Error403 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error403 = Error

// Error404 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error404 = Error

// Error500 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error500 = Error

// ErrorSource An object containing references to the source of the error.
type ErrorSource struct {
	// Parameter A string indicating which URI query parameter caused the error.
	Parameter string `json:"parameter"`

	// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
	Pointer string `json:"pointer"`
}

// GlobalResourceMetadata defines model for GlobalResourceMetadata.
type GlobalResourceMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// CreatedAt Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Kind Type of the resource
	Kind GlobalResourceMetadataKind `json:"kind"`

	// LastModifiedAt Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedAt time.Time `json:"lastModifiedAt"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name     string `json:"name"`
	Provider string `json:"provider"`

	// Ref Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
	// The reference can be used to refer to a resource in other resources.
	Ref      *Reference `json:"ref,omitempty"`
	Resource string     `json:"resource"`

	// ResourceVersion Incremented on every modification of the resource. Used for optimistic concurrency control.
	ResourceVersion int `json:"resourceVersion"`

	// Tenant Tenant identifier
	Tenant string `json:"tenant"`
	Verb   string `json:"verb"`
}

// GlobalResourceMetadataKind Type of the resource
type GlobalResourceMetadataKind string

// ModificationMetadata Base metadata for all resources with optional region references
type ModificationMetadata struct {
	// CreatedAt Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// LastModifiedAt Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedAt time.Time `json:"lastModifiedAt"`

	// ResourceVersion Incremented on every modification of the resource. Used for optimistic concurrency control.
	ResourceVersion int `json:"resourceVersion"`
}

// NameMetadata Metadata for resource names
type NameMetadata struct {
	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name string `json:"name"`
}

// PermissionMetadata Metadata for permission management
type PermissionMetadata struct {
	Provider string `json:"provider"`
	Resource string `json:"resource"`
	Verb     string `json:"verb"`
}

// Provider A provider of cloud services
type Provider struct {
	Name    string `json:"name"`
	Url     string `json:"url"`
	Version string `json:"version"`
}

// Reference Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
// The reference can be used to refer to a resource in other resources.
type Reference struct {
	union json.RawMessage
}

// ReferenceObject A reference to a resource using an object. The object contains the
// same information as the ReferenceURN, but is represented as a structured object.
// The advantage of this representation is that it can be used to reference
// resources in different workspaces or regions without the need to specify
// the full URN.
type ReferenceObject struct {
	// Provider Provider of the resource. If not set, the provider is inferred from the context.
	Provider *string `json:"provider,omitempty"`

	// Region Region of the resource. If not set, the region is inferred from the context.
	Region *string `json:"region,omitempty"`

	// Resource Name and type of the resource. Must be in the format `<type>/<name>`.
	// The type is the resource type, and the name is the resource name.
	Resource string `json:"resource"`

	// Tenant Tenant of the resource. If not set, the tenant is inferred from the context.
	Tenant *string `json:"tenant,omitempty"`

	// Workspace Workspace of the resource. If not set, the workspace is inferred from the context.
	Workspace *string `json:"workspace,omitempty"`
}

// ReferenceURN A unique resource name used to reference this resource in other resources. The reference
// is represented as the full URN (Uniform Resource Name) name of the resource.
//
// ### Automatic Prefix Inference
//
// In most cases, the prefix of the URN can be automatically derived in the given context.
// To simplify usage, only the resource type and name might be specified as a reference
// using the `<type>/<name>` notation. The suffix can be made more specific by adding
// additional segments separated by slashes.
//
// The prefix is automatically inferred from the context. For example, if the resource is a
// block storage in the same workspace the reference can be specified as
// `block-storages/my-block-storage`. If the resource is a block storage in a different workspace, the
// reference can be specified as `workspaces/ws-1/block-storages/my-block-storage`.
//
// For automatic prefix inference, the following rules apply:
// - the version is inferred from the current resource version
// - the workspace is inferred from the current workspace
// - the region is inferred from the current region
// - the provider is inferred from the type and context of the usage
//
// The prefix inference is resolved on admission into the full URN format, which makes it
// mostly suitable for human use.
type ReferenceURN = string

// Region Represents a region, which is a geographical location
// with one or more zones.
type Region struct {
	// Metadata Metadata for global resources with name, permission, modification, type, and tenant information.
	Metadata *GlobalResourceMetadata `json:"metadata,omitempty"`

	// Spec The specification of a region, including the available zones and providers.
	Spec RegionSpec `json:"spec"`
}

// RegionIterator Iterator for regions
type RegionIterator struct {
	// Items List of regions
	Items []Region `json:"items"`

	// Metadata Metadata for response objects.
	Metadata ResponseMetadata `json:"metadata"`
}

// RegionSpec The specification of a region, including the available zones and providers.
type RegionSpec struct {
	// AvailableZones The list of zones available in the region.
	AvailableZones []Zone `json:"availableZones"`

	// Providers The list of providers available in the region.
	Providers []Provider `json:"providers"`
}

// ResponseMetadata defines model for ResponseMetadata.
type ResponseMetadata struct {
	Provider string `json:"provider"`
	Resource string `json:"resource"`

	// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
	SkipToken *string `json:"skipToken,omitempty"`
	Verb      string  `json:"verb"`
}

// TenantMetadata Metadata for resources with tenant constraints
type TenantMetadata struct {
	// Tenant Tenant identifier
	Tenant string `json:"tenant"`
}

// TypeMetadata Metadata for all resources with type information.
type TypeMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// Kind Type of the resource
	Kind TypeMetadataKind `json:"kind"`

	// Ref Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
	// The reference can be used to refer to a resource in other resources.
	Ref *Reference `json:"ref,omitempty"`
}

// TypeMetadataKind Type of the resource
type TypeMetadataKind string

// Zone Reference to a specific zone within a region
type Zone = string

// AcceptHeader defines model for acceptHeader.
type AcceptHeader string

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// ResourcePathParam defines model for resourcePathParam.
type ResourcePathParam = string

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// ListRegionsParams defines parameters for ListRegions.
type ListRegionsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListRegionsParamsAccept `json:"Accept,omitempty"`
}

// ListRegionsParamsAccept defines parameters for ListRegions.
type ListRegionsParamsAccept string

// AsReferenceURN returns the union data inside the Reference as a ReferenceURN
func (t Reference) AsReferenceURN() (ReferenceURN, error) {
	var body ReferenceURN
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReferenceURN overwrites any union data inside the Reference as the provided ReferenceURN
func (t *Reference) FromReferenceURN(v ReferenceURN) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReferenceURN performs a merge with any union data inside the Reference, using the provided ReferenceURN
func (t *Reference) MergeReferenceURN(v ReferenceURN) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReferenceObject returns the union data inside the Reference as a ReferenceObject
func (t Reference) AsReferenceObject() (ReferenceObject, error) {
	var body ReferenceObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReferenceObject overwrites any union data inside the Reference as the provided ReferenceObject
func (t *Reference) FromReferenceObject(v ReferenceObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReferenceObject performs a merge with any union data inside the Reference, using the provided ReferenceObject
func (t *Reference) MergeReferenceObject(v ReferenceObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Reference) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Reference) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListRegions request
	ListRegions(ctx context.Context, params *ListRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegion request
	GetRegion(ctx context.Context, name ResourcePathParam, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListRegions(ctx context.Context, params *ListRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRegionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegion(ctx context.Context, name ResourcePathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegionRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListRegionsRequest generates requests for ListRegions
func NewListRegionsRequest(server string, params *ListRegionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/regions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewGetRegionRequest generates requests for GetRegion
func NewGetRegionRequest(server string, name ResourcePathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/regions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListRegionsWithResponse request
	ListRegionsWithResponse(ctx context.Context, params *ListRegionsParams, reqEditors ...RequestEditorFn) (*ListRegionsResponse, error)

	// GetRegionWithResponse request
	GetRegionWithResponse(ctx context.Context, name ResourcePathParam, reqEditors ...RequestEditorFn) (*GetRegionResponse, error)
}

type ListRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegionIterator
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r ListRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Region
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListRegionsWithResponse request returning *ListRegionsResponse
func (c *ClientWithResponses) ListRegionsWithResponse(ctx context.Context, params *ListRegionsParams, reqEditors ...RequestEditorFn) (*ListRegionsResponse, error) {
	rsp, err := c.ListRegions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRegionsResponse(rsp)
}

// GetRegionWithResponse request returning *GetRegionResponse
func (c *ClientWithResponses) GetRegionWithResponse(ctx context.Context, name ResourcePathParam, reqEditors ...RequestEditorFn) (*GetRegionResponse, error) {
	rsp, err := c.GetRegion(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegionResponse(rsp)
}

// ParseListRegionsResponse parses an HTTP response from a ListRegionsWithResponse call
func ParseListRegionsResponse(rsp *http.Response) (*ListRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegionIterator
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRegionResponse parses an HTTP response from a GetRegionWithResponse call
func ParseGetRegionResponse(rsp *http.Response) (*GetRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Region
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List regions
	// (GET /v1/regions)
	ListRegions(w http.ResponseWriter, r *http.Request, params ListRegionsParams)
	// Get region
	// (GET /v1/regions/{name})
	GetRegion(w http.ResponseWriter, r *http.Request, name ResourcePathParam)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListRegions operation middleware
func (siw *ServerInterfaceWrapper) ListRegions(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRegionsParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListRegionsParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRegions(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRegion operation middleware
func (siw *ServerInterfaceWrapper) GetRegion(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "name" -------------
	var name ResourcePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRegion(w, r, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/v1/regions", wrapper.ListRegions)
	m.HandleFunc("GET "+options.BaseURL+"/v1/regions/{name}", wrapper.GetRegion)

	return m
}
