//go:build go1.22

// Package compute provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package compute

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ResourceState.
const (
	ResourceStateActive    ResourceState = "active"
	ResourceStateCreating  ResourceState = "creating"
	ResourceStateDeleting  ResourceState = "deleting"
	ResourceStateError     ResourceState = "error"
	ResourceStatePending   ResourceState = "pending"
	ResourceStateSuspended ResourceState = "suspended"
	ResourceStateUpdating  ResourceState = "updating"
)

// Defines values for TypeMetadataKind.
const (
	TypeMetadataKindActivityLog          TypeMetadataKind = "activity-log"
	TypeMetadataKindBlockStorage         TypeMetadataKind = "block-storage"
	TypeMetadataKindImage                TypeMetadataKind = "image"
	TypeMetadataKindInstance             TypeMetadataKind = "instance"
	TypeMetadataKindInstanceSku          TypeMetadataKind = "instance-sku"
	TypeMetadataKindInternetGateway      TypeMetadataKind = "internet-gateway"
	TypeMetadataKindNetwork              TypeMetadataKind = "network"
	TypeMetadataKindNetworkLoadBalancer  TypeMetadataKind = "network-load-balancer"
	TypeMetadataKindNetworkSku           TypeMetadataKind = "network-sku"
	TypeMetadataKindNic                  TypeMetadataKind = "nic"
	TypeMetadataKindObjectStorageAccount TypeMetadataKind = "object-storage-account"
	TypeMetadataKindPublicIp             TypeMetadataKind = "public-ip"
	TypeMetadataKindRegion               TypeMetadataKind = "region"
	TypeMetadataKindRole                 TypeMetadataKind = "role"
	TypeMetadataKindRoleAssignment       TypeMetadataKind = "role-assignment"
	TypeMetadataKindRoutingTable         TypeMetadataKind = "routing-table"
	TypeMetadataKindSecurityGroup        TypeMetadataKind = "security-group"
	TypeMetadataKindSecurityGroupRule    TypeMetadataKind = "security-group-rule"
	TypeMetadataKindStorageSku           TypeMetadataKind = "storage-sku"
	TypeMetadataKindSubnet               TypeMetadataKind = "subnet"
	TypeMetadataKindWorkspace            TypeMetadataKind = "workspace"
)

// Defines values for VolumeReferenceType.
const (
	Virtio VolumeReferenceType = "virtio"
)

// Defines values for ZonalResourceMetadataKind.
const (
	ZonalResourceMetadataKindActivityLog          ZonalResourceMetadataKind = "activity-log"
	ZonalResourceMetadataKindBlockStorage         ZonalResourceMetadataKind = "block-storage"
	ZonalResourceMetadataKindImage                ZonalResourceMetadataKind = "image"
	ZonalResourceMetadataKindInstance             ZonalResourceMetadataKind = "instance"
	ZonalResourceMetadataKindInstanceSku          ZonalResourceMetadataKind = "instance-sku"
	ZonalResourceMetadataKindInternetGateway      ZonalResourceMetadataKind = "internet-gateway"
	ZonalResourceMetadataKindNetwork              ZonalResourceMetadataKind = "network"
	ZonalResourceMetadataKindNetworkLoadBalancer  ZonalResourceMetadataKind = "network-load-balancer"
	ZonalResourceMetadataKindNetworkSku           ZonalResourceMetadataKind = "network-sku"
	ZonalResourceMetadataKindNic                  ZonalResourceMetadataKind = "nic"
	ZonalResourceMetadataKindObjectStorageAccount ZonalResourceMetadataKind = "object-storage-account"
	ZonalResourceMetadataKindPublicIp             ZonalResourceMetadataKind = "public-ip"
	ZonalResourceMetadataKindRegion               ZonalResourceMetadataKind = "region"
	ZonalResourceMetadataKindRole                 ZonalResourceMetadataKind = "role"
	ZonalResourceMetadataKindRoleAssignment       ZonalResourceMetadataKind = "role-assignment"
	ZonalResourceMetadataKindRoutingTable         ZonalResourceMetadataKind = "routing-table"
	ZonalResourceMetadataKindSecurityGroup        ZonalResourceMetadataKind = "security-group"
	ZonalResourceMetadataKindSecurityGroupRule    ZonalResourceMetadataKind = "security-group-rule"
	ZonalResourceMetadataKindStorageSku           ZonalResourceMetadataKind = "storage-sku"
	ZonalResourceMetadataKindSubnet               ZonalResourceMetadataKind = "subnet"
	ZonalResourceMetadataKindWorkspace            ZonalResourceMetadataKind = "workspace"
)

// Defines values for AcceptHeader.
const (
	AcceptHeaderApplicationjson            AcceptHeader = "application/json"
	AcceptHeaderApplicationjsonDeletedOnly AcceptHeader = "application/json; deleted=only"
	AcceptHeaderApplicationjsonDeletedTrue AcceptHeader = "application/json; deleted=true"
)

// Defines values for ListSkusParamsAccept.
const (
	ListSkusParamsAcceptApplicationjson            ListSkusParamsAccept = "application/json"
	ListSkusParamsAcceptApplicationjsonDeletedOnly ListSkusParamsAccept = "application/json; deleted=only"
	ListSkusParamsAcceptApplicationjsonDeletedTrue ListSkusParamsAccept = "application/json; deleted=true"
)

// Defines values for ListInstancesParamsAccept.
const (
	Applicationjson            ListInstancesParamsAccept = "application/json"
	ApplicationjsonDeletedOnly ListInstancesParamsAccept = "application/json; deleted=only"
	ApplicationjsonDeletedTrue ListInstancesParamsAccept = "application/json; deleted=true"
)

// Error A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta    *map[string]interface{} `json:"meta,omitempty"`
	Sources *[]ErrorSource          `json:"sources,omitempty"`

	// Status The HTTP status type ([http://secapi.eu/errors/-rfc7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem
	// type.  It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`

	// Type The type of error, expressed as a URI.
	Type string `json:"type"`
}

// Error400 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error400 = Error

// Error401 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error401 = Error

// Error403 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error403 = Error

// Error404 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error404 = Error

// Error409 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error409 = Error

// Error412 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error412 = Error

// Error422 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error422 = Error

// Error500 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error500 = Error

// ErrorSource An object containing references to the source of the error.
type ErrorSource struct {
	// Parameter A string indicating which URI query parameter caused the error.
	Parameter string `json:"parameter"`

	// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
	Pointer string `json:"pointer"`
}

// Instance defines model for Instance.
type Instance struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for zonal resources with name, permission, modification, type, tenant, region, and zone information.
	Metadata *ZonalResourceMetadata `json:"metadata,omitempty"`

	// Spec Specification of the instance, including its SKU, network configuration, and storage options.
	Spec InstanceSpec `json:"spec"`

	// Status Current status of the instance.
	Status *InstanceStatus `json:"status,omitempty"`
}

// InstanceIterator Iterator for instances
type InstanceIterator struct {
	// Items List of instances
	Items []Instance `json:"items"`

	// Metadata Metadata for response objects.
	Metadata ResponseMetadata `json:"metadata"`
}

// InstanceSku defines model for InstanceSku.
type InstanceSku struct {
	// Annotations System-defined key/value pairs to annotate the resource.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions System-defined key/value pairs to document available extensions.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels System-defined key/value pairs to filter resources.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for SKU resources.
	Metadata *SkuResourceMetadata `json:"metadata,omitempty"`

	// Spec Specification of the instance SKU, including its capabilities and extensions.
	Spec *InstanceSkuSpec `json:"spec,omitempty"`
}

// InstanceSkuSpec Specification of the instance SKU, including its capabilities and extensions.
type InstanceSkuSpec struct {
	// Ram The amount of RAM (Random Access Memory) allocated to the instance SKU in gigabytes.
	// This value represents the total memory available to the instance.
	Ram int `json:"ram"`

	// VCPU The number of virtual CPUs (vCPUs) allocated to the instance SKU.
	// This value represents the number of cores visible to the operating system.
	// It does not specify the number of physical processors or hyper-threads available.
	VCPU int `json:"vCPU"`
}

// InstanceSpec Specification of the instance, including its SKU, network configuration, and storage options.
type InstanceSpec struct {
	// AdditionalNicRefs Additional NICs attached to this instance
	AdditionalNicRefs *[]Reference `json:"additionalNicRefs,omitempty"`

	// AntiAffinityGroup Anti-affinity group to which this instance belongs.
	// Instances in the same anti-affinity group are placed on different physical hosts.
	// The number of maximum instances in an anti-affinity group is provider-specific.
	AntiAffinityGroup *string `json:"antiAffinityGroup,omitempty"`

	// BootVolume Reference to the block storage used to store the boot volume of the instance.
	BootVolume  VolumeReference    `json:"bootVolume"`
	DataVolumes *[]VolumeReference `json:"dataVolumes,omitempty"`

	// PrimaryNicRef Reference to the primary NIC attached to this instance.
	PrimaryNicRef *Reference `json:"primaryNicRef,omitempty"`

	// SecurityGroupRef Reference to the security group associated with this instance.
	SecurityGroupRef *Reference `json:"securityGroupRef,omitempty"`

	// SkuRef Reference to the SKU of the instance.
	SkuRef Reference `json:"skuRef"`

	// SshKeys Provider-specific references to SSH keys used in cloud-init vendorData.
	// These references are used to inject SSH public keys during instance initialization
	// through cloud-init's vendor data configuration.
	SshKeys *[]string `json:"sshKeys,omitempty"`

	// UserData Cloud-init user data for instance initialization
	// Example cloud-init user configuration with SSH key:
	UserData *string `json:"userData,omitempty"`

	// Zone Reference to a specific zone within a region
	Zone Zone `json:"zone"`
}

// InstanceStatus Current status of the resource
type InstanceStatus = Status

// ModificationMetadata Base metadata for all resources with optional region references
type ModificationMetadata struct {
	// CreatedAt Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// LastModifiedAt Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedAt time.Time `json:"lastModifiedAt"`

	// ResourceVersion Incremented on every modification of the resource. Used for optimistic concurrency control.
	ResourceVersion int `json:"resourceVersion"`
}

// NameMetadata Metadata for resource names
type NameMetadata struct {
	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name string `json:"name"`
}

// PermissionMetadata Metadata for permission management
type PermissionMetadata struct {
	Provider string `json:"provider"`
	Resource string `json:"resource"`
	Verb     string `json:"verb"`
}

// Reference Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
// The reference can be used to refer to a resource in other resources.
type Reference struct {
	union json.RawMessage
}

// ReferenceObject A reference to a resource using an object. The object contains the
// same information as the ReferenceURN, but is represented as a structured object.
// The advantage of this representation is that it can be used to reference
// resources in different workspaces or regions without the need to specify
// the full URN.
type ReferenceObject struct {
	// Provider Provider of the resource. If not set, the provider is inferred from the context.
	Provider *string `json:"provider,omitempty"`

	// Region Region of the resource. If not set, the region is inferred from the context.
	Region *string `json:"region,omitempty"`

	// Resource Name and type of the resource. Must be in the format `<type>/<name>`.
	// The type is the resource type, and the name is the resource name.
	Resource string `json:"resource"`

	// Tenant Tenant of the resource. If not set, the tenant is inferred from the context.
	Tenant *string `json:"tenant,omitempty"`

	// Workspace Workspace of the resource. If not set, the workspace is inferred from the context.
	Workspace *string `json:"workspace,omitempty"`
}

// ReferenceURN A unique resource name used to reference this resource in other resources. The reference
// is represented as the full URN (Uniform Resource Name) name of the resource.
//
// ### Automatic Prefix Inference
//
// In most cases, the prefix of the URN can be automatically derived in the given context.
// To simplify usage, only the resource type and name might be specified as a reference
// using the `<type>/<name>` notation. The suffix can be made more specific by adding
// additional segments separated by slashes.
//
// The prefix is automatically inferred from the context. For example, if the resource is a
// block storage in the same workspace the reference can be specified as
// `block-storages/my-block-storage`. If the resource is a block storage in a different workspace, the
// reference can be specified as `workspaces/ws-1/block-storages/my-block-storage`.
//
// For automatic prefix inference, the following rules apply:
// - the version is inferred from the current resource version
// - the workspace is inferred from the current workspace
// - the region is inferred from the current region
// - the provider is inferred from the type and context of the usage
//
// The prefix inference is resolved on admission into the full URN format, which makes it
// mostly suitable for human use.
type ReferenceURN = string

// RegionalMetadata Metadata for regional resources
type RegionalMetadata struct {
	// Region Reference to the region where the resource is located
	Region string `json:"region"`

	// Workspace Workspace identifier
	Workspace *string `json:"workspace,omitempty"`
}

// ResourceState Current phase of the resource:
// - pending: not available, waiting for other resources
// - creating: not available, creation started
// - active: available for data layer usage
// - updating: available for data layer usage
// - deleting: maybe still available for data layer user, can fail any moment
// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
// - error: failed to fulfill the request; would be related to provider issue or customer related input.
type ResourceState string

// ResponseMetadata defines model for ResponseMetadata.
type ResponseMetadata struct {
	Provider string `json:"provider"`
	Resource string `json:"resource"`

	// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
	SkipToken *string `json:"skipToken,omitempty"`
	Verb      string  `json:"verb"`
}

// SkuIterator Iterator for skus
type SkuIterator struct {
	// Items List of skus
	Items []InstanceSku `json:"items"`

	// Metadata Metadata for response objects.
	Metadata ResponseMetadata `json:"metadata"`
}

// SkuResourceMetadata Metadata for resource names
type SkuResourceMetadata = NameMetadata

// Status Current status of the resource
type Status struct {
	Conditions []StatusCondition `json:"conditions"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *ResourceState `json:"state,omitempty"`
}

// StatusCondition StatusCondition describes the state of a resource at a certain point.
// Conditions are provider-specific and can represent different states depending on the
// resource type and provider implementation.
type StatusCondition struct {
	// LastTransitionAt LastTransitionAt is the last time the condition transitioned from one
	// status to another. This should be when the underlying condition changed.
	// If that is not known, then using the time when the API field changed is
	// acceptable.
	LastTransitionAt time.Time `json:"lastTransitionAt"`

	// Message A human-readable message indicating details about the transition.
	Message *string `json:"message,omitempty"`

	// Reason The reason for the condition's last transition in CamelCase.
	// The specific set of reason values is provider-specific and should be
	// documented by the provider.
	Reason *string `json:"reason,omitempty"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State ResourceState `json:"state"`

	// Type Type of condition. The condition type is provider-specific and should
	// reflect the specific states relevant to your resource.
	Type *string `json:"type,omitempty"`
}

// SystemResourceMetadata Metadata for user-defined resource properties
type SystemResourceMetadata struct {
	// Annotations System-defined key/value pairs to annotate the resource.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions System-defined key/value pairs to document available extensions.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels System-defined key/value pairs to filter resources.
	Labels *map[string]string `json:"labels,omitempty"`
}

// TenantMetadata Metadata for global resources with tenant constraints
type TenantMetadata struct {
	// Tenant Tenant identifier
	Tenant string `json:"tenant"`
}

// TypeMetadata Metadata for all resources with type information.
type TypeMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// Kind Type of the resource
	Kind TypeMetadataKind `json:"kind"`

	// Ref Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
	// The reference can be used to refer to a resource in other resources.
	Ref *Reference `json:"ref,omitempty"`
}

// TypeMetadataKind Type of the resource
type TypeMetadataKind string

// UserResourceMetadata Metadata for user-defined resource properties
type UserResourceMetadata struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`
}

// VolumeReference Represents a connection between a Block Storage and an a user of the block storage.
type VolumeReference struct {
	// DeviceRef Reference to the block storage used to store the volume.
	DeviceRef Reference `json:"deviceRef"`

	// Type The connection type depends on the type of device and type of block storage.
	Type *VolumeReferenceType `json:"type,omitempty"`
}

// VolumeReferenceType The connection type depends on the type of device and type of block storage.
type VolumeReferenceType string

// ZonalMetadata Metadata for zonal resources
type ZonalMetadata struct {
	// Zone Reference to a specific zone within a region
	Zone Zone `json:"zone"`
}

// ZonalResourceMetadata defines model for ZonalResourceMetadata.
type ZonalResourceMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// CreatedAt Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Kind Type of the resource
	Kind ZonalResourceMetadataKind `json:"kind"`

	// LastModifiedAt Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedAt time.Time `json:"lastModifiedAt"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name     string `json:"name"`
	Provider string `json:"provider"`

	// Ref Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
	// The reference can be used to refer to a resource in other resources.
	Ref *Reference `json:"ref,omitempty"`

	// Region Reference to the region where the resource is located
	Region   string `json:"region"`
	Resource string `json:"resource"`

	// ResourceVersion Incremented on every modification of the resource. Used for optimistic concurrency control.
	ResourceVersion int `json:"resourceVersion"`

	// Tenant Tenant identifier
	Tenant string `json:"tenant"`
	Verb   string `json:"verb"`

	// Workspace Workspace identifier
	Workspace *string `json:"workspace,omitempty"`

	// Zone Reference to a specific zone within a region
	Zone Zone `json:"zone"`
}

// ZonalResourceMetadataKind Type of the resource
type ZonalResourceMetadataKind string

// Zone Reference to a specific zone within a region
type Zone = string

// AcceptHeader defines model for acceptHeader.
type AcceptHeader string

// IfUnmodifiedSince defines model for ifUnmodifiedSince.
type IfUnmodifiedSince = int

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// ResourcePathParam defines model for resourcePathParam.
type ResourcePathParam = string

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// TenantPathParam defines model for tenantPathParam.
type TenantPathParam = string

// WorkspacePathParam defines model for workspacePathParam.
type WorkspacePathParam = string

// ListSkusParams defines parameters for ListSkus.
type ListSkusParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListSkusParamsAccept `json:"Accept,omitempty"`
}

// ListSkusParamsAccept defines parameters for ListSkus.
type ListSkusParamsAccept string

// ListInstancesParams defines parameters for ListInstances.
type ListInstancesParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListInstancesParamsAccept `json:"Accept,omitempty"`
}

// ListInstancesParamsAccept defines parameters for ListInstances.
type ListInstancesParamsAccept string

// DeleteInstanceParams defines parameters for DeleteInstance.
type DeleteInstanceParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateInstanceParams defines parameters for CreateOrUpdateInstance.
type CreateOrUpdateInstanceParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// RestartInstanceParams defines parameters for RestartInstance.
type RestartInstanceParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// StartInstanceParams defines parameters for StartInstance.
type StartInstanceParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// StopInstanceParams defines parameters for StopInstance.
type StopInstanceParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateInstanceJSONRequestBody defines body for CreateOrUpdateInstance for application/json ContentType.
type CreateOrUpdateInstanceJSONRequestBody = Instance

// AsReferenceURN returns the union data inside the Reference as a ReferenceURN
func (t Reference) AsReferenceURN() (ReferenceURN, error) {
	var body ReferenceURN
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReferenceURN overwrites any union data inside the Reference as the provided ReferenceURN
func (t *Reference) FromReferenceURN(v ReferenceURN) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReferenceURN performs a merge with any union data inside the Reference, using the provided ReferenceURN
func (t *Reference) MergeReferenceURN(v ReferenceURN) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReferenceObject returns the union data inside the Reference as a ReferenceObject
func (t Reference) AsReferenceObject() (ReferenceObject, error) {
	var body ReferenceObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReferenceObject overwrites any union data inside the Reference as the provided ReferenceObject
func (t *Reference) FromReferenceObject(v ReferenceObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReferenceObject performs a merge with any union data inside the Reference, using the provided ReferenceObject
func (t *Reference) MergeReferenceObject(v ReferenceObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Reference) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Reference) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListSkus request
	ListSkus(ctx context.Context, tenant TenantPathParam, params *ListSkusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSku request
	GetSku(ctx context.Context, tenant TenantPathParam, name ResourcePathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInstances request
	ListInstances(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, params *ListInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInstance request
	DeleteInstance(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *DeleteInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstance request
	GetInstance(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateInstanceWithBody request with any body
	CreateOrUpdateInstanceWithBody(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *CreateOrUpdateInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateInstance(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *CreateOrUpdateInstanceParams, body CreateOrUpdateInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartInstance request
	RestartInstance(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *RestartInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartInstance request
	StartInstance(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *StartInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopInstance request
	StopInstance(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *StopInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListSkus(ctx context.Context, tenant TenantPathParam, params *ListSkusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSkusRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSku(ctx context.Context, tenant TenantPathParam, name ResourcePathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSkuRequest(c.Server, tenant, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInstances(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, params *ListInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInstancesRequest(c.Server, tenant, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInstance(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *DeleteInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInstanceRequest(c.Server, tenant, workspace, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstance(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceRequest(c.Server, tenant, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateInstanceWithBody(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *CreateOrUpdateInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateInstanceRequestWithBody(c.Server, tenant, workspace, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateInstance(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *CreateOrUpdateInstanceParams, body CreateOrUpdateInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateInstanceRequest(c.Server, tenant, workspace, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartInstance(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *RestartInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartInstanceRequest(c.Server, tenant, workspace, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartInstance(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *StartInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartInstanceRequest(c.Server, tenant, workspace, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopInstance(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *StopInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopInstanceRequest(c.Server, tenant, workspace, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListSkusRequest generates requests for ListSkus
func NewListSkusRequest(server string, tenant TenantPathParam, params *ListSkusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/skus", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewGetSkuRequest generates requests for GetSku
func NewGetSkuRequest(server string, tenant TenantPathParam, name ResourcePathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/skus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInstancesRequest generates requests for ListInstances
func NewListInstancesRequest(server string, tenant TenantPathParam, workspace WorkspacePathParam, params *ListInstancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteInstanceRequest generates requests for DeleteInstance
func NewDeleteInstanceRequest(server string, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *DeleteInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewGetInstanceRequest generates requests for GetInstance
func NewGetInstanceRequest(server string, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateInstanceRequest calls the generic CreateOrUpdateInstance builder with application/json body
func NewCreateOrUpdateInstanceRequest(server string, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *CreateOrUpdateInstanceParams, body CreateOrUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateInstanceRequestWithBody(server, tenant, workspace, name, params, "application/json", bodyReader)
}

// NewCreateOrUpdateInstanceRequestWithBody generates requests for CreateOrUpdateInstance with any type of body
func NewCreateOrUpdateInstanceRequestWithBody(server string, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *CreateOrUpdateInstanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewRestartInstanceRequest generates requests for RestartInstance
func NewRestartInstanceRequest(server string, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *RestartInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances/%s/restart", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewStartInstanceRequest generates requests for StartInstance
func NewStartInstanceRequest(server string, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *StartInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances/%s/start", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewStopInstanceRequest generates requests for StopInstance
func NewStopInstanceRequest(server string, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *StopInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/instances/%s/stop", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListSkusWithResponse request
	ListSkusWithResponse(ctx context.Context, tenant TenantPathParam, params *ListSkusParams, reqEditors ...RequestEditorFn) (*ListSkusResponse, error)

	// GetSkuWithResponse request
	GetSkuWithResponse(ctx context.Context, tenant TenantPathParam, name ResourcePathParam, reqEditors ...RequestEditorFn) (*GetSkuResponse, error)

	// ListInstancesWithResponse request
	ListInstancesWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, params *ListInstancesParams, reqEditors ...RequestEditorFn) (*ListInstancesResponse, error)

	// DeleteInstanceWithResponse request
	DeleteInstanceWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *DeleteInstanceParams, reqEditors ...RequestEditorFn) (*DeleteInstanceResponse, error)

	// GetInstanceWithResponse request
	GetInstanceWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, reqEditors ...RequestEditorFn) (*GetInstanceResponse, error)

	// CreateOrUpdateInstanceWithBodyWithResponse request with any body
	CreateOrUpdateInstanceWithBodyWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *CreateOrUpdateInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateInstanceResponse, error)

	CreateOrUpdateInstanceWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *CreateOrUpdateInstanceParams, body CreateOrUpdateInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateInstanceResponse, error)

	// RestartInstanceWithResponse request
	RestartInstanceWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *RestartInstanceParams, reqEditors ...RequestEditorFn) (*RestartInstanceResponse, error)

	// StartInstanceWithResponse request
	StartInstanceWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *StartInstanceParams, reqEditors ...RequestEditorFn) (*StartInstanceResponse, error)

	// StopInstanceWithResponse request
	StopInstanceWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *StopInstanceParams, reqEditors ...RequestEditorFn) (*StopInstanceResponse, error)
}

type ListSkusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SkuIterator
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r ListSkusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSkusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSkuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstanceSku
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetSkuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSkuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstanceIterator
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r ListInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON409      *Error409
	JSON412      *Error412
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Instance
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Instance
	JSON201      *Instance
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON409      *Error409
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON409      *Error409
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r RestartInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON409      *Error409
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r StartInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON409      *Error409
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r StopInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListSkusWithResponse request returning *ListSkusResponse
func (c *ClientWithResponses) ListSkusWithResponse(ctx context.Context, tenant TenantPathParam, params *ListSkusParams, reqEditors ...RequestEditorFn) (*ListSkusResponse, error) {
	rsp, err := c.ListSkus(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSkusResponse(rsp)
}

// GetSkuWithResponse request returning *GetSkuResponse
func (c *ClientWithResponses) GetSkuWithResponse(ctx context.Context, tenant TenantPathParam, name ResourcePathParam, reqEditors ...RequestEditorFn) (*GetSkuResponse, error) {
	rsp, err := c.GetSku(ctx, tenant, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSkuResponse(rsp)
}

// ListInstancesWithResponse request returning *ListInstancesResponse
func (c *ClientWithResponses) ListInstancesWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, params *ListInstancesParams, reqEditors ...RequestEditorFn) (*ListInstancesResponse, error) {
	rsp, err := c.ListInstances(ctx, tenant, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInstancesResponse(rsp)
}

// DeleteInstanceWithResponse request returning *DeleteInstanceResponse
func (c *ClientWithResponses) DeleteInstanceWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *DeleteInstanceParams, reqEditors ...RequestEditorFn) (*DeleteInstanceResponse, error) {
	rsp, err := c.DeleteInstance(ctx, tenant, workspace, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInstanceResponse(rsp)
}

// GetInstanceWithResponse request returning *GetInstanceResponse
func (c *ClientWithResponses) GetInstanceWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, reqEditors ...RequestEditorFn) (*GetInstanceResponse, error) {
	rsp, err := c.GetInstance(ctx, tenant, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceResponse(rsp)
}

// CreateOrUpdateInstanceWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateInstanceResponse
func (c *ClientWithResponses) CreateOrUpdateInstanceWithBodyWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *CreateOrUpdateInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateInstanceResponse, error) {
	rsp, err := c.CreateOrUpdateInstanceWithBody(ctx, tenant, workspace, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateInstanceWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *CreateOrUpdateInstanceParams, body CreateOrUpdateInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateInstanceResponse, error) {
	rsp, err := c.CreateOrUpdateInstance(ctx, tenant, workspace, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateInstanceResponse(rsp)
}

// RestartInstanceWithResponse request returning *RestartInstanceResponse
func (c *ClientWithResponses) RestartInstanceWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *RestartInstanceParams, reqEditors ...RequestEditorFn) (*RestartInstanceResponse, error) {
	rsp, err := c.RestartInstance(ctx, tenant, workspace, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartInstanceResponse(rsp)
}

// StartInstanceWithResponse request returning *StartInstanceResponse
func (c *ClientWithResponses) StartInstanceWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *StartInstanceParams, reqEditors ...RequestEditorFn) (*StartInstanceResponse, error) {
	rsp, err := c.StartInstance(ctx, tenant, workspace, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartInstanceResponse(rsp)
}

// StopInstanceWithResponse request returning *StopInstanceResponse
func (c *ClientWithResponses) StopInstanceWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params *StopInstanceParams, reqEditors ...RequestEditorFn) (*StopInstanceResponse, error) {
	rsp, err := c.StopInstance(ctx, tenant, workspace, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopInstanceResponse(rsp)
}

// ParseListSkusResponse parses an HTTP response from a ListSkusWithResponse call
func ParseListSkusResponse(rsp *http.Response) (*ListSkusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSkusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SkuIterator
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSkuResponse parses an HTTP response from a GetSkuWithResponse call
func ParseGetSkuResponse(rsp *http.Response) (*GetSkuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSkuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstanceSku
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListInstancesResponse parses an HTTP response from a ListInstancesWithResponse call
func ParseListInstancesResponse(rsp *http.Response) (*ListInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstanceIterator
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInstanceResponse parses an HTTP response from a DeleteInstanceWithResponse call
func ParseDeleteInstanceResponse(rsp *http.Response) (*DeleteInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInstanceResponse parses an HTTP response from a GetInstanceWithResponse call
func ParseGetInstanceResponse(rsp *http.Response) (*GetInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Instance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateInstanceResponse parses an HTTP response from a CreateOrUpdateInstanceWithResponse call
func ParseCreateOrUpdateInstanceResponse(rsp *http.Response) (*CreateOrUpdateInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Instance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Instance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRestartInstanceResponse parses an HTTP response from a RestartInstanceWithResponse call
func ParseRestartInstanceResponse(rsp *http.Response) (*RestartInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestartInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartInstanceResponse parses an HTTP response from a StartInstanceWithResponse call
func ParseStartInstanceResponse(rsp *http.Response) (*StartInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStopInstanceResponse parses an HTTP response from a StopInstanceWithResponse call
func ParseStopInstanceResponse(rsp *http.Response) (*StopInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List skus
	// (GET /v1/tenants/{tenant}/skus)
	ListSkus(w http.ResponseWriter, r *http.Request, tenant TenantPathParam, params ListSkusParams)
	// Get sku
	// (GET /v1/tenants/{tenant}/skus/{name})
	GetSku(w http.ResponseWriter, r *http.Request, tenant TenantPathParam, name ResourcePathParam)
	// List instances
	// (GET /v1/tenants/{tenant}/workspaces/{workspace}/instances)
	ListInstances(w http.ResponseWriter, r *http.Request, tenant TenantPathParam, workspace WorkspacePathParam, params ListInstancesParams)
	// Delete instance
	// (DELETE /v1/tenants/{tenant}/workspaces/{workspace}/instances/{name})
	DeleteInstance(w http.ResponseWriter, r *http.Request, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params DeleteInstanceParams)
	// Get instance
	// (GET /v1/tenants/{tenant}/workspaces/{workspace}/instances/{name})
	GetInstance(w http.ResponseWriter, r *http.Request, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam)
	// Create or update instance
	// (PUT /v1/tenants/{tenant}/workspaces/{workspace}/instances/{name})
	CreateOrUpdateInstance(w http.ResponseWriter, r *http.Request, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params CreateOrUpdateInstanceParams)
	// restart instance
	// (POST /v1/tenants/{tenant}/workspaces/{workspace}/instances/{name}/restart)
	RestartInstance(w http.ResponseWriter, r *http.Request, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params RestartInstanceParams)
	// start instance
	// (POST /v1/tenants/{tenant}/workspaces/{workspace}/instances/{name}/start)
	StartInstance(w http.ResponseWriter, r *http.Request, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params StartInstanceParams)
	// stop instance
	// (POST /v1/tenants/{tenant}/workspaces/{workspace}/instances/{name}/stop)
	StopInstance(w http.ResponseWriter, r *http.Request, tenant TenantPathParam, workspace WorkspacePathParam, name ResourcePathParam, params StopInstanceParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListSkus operation middleware
func (siw *ServerInterfaceWrapper) ListSkus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant TenantPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSkusParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListSkusParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSkus(w, r, tenant, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSku operation middleware
func (siw *ServerInterfaceWrapper) GetSku(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant TenantPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourcePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSku(w, r, tenant, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListInstances operation middleware
func (siw *ServerInterfaceWrapper) ListInstances(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant TenantPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspacePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListInstancesParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListInstancesParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListInstances(w, r, tenant, workspace, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteInstance operation middleware
func (siw *ServerInterfaceWrapper) DeleteInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant TenantPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspacePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourcePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteInstanceParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteInstance(w, r, tenant, workspace, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetInstance operation middleware
func (siw *ServerInterfaceWrapper) GetInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant TenantPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspacePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourcePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInstance(w, r, tenant, workspace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateInstance operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant TenantPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspacePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourcePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateInstanceParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateInstance(w, r, tenant, workspace, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RestartInstance operation middleware
func (siw *ServerInterfaceWrapper) RestartInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant TenantPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspacePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourcePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params RestartInstanceParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RestartInstance(w, r, tenant, workspace, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// StartInstance operation middleware
func (siw *ServerInterfaceWrapper) StartInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant TenantPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspacePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourcePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params StartInstanceParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StartInstance(w, r, tenant, workspace, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// StopInstance operation middleware
func (siw *ServerInterfaceWrapper) StopInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant TenantPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspacePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourcePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params StopInstanceParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StopInstance(w, r, tenant, workspace, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{tenant}/skus", wrapper.ListSkus)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{tenant}/skus/{name}", wrapper.GetSku)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{tenant}/workspaces/{workspace}/instances", wrapper.ListInstances)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{tenant}/workspaces/{workspace}/instances/{name}", wrapper.DeleteInstance)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{tenant}/workspaces/{workspace}/instances/{name}", wrapper.GetInstance)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{tenant}/workspaces/{workspace}/instances/{name}", wrapper.CreateOrUpdateInstance)
	m.HandleFunc("POST "+options.BaseURL+"/v1/tenants/{tenant}/workspaces/{workspace}/instances/{name}/restart", wrapper.RestartInstance)
	m.HandleFunc("POST "+options.BaseURL+"/v1/tenants/{tenant}/workspaces/{workspace}/instances/{name}/start", wrapper.StartInstance)
	m.HandleFunc("POST "+options.BaseURL+"/v1/tenants/{tenant}/workspaces/{workspace}/instances/{name}/stop", wrapper.StopInstance)

	return m
}
