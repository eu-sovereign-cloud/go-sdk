// Package schema provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package schema

// Defines values for LoadBalancerHealthCheckType.
const (
	LoadBalancerHealthCheckConnect LoadBalancerHealthCheckType = "connect"
)

// Defines values for LoadBalancerTargetAlgorithm.
const (
	LoadBalancerAlgorithmRoundRobin LoadBalancerTargetAlgorithm = "round-robin"
)

// Defines values for LoadBalancerTargetProxyProtocol.
const (
	LoadBalancerProxyProtocolNone LoadBalancerTargetProxyProtocol = "none"
	LoadBalancerProxyProtocolV2   LoadBalancerTargetProxyProtocol = "v2"
)

// Defines values for NetworkLoadBalancerFrontendProtocol.
const (
	LoadBalancerProtocolBoth NetworkLoadBalancerFrontendProtocol = "both"
	LoadBalancerProtocolTCP  NetworkLoadBalancerFrontendProtocol = "tcp"
	LoadBalancerProtocolUDP  NetworkLoadBalancerFrontendProtocol = "udp"
)

// LoadBalancerHealthCheck Optional port health check. It probes the port with protocol.
type LoadBalancerHealthCheck struct {
	// Interval health check interval in seconds. It means after how many seconds it will take a new check
	Interval int `json:"interval"`

	// Retry health check retry number after considered unhealthy a backend instance
	Retry int `json:"retry"`

	// Timeout health check in seconds. It means after how many seconds the attempt will be considered unhealthy
	Timeout int `json:"timeout"`

	// Type Specifies the type of health check. A `connect` health check attempts
	// to establish a connection to the specified port to determine its health.
	Type *LoadBalancerHealthCheckType `json:"type,omitempty"`
}

// LoadBalancerHealthCheckType Specifies the type of health check. A `connect` health check attempts
// to establish a connection to the specified port to determine its health.
type LoadBalancerHealthCheckType string

// LoadBalancerTarget The target of the LoadBalancer. It can be a set of instances nics. The port can be different from the frontend port, if omitted it will be the same. If no health check is specified, the LoadBalancer will not check the health of the backend instances.
type LoadBalancerTarget struct {
	// Algorithm LoadBalancer algorithm to take a backend instance
	Algorithm *LoadBalancerTargetAlgorithm `json:"algorithm,omitempty"`

	// HealthCheck Optional port health check. It probes the port with protocol.
	HealthCheck *LoadBalancerHealthCheck `json:"healthCheck,omitempty"`

	// Members Nic reference to the members as part of the LoadBalancerTarget
	Members []Reference `json:"members"`

	// Port A valid network port number.
	// The port number is a 16-bit unsigned integer ranging from 1 to 65535.
	Port *Port `json:"port,omitempty"`

	// ProxyProtocol Specifies the proxy protocol version. The proxy protocol is used to
	// pass client connection information to the backend instances.
	// If not specified, the default is `none`.
	ProxyProtocol *LoadBalancerTargetProxyProtocol `json:"proxyProtocol,omitempty"`
}

// LoadBalancerTargetAlgorithm LoadBalancer algorithm to take a backend instance
type LoadBalancerTargetAlgorithm string

// LoadBalancerTargetProxyProtocol Specifies the proxy protocol version. The proxy protocol is used to
// pass client connection information to the backend instances.
// If not specified, the default is `none`.
type LoadBalancerTargetProxyProtocol string

// NetworkLoadBalancer defines model for NetworkLoadBalancer.
type NetworkLoadBalancer struct {
	Annotations *interface{} `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions Extensions `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels Labels `json:"labels,omitempty"`

	// Metadata Metadata for regional resources with name, permission, modification, type, tenant and workspace and region information.
	Metadata *RegionalWorkspaceResourceMetadata `json:"metadata,omitempty"`

	// Spec Defines the specification for a Network Load Balancer. A Load Balancer can have multiple
	// frontends, where each frontend may target multiple backend instances. Frontend ports and
	// protocols must be unique to ensure proper routing. The NIC associated with the proxy
	// determines whether the Load Balancer is internal or external.
	Spec NetworkLoadBalancerSpec `json:"spec"`

	// Status Represents the status of the Network Load Balancer. It provides information about
	// the health of the backend instances and their readiness to handle traffic.
	Status *NetworkLoadBalancerStatus `json:"status,omitempty"`
}

// NetworkLoadBalancerFrontend Represents the frontend configuration of the LoadBalancer. Each frontend
// can have multiple targets, but the combination of port and protocol must
// be unique to ensure proper routing.
type NetworkLoadBalancerFrontend struct {
	// Port A valid network port number.
	// The port number is a 16-bit unsigned integer ranging from 1 to 65535.
	Port Port `json:"port"`

	// Protocol Frontend Protocol to which the load balancer will be listening on
	Protocol NetworkLoadBalancerFrontendProtocol `json:"protocol"`

	// Target The target of the LoadBalancer. It can be a set of instances nics. The port can be different from the frontend port, if omitted it will be the same. If no health check is specified, the LoadBalancer will not check the health of the backend instances.
	Target LoadBalancerTarget `json:"target"`
}

// NetworkLoadBalancerFrontendProtocol Frontend Protocol to which the load balancer will be listening on
type NetworkLoadBalancerFrontendProtocol string

// NetworkLoadBalancerSpec Defines the specification for a Network Load Balancer. A Load Balancer can have multiple
// frontends, where each frontend may target multiple backend instances. Frontend ports and
// protocols must be unique to ensure proper routing. The NIC associated with the proxy
// determines whether the Load Balancer is internal or external.
type NetworkLoadBalancerSpec struct {
	Frontends []NetworkLoadBalancerFrontend `json:"frontends"`

	// NicRef Reference to the NIC attached to the load balancer.
	NicRef Reference `json:"nicRef"`

	// SecurityGroupRef Reference to the security group associated with this instance.
	SecurityGroupRef *Reference `json:"securityGroupRef,omitempty"`
}

// NetworkLoadBalancerStatus defines model for NetworkLoadBalancerStatus.
type NetworkLoadBalancerStatus struct {
	Conditions []StatusCondition `json:"conditions"`

	// HealthyMembers List of healthy members
	HealthyMembers *[]Reference `json:"healthyMembers,omitempty"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *ResourceState `json:"state,omitempty"`
}
