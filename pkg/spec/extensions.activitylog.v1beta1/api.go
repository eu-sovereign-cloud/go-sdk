//go:build go1.22

// Package activitylog provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package activitylog

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for IPVersion.
const (
	IPv4 IPVersion = "IPv4"
	IPv6 IPVersion = "IPv6"
)

// Defines values for LoadBalancerHealthCheckType.
const (
	Connect LoadBalancerHealthCheckType = "connect"
)

// Defines values for LoadBalancerTargetAlgorithm.
const (
	RoundRobin LoadBalancerTargetAlgorithm = "round-robin"
)

// Defines values for LoadBalancerTargetProxyProtocol.
const (
	None LoadBalancerTargetProxyProtocol = "none"
	V2   LoadBalancerTargetProxyProtocol = "v2"
)

// Defines values for NetworkLoadBalancerFrontendProtocol.
const (
	NetworkLoadBalancerFrontendProtocolBoth NetworkLoadBalancerFrontendProtocol = "both"
	NetworkLoadBalancerFrontendProtocolTcp  NetworkLoadBalancerFrontendProtocol = "tcp"
	NetworkLoadBalancerFrontendProtocolUdp  NetworkLoadBalancerFrontendProtocol = "udp"
)

// Defines values for RegionalWorkspaceResourceMetadataKind.
const (
	RegionalWorkspaceResourceMetadataKindActivityLog          RegionalWorkspaceResourceMetadataKind = "activity-log"
	RegionalWorkspaceResourceMetadataKindBlockStorage         RegionalWorkspaceResourceMetadataKind = "block-storage"
	RegionalWorkspaceResourceMetadataKindImage                RegionalWorkspaceResourceMetadataKind = "image"
	RegionalWorkspaceResourceMetadataKindInstance             RegionalWorkspaceResourceMetadataKind = "instance"
	RegionalWorkspaceResourceMetadataKindInstanceSku          RegionalWorkspaceResourceMetadataKind = "instance-sku"
	RegionalWorkspaceResourceMetadataKindInternetGateway      RegionalWorkspaceResourceMetadataKind = "internet-gateway"
	RegionalWorkspaceResourceMetadataKindNetwork              RegionalWorkspaceResourceMetadataKind = "network"
	RegionalWorkspaceResourceMetadataKindNetworkLoadBalancer  RegionalWorkspaceResourceMetadataKind = "network-load-balancer"
	RegionalWorkspaceResourceMetadataKindNetworkSku           RegionalWorkspaceResourceMetadataKind = "network-sku"
	RegionalWorkspaceResourceMetadataKindNic                  RegionalWorkspaceResourceMetadataKind = "nic"
	RegionalWorkspaceResourceMetadataKindObjectStorageAccount RegionalWorkspaceResourceMetadataKind = "object-storage-account"
	RegionalWorkspaceResourceMetadataKindPublicIp             RegionalWorkspaceResourceMetadataKind = "public-ip"
	RegionalWorkspaceResourceMetadataKindRegion               RegionalWorkspaceResourceMetadataKind = "region"
	RegionalWorkspaceResourceMetadataKindRole                 RegionalWorkspaceResourceMetadataKind = "role"
	RegionalWorkspaceResourceMetadataKindRoleAssignment       RegionalWorkspaceResourceMetadataKind = "role-assignment"
	RegionalWorkspaceResourceMetadataKindRoutingTable         RegionalWorkspaceResourceMetadataKind = "routing-table"
	RegionalWorkspaceResourceMetadataKindSecurityGroup        RegionalWorkspaceResourceMetadataKind = "security-group"
	RegionalWorkspaceResourceMetadataKindSecurityGroupRule    RegionalWorkspaceResourceMetadataKind = "security-group-rule"
	RegionalWorkspaceResourceMetadataKindStorageSku           RegionalWorkspaceResourceMetadataKind = "storage-sku"
	RegionalWorkspaceResourceMetadataKindSubnet               RegionalWorkspaceResourceMetadataKind = "subnet"
	RegionalWorkspaceResourceMetadataKindWorkspace            RegionalWorkspaceResourceMetadataKind = "workspace"
)

// Defines values for SecurityGroupRuleSpecDirection.
const (
	Egress  SecurityGroupRuleSpecDirection = "egress"
	Ingress SecurityGroupRuleSpecDirection = "ingress"
)

// Defines values for SecurityGroupRuleSpecProtocol.
const (
	SecurityGroupRuleSpecProtocolIcmp   SecurityGroupRuleSpecProtocol = "icmp"
	SecurityGroupRuleSpecProtocolTcp    SecurityGroupRuleSpecProtocol = "tcp"
	SecurityGroupRuleSpecProtocolTcpUdp SecurityGroupRuleSpecProtocol = "tcp+udp"
	SecurityGroupRuleSpecProtocolUdp    SecurityGroupRuleSpecProtocol = "udp"
)

// Defines values for StorageSkuSpecType.
const (
	LocalDurable   StorageSkuSpecType = "local-durable"
	LocalEphemeral StorageSkuSpecType = "local-ephemeral"
	RemoteDurable  StorageSkuSpecType = "remote-durable"
)

// Defines values for TypeMetadataKind.
const (
	TypeMetadataKindActivityLog          TypeMetadataKind = "activity-log"
	TypeMetadataKindBlockStorage         TypeMetadataKind = "block-storage"
	TypeMetadataKindImage                TypeMetadataKind = "image"
	TypeMetadataKindInstance             TypeMetadataKind = "instance"
	TypeMetadataKindInstanceSku          TypeMetadataKind = "instance-sku"
	TypeMetadataKindInternetGateway      TypeMetadataKind = "internet-gateway"
	TypeMetadataKindNetwork              TypeMetadataKind = "network"
	TypeMetadataKindNetworkLoadBalancer  TypeMetadataKind = "network-load-balancer"
	TypeMetadataKindNetworkSku           TypeMetadataKind = "network-sku"
	TypeMetadataKindNic                  TypeMetadataKind = "nic"
	TypeMetadataKindObjectStorageAccount TypeMetadataKind = "object-storage-account"
	TypeMetadataKindPublicIp             TypeMetadataKind = "public-ip"
	TypeMetadataKindRegion               TypeMetadataKind = "region"
	TypeMetadataKindRole                 TypeMetadataKind = "role"
	TypeMetadataKindRoleAssignment       TypeMetadataKind = "role-assignment"
	TypeMetadataKindRoutingTable         TypeMetadataKind = "routing-table"
	TypeMetadataKindSecurityGroup        TypeMetadataKind = "security-group"
	TypeMetadataKindSecurityGroupRule    TypeMetadataKind = "security-group-rule"
	TypeMetadataKindStorageSku           TypeMetadataKind = "storage-sku"
	TypeMetadataKindSubnet               TypeMetadataKind = "subnet"
	TypeMetadataKindWorkspace            TypeMetadataKind = "workspace"
)

// Defines values for VolumeReferenceType.
const (
	Virtio VolumeReferenceType = "virtio"
)

// Defines values for AcceptHeader.
const (
	AcceptHeaderApplicationjson            AcceptHeader = "application/json"
	AcceptHeaderApplicationjsonDeletedOnly AcceptHeader = "application/json; deleted=only"
	AcceptHeaderApplicationjsonDeletedTrue AcceptHeader = "application/json; deleted=true"
)

// Defines values for ListActivityLogsParamsAccept.
const (
	ListActivityLogsParamsAcceptApplicationjson            ListActivityLogsParamsAccept = "application/json"
	ListActivityLogsParamsAcceptApplicationjsonDeletedOnly ListActivityLogsParamsAccept = "application/json; deleted=only"
	ListActivityLogsParamsAcceptApplicationjsonDeletedTrue ListActivityLogsParamsAccept = "application/json; deleted=true"
)

// ActivityLog Activity log resource
type ActivityLog struct {
	// Metadata Metadata for regional resources with name, permission, modification, type, tenant and workspace and region information.
	Metadata *RegionalWorkspaceResourceMetadata `json:"metadata,omitempty"`

	// Spec Activity log specification
	Spec ActivityLogSpec `json:"spec"`
}

// ActivityLogIterator Iterator for activity logs
type ActivityLogIterator struct {
	// Items List of activity logs
	Items []ActivityLog `json:"items"`

	// Metadata Metadata for response objects.
	Metadata ResponseMetadata `json:"metadata"`
}

// ActivityLogSpec Activity log specification
type ActivityLogSpec struct {
	// Request Request object
	Request *RequestObject `json:"request,omitempty"`

	// Response Response object
	Response *ResponseObject `json:"response,omitempty"`

	// Subject User-JWT executing this query
	Subject *string `json:"subject,omitempty"`
}

// BlockStorageSpec References the SKU used for this block.
// If a reference to the source image is used as the base for creating this block storage.
type BlockStorageSpec struct {
	// SizeGB Size of the block storage in GB.
	SizeGB int `json:"sizeGB"`

	// SkuRef Reference to the SKU of the block storage.
	SkuRef Reference `json:"skuRef"`

	// SourceImageRef Reference to the source image used as the base for creating the block storage.
	SourceImageRef *Reference `json:"sourceImageRef,omitempty"`
}

// Error A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta    *map[string]interface{} `json:"meta,omitempty"`
	Sources *[]ErrorSource          `json:"sources,omitempty"`

	// Status The HTTP status type ([http://secapi.eu/errors/-rfc7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem
	// type.  It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`

	// Type The type of error, expressed as a URI.
	Type string `json:"type"`
}

// Error400 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error400 = Error

// Error401 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error401 = Error

// Error403 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error403 = Error

// Error500 A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error500 = Error

// ErrorSource An object containing references to the source of the error.
type ErrorSource struct {
	// Parameter A string indicating which URI query parameter caused the error.
	Parameter string `json:"parameter"`

	// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
	Pointer string `json:"pointer"`
}

// IPVersion IP version of the address
type IPVersion string

// IcmpConfig ICMP specific rule configuration
type IcmpConfig struct {
	// Code ICMP code
	Code int `json:"code"`

	// Type ICMP type
	Type int `json:"type"`
}

// InstanceSkuSpec Specification of the instance SKU, including its capabilities and extensions.
type InstanceSkuSpec struct {
	// Ram The amount of RAM (Random Access Memory) allocated to the instance SKU in gigabytes.
	// This value represents the total memory available to the instance.
	Ram int `json:"ram"`

	// VCPU The number of virtual CPUs (vCPUs) allocated to the instance SKU.
	// This value represents the number of cores visible to the operating system.
	// It does not specify the number of physical processors or hyper-threads available.
	VCPU int `json:"vCPU"`
}

// InstanceSpec Specification of the instance, including its SKU, network configuration, and storage options.
type InstanceSpec struct {
	// AdditionalNicRefs Additional NICs attached to this instance
	AdditionalNicRefs *[]Reference `json:"additionalNicRefs,omitempty"`

	// AntiAffinityGroup Anti-affinity group to which this instance belongs.
	// Instances in the same anti-affinity group are placed on different physical hosts.
	// The number of maximum instances in an anti-affinity group is provider-specific.
	AntiAffinityGroup *string `json:"antiAffinityGroup,omitempty"`

	// BootVolume Reference to the block storage used to store the boot volume of the instance.
	BootVolume  VolumeReference    `json:"bootVolume"`
	DataVolumes *[]VolumeReference `json:"dataVolumes,omitempty"`

	// PrimaryNicRef Reference to the primary NIC attached to this instance.
	PrimaryNicRef *Reference `json:"primaryNicRef,omitempty"`

	// SecurityGroupRef Reference to the security group associated with this instance.
	SecurityGroupRef *Reference `json:"securityGroupRef,omitempty"`

	// SkuRef Reference to the SKU of the instance.
	SkuRef Reference `json:"skuRef"`

	// SshKeys Provider-specific references to SSH keys used in cloud-init vendorData.
	// These references are used to inject SSH public keys during instance initialization
	// through cloud-init's vendor data configuration.
	SshKeys *[]string `json:"sshKeys,omitempty"`

	// UserData Cloud-init user data for instance initialization
	// Example cloud-init user configuration with SSH key:
	UserData *string `json:"userData,omitempty"`

	// Zone Reference to a specific zone within a region
	Zone Zone `json:"zone"`
}

// LoadBalancerHealthCheck Optional port health check. It probes the port with protocol.
type LoadBalancerHealthCheck struct {
	// Interval health check interval in seconds. It means after how many seconds it will take a new check
	Interval int `json:"interval"`

	// Retry health check retry number after considered unhealthy a backend instance
	Retry int `json:"retry"`

	// Timeout health check in seconds. It means after how many seconds the attempt will be considered unhealthy
	Timeout int `json:"timeout"`

	// Type Specifies the type of health check. A `connect` health check attempts
	// to establish a connection to the specified port to determine its health.
	Type *LoadBalancerHealthCheckType `json:"type,omitempty"`
}

// LoadBalancerHealthCheckType Specifies the type of health check. A `connect` health check attempts
// to establish a connection to the specified port to determine its health.
type LoadBalancerHealthCheckType string

// LoadBalancerTarget The target of the LoadBalancer. It can be a set of instances nics. The port can be different from the frontend port, if omitted it will be the same. If no health check is specified, the LoadBalancer will not check the health of the backend instances.
type LoadBalancerTarget struct {
	// Algorithm LoadBalancer algorithm to take a backend instance
	Algorithm *LoadBalancerTargetAlgorithm `json:"algorithm,omitempty"`

	// HealthCheck Optional port health check. It probes the port with protocol.
	HealthCheck *LoadBalancerHealthCheck `json:"healthCheck,omitempty"`

	// Members Nic reference to the members as part of the LoadBalancerTarget
	Members []Reference `json:"members"`

	// Port A valid network port number.
	// The port number is a 16-bit unsigned integer ranging from 1 to 65535.
	Port *Port `json:"port,omitempty"`

	// ProxyProtocol Specifies the proxy protocol version. The proxy protocol is used to
	// pass client connection information to the backend instances.
	// If not specified, the default is `none`.
	ProxyProtocol *LoadBalancerTargetProxyProtocol `json:"proxyProtocol,omitempty"`
}

// LoadBalancerTargetAlgorithm LoadBalancer algorithm to take a backend instance
type LoadBalancerTargetAlgorithm string

// LoadBalancerTargetProxyProtocol Specifies the proxy protocol version. The proxy protocol is used to
// pass client connection information to the backend instances.
// If not specified, the default is `none`.
type LoadBalancerTargetProxyProtocol string

// ModificationMetadata Base metadata for all resources with optional region references
type ModificationMetadata struct {
	// CreatedAt Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// LastModifiedAt Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedAt time.Time `json:"lastModifiedAt"`

	// ResourceVersion Incremented on every modification of the resource. Used for optimistic concurrency control.
	ResourceVersion int `json:"resourceVersion"`
}

// NameMetadata Metadata for resource names
type NameMetadata struct {
	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name string `json:"name"`
}

// NetworkLoadBalancerFrontend Represents the frontend configuration of the LoadBalancer. Each frontend
// can have multiple targets, but the combination of port and protocol must
// be unique to ensure proper routing.
type NetworkLoadBalancerFrontend struct {
	// Port A valid network port number.
	// The port number is a 16-bit unsigned integer ranging from 1 to 65535.
	Port Port `json:"port"`

	// Protocol Frontend Protocol to which the load balancer will be listening on
	Protocol NetworkLoadBalancerFrontendProtocol `json:"protocol"`

	// Target The target of the LoadBalancer. It can be a set of instances nics. The port can be different from the frontend port, if omitted it will be the same. If no health check is specified, the LoadBalancer will not check the health of the backend instances.
	Target LoadBalancerTarget `json:"target"`
}

// NetworkLoadBalancerFrontendProtocol Frontend Protocol to which the load balancer will be listening on
type NetworkLoadBalancerFrontendProtocol string

// NetworkLoadBalancerSpec Defines the specification for a Network Load Balancer. A Load Balancer can have multiple
// frontends, where each frontend may target multiple backend instances. Frontend ports and
// protocols must be unique to ensure proper routing. The NIC associated with the proxy
// determines whether the Load Balancer is internal or external.
type NetworkLoadBalancerSpec struct {
	Frontends []NetworkLoadBalancerFrontend `json:"frontends"`

	// NicRef Reference to the NIC attached to the load balancer.
	NicRef Reference `json:"nicRef"`
}

// NetworkSkuSpec Specification of the network SKU, including its bandwidth and packets per second.
type NetworkSkuSpec struct {
	// Bandwidth The bandwidth in Mbps (Megabits per second).
	Bandwidth int `json:"bandwidth"`

	// Packets The number of packets per second (PPS) that the network SKU can handle.
	Packets int `json:"packets"`
}

// NetworkSpec A Network represents a virtual network that can be used to isolate resources.
// Key network concepts:
//
// * Defines a range of IP addresses for compute resources (e.g. instances)
// * Enables network segmentation and isolation
// * Provides common performance configuration across the network using a SKU
//
// The `cidr` is the base CIDR block for the network. Additional CIDR blocks can be
// added to the network using the `additionalCidrs` field. The `additionalCidrs` can
// be changed after the network is created in case they are not used. The main CIDR
// block cannot be changed after the network is created. All cidrs must be non-overlapping.
// The cidrs have to be part of the RFC 1918 address space in case of IPv4 and or RFC 4193.
//
// In case the system should automatically assign IP addresses to the network cidrs
// only the network prefix is required. E.g. to request a /16 IPv4 CIDR block the
// CIDR block would be `0.0.0.0/16` and for a /56 IPv6 CIDR block the CIDR block would
// be `::/56`. Most CSP will not allow to use a different IPv6 prefix length than /56.
type NetworkSpec struct {
	AdditionalCidrs *[]Cidr `json:"additionalCidrs,omitempty"`

	// Cidr Combined IPv4 and IPv6 CIDR block for a subnet. Depending on the network
	// configuration, either the IPv4 or IPv6 range can be omitted. So the following
	// combinations are possible:
	//
	// * IPv4 only
	// * IPv6 only
	// * IPv4 and IPv6 (Dual Stack)
	Cidr Cidr `json:"cidr"`

	// RouteTableRef Reference to the route table used by default for all Subnets.
	RouteTableRef Reference `json:"routeTableRef"`

	// SkuRef Reference to the SKU used by default for all NIC in this Network.
	// Can be overridden by the NIC.
	SkuRef Reference `json:"skuRef"`
}

// NicIp IP address for the NIC. The IP is either IPv4 or IPv6. The IP
// can be `0.0.0.0` or `::` to indicate that the IP needs to be assigned
// automatically. The IP can also be a specific IP address.
// If not provided, the mutate admission controller will populate this value using the default values for ipv4 and ipv6.
type NicIp = string

// NicSpec Specification of the Network Interface Card
//
// The referenced SKU overwrites the default. In case of different network SKU references
// the highest possible network SKU reference is used. The network SKU reference
// might be restricted by the instance size.
type NicSpec struct {
	// Addresses List of IP addresses for the NIC. A specific IP address needs to be in the
	// CIDR range of the subnet and not used by any other NIC in the subnet. Multiple
	// IP addresses can be assigned to a NIC. The number of IP addresses is might be
	// limited by the CSP or the subnet size.
	Addresses []NicIp `json:"addresses"`

	// PublicIpRefs References to public IP addresses associated with this NIC. The IP may be external
	// and not directly visible on the server/NIC itself.
	PublicIpRefs *[]Reference `json:"publicIpRefs,omitempty"`

	// SkuRef Reference to the SKU of the NIC.
	SkuRef *Reference `json:"skuRef,omitempty"`

	// SubnetRef Reference to the subnet used by the NIC connections.
	SubnetRef Reference `json:"subnetRef"`
}

// ObjectStorageAccountSpec The specification of an object storage account, including the region and zone.
type ObjectStorageAccountSpec = map[string]interface{}

// Permission Permission specification, including providers, resources, and verbs.
// Permissions are used to define access control policies for user accounts.
type Permission struct {
	// Provider The provider for which the resource and verbs are defined.
	Provider string `json:"provider"`

	// Resources The resources are the specific resources that the permission applies to.
	// The resource can be a wildcard `*` to represent all resources or a
	// specific resource type. For example, `images/my-image` or
	// `images/*`.
	Resources []string `json:"resources"`

	// Verb The verb is a string that represents the action to be performed on a resource.
	// The standard operations are defined as `get`, `put`, `list`, `delete`. If the
	// resource has additional actions they can to be permitted individually as
	// verb and action in the form `<verb>:<action>`. For example, `post.start`,
	// `post.stop`, `post.restart` or with a wildcard for all actions `post`.
	Verb []string `json:"verb"`
}

// PermissionMetadata Metadata for permission management
type PermissionMetadata struct {
	Provider string `json:"provider"`
	Resource string `json:"resource"`
	Verb     string `json:"verb"`
}

// Port A valid network port number.
// The port number is a 16-bit unsigned integer ranging from 1 to 65535.
type Port = int

// Ports Defines a specific port list or port range for the rule.
// The configuration allows specifying individual ports, ranges, or a combination of both.
//
// Behavior:
// - If only `from` is specified, the range is interpreted as a single port: `from` to `from`.
// - If only `to` is specified, the range is interpreted as a single port: `to` to `to`.
// - If both `from` and `to` are specified, the range spans from `from` to `to`.
// - The `list` property can be used to explicitly define additional individual ports.
//
// The final result is a comprehensive list of ports and/or port ranges.
type Ports struct {
	// From A valid network port number.
	// The port number is a 16-bit unsigned integer ranging from 1 to 65535.
	From *Port   `json:"from,omitempty"`
	List *[]Port `json:"list,omitempty"`

	// To A valid network port number.
	// The port number is a 16-bit unsigned integer ranging from 1 to 65535.
	To *Port `json:"to,omitempty"`
}

// PublicIpSpec Specification of the public IP.
type PublicIpSpec struct {
	// Address The public IP address in case of BYOIP.
	Address *string `json:"address,omitempty"`

	// Version IP version of the address
	Version IPVersion `json:"version"`
}

// Reference Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
// The reference can be used to refer to a resource in other resources.
type Reference struct {
	union json.RawMessage
}

// ReferenceObject A reference to a resource using an object. The object contains the
// same information as the ReferenceURN, but is represented as a structured object.
// The advantage of this representation is that it can be used to reference
// resources in different workspaces or regions without the need to specify
// the full URN.
type ReferenceObject struct {
	// Provider Provider of the resource. If not set, the provider is inferred from the context.
	Provider *string `json:"provider,omitempty"`

	// Region Region of the resource. If not set, the region is inferred from the context.
	Region *string `json:"region,omitempty"`

	// Resource Name and type of the resource. Must be in the format `<type>/<name>`.
	// The type is the resource type, and the name is the resource name.
	Resource string `json:"resource"`

	// Tenant Tenant of the resource. If not set, the tenant is inferred from the context.
	Tenant *string `json:"tenant,omitempty"`

	// Workspace Workspace of the resource. If not set, the workspace is inferred from the context.
	Workspace *string `json:"workspace,omitempty"`
}

// ReferenceURN A unique resource name used to reference this resource in other resources. The reference
// is represented as the full URN (Uniform Resource Name) name of the resource.
//
// ### Automatic Prefix Inference
//
// In most cases, the prefix of the URN can be automatically derived in the given context.
// To simplify usage, only the resource type and name might be specified as a reference
// using the `<type>/<name>` notation. The suffix can be made more specific by adding
// additional segments separated by slashes.
//
// The prefix is automatically inferred from the context. For example, if the resource is a
// block storage in the same workspace the reference can be specified as
// `block-storages/my-block-storage`. If the resource is a block storage in a different workspace, the
// reference can be specified as `workspaces/ws-1/block-storages/my-block-storage`.
//
// For automatic prefix inference, the following rules apply:
// - the version is inferred from the current resource version
// - the workspace is inferred from the current workspace
// - the region is inferred from the current region
// - the provider is inferred from the type and context of the usage
//
// The prefix inference is resolved on admission into the full URN format, which makes it
// mostly suitable for human use.
type ReferenceURN = string

// RegionalMetadata Metadata for regional resources
type RegionalMetadata struct {
	// Region Reference to the region where the resource is located
	Region string `json:"region"`
}

// RegionalWorkspaceResourceMetadata defines model for RegionalWorkspaceResourceMetadata.
type RegionalWorkspaceResourceMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// CreatedAt Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Kind Type of the resource
	Kind RegionalWorkspaceResourceMetadataKind `json:"kind"`

	// LastModifiedAt Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedAt time.Time `json:"lastModifiedAt"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name     string `json:"name"`
	Provider string `json:"provider"`

	// Ref Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
	// The reference can be used to refer to a resource in other resources.
	Ref *Reference `json:"ref,omitempty"`

	// Region Reference to the region where the resource is located
	Region   string `json:"region"`
	Resource string `json:"resource"`

	// ResourceVersion Incremented on every modification of the resource. Used for optimistic concurrency control.
	ResourceVersion int `json:"resourceVersion"`

	// Tenant Tenant identifier
	Tenant string `json:"tenant"`
	Verb   string `json:"verb"`

	// Workspace Workspace identifier
	Workspace string `json:"workspace"`
}

// RegionalWorkspaceResourceMetadataKind Type of the resource
type RegionalWorkspaceResourceMetadataKind string

// RequestObject Request object
type RequestObject struct {
	Body     *RequestObject_Body `json:"body,omitempty"`
	Resource *string             `json:"resource,omitempty"`

	// Verb Verb that describes the action to be performed on the resource.
	// The verb can be one of the following: get, list, put, delete, post, ..
	Verb *string `json:"verb,omitempty"`
}

// RequestObject_Body defines model for RequestObject.Body.
type RequestObject_Body struct {
	union json.RawMessage
}

// ResponseMetadata defines model for ResponseMetadata.
type ResponseMetadata struct {
	Provider string `json:"provider"`
	Resource string `json:"resource"`

	// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
	SkipToken *string `json:"skipToken,omitempty"`
	Verb      string  `json:"verb"`
}

// ResponseObject Response object
type ResponseObject struct {
	Code *float32 `json:"code,omitempty"`
}

// RoleAssignmentScope Role assignment scope, including the workspaces, regions and tenants.
type RoleAssignmentScope struct {
	// Regions Optionally, a restriction can be applied to the region
	// where the role assignment is valid. If not specified,
	// the role assignment is valid for all regions.
	Regions *[]string `json:"regions,omitempty"`

	// Tenants Optionally, can be opened to all tenants or restricted to a specific tenant.
	// If not specified, the role assignment is valid for the current tenant.
	Tenants *[]string `json:"tenants,omitempty"`

	// Workspaces Optionally, a restriction can be applied to the workspace
	// where the role assignment is valid. If not specified,
	// the role assignment is valid for all workspaces.
	Workspaces *[]string `json:"workspaces,omitempty"`
}

// RoleAssignmentSpec Role assignment for a user account. The role is assigned to the user account in the context of the specified scopes.
type RoleAssignmentSpec struct {
	// Roles List of assigned role names
	Roles []string `json:"roles"`

	// Scopes List of scopes (e.g., tenant, workspace) for the role assignment
	Scopes []RoleAssignmentScope `json:"scopes"`

	// Subs List of subject IDs (from JWT) to whom the roles are assigned,
	// A wildcard `*` can be used to represent all users of the tenant scopes
	Subs []string `json:"subs"`
}

// RoleSpec Role specification defined as a list of permissions.
// Roles are used to define access control policies for
// a user account using a role assignment.
type RoleSpec struct {
	// Permissions List of permissions granted by this role
	Permissions []Permission `json:"permissions"`
}

// SecurityGroupRuleSpec Specification of a security group rule defining network access permissions.
// If no version is specified, any IP version will be allowed.
// If no protocol is specified, any network protocol will be allowed.
type SecurityGroupRuleSpec struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *Annotations `json:"annotations,omitempty"`

	// Direction Direction of the traffic flow:
	// * ingress: Only incoming traffic is allowed
	// * egress: Only outgoing traffic is allowed
	Direction SecurityGroupRuleSpecDirection `json:"direction"`

	// Icmp ICMP specific rule configuration
	Icmp *IcmpConfig `json:"icmp,omitempty"`

	// Ports Defines a specific port list or port range for the rule.
	// The configuration allows specifying individual ports, ranges, or a combination of both.
	//
	// Behavior:
	// - If only `from` is specified, the range is interpreted as a single port: `from` to `from`.
	// - If only `to` is specified, the range is interpreted as a single port: `to` to `to`.
	// - If both `from` and `to` are specified, the range spans from `from` to `to`.
	// - The `list` property can be used to explicitly define additional individual ports.
	//
	// The final result is a comprehensive list of ports and/or port ranges.
	Ports *Ports `json:"ports,omitempty"`

	// Protocol Network protocol for the rule
	Protocol *SecurityGroupRuleSpecProtocol `json:"protocol,omitempty"`

	// SourceRefs List of CIDR blocks, IP addresses, gateways, instances or security group references that are allowed to communicate
	// with the security group. If a security group is specified, all instances in that group are allowed.
	// If no sourceRefs are specified, all traffic is allowed.
	SourceRefs *[]Reference `json:"sourceRefs,omitempty"`

	// Version IP version of the address
	Version *IPVersion `json:"version,omitempty"`
}

// SecurityGroupRuleSpecDirection Direction of the traffic flow:
// * ingress: Only incoming traffic is allowed
// * egress: Only outgoing traffic is allowed
type SecurityGroupRuleSpecDirection string

// SecurityGroupRuleSpecProtocol Network protocol for the rule
type SecurityGroupRuleSpecProtocol string

// SecurityGroupSpec Specification of the security group
type SecurityGroupSpec struct {
	// Rules Network access rules defining communication between security groups and external networks.
	//
	// Rule Evaluation:
	// - Default behavior is to deny all traffic not explicitly allowed
	// - Rules provide granular control over allowed traffic types, sources, and destinations
	Rules []SecurityGroupRuleSpec `json:"rules"`
}

// StorageSkuSpec Specification of the storage SKU, including its capabilities and extensions.
type StorageSkuSpec struct {
	// Iops The number of IOPS (Input/Output Operations Per Second) guaranteed for
	// the storage SKU.
	Iops int `json:"iops"`

	// MinVolumeSize Minimum volume size for guaranteed performance, in GB.
	MinVolumeSize int `json:"minVolumeSize"`

	// Type Type of storage SKU. Can be one of the following:
	//
	// * `local-ephemeral`: Local storage is directly attached to the hypervisor
	//   hosting the instance. In the event of a hypervisor failure or instance
	//   restart, the data may either be lost or become unavailable. The failure
	//   mode depends on the Cloud Service Provider (CSP).
	//   Users of local storage should be aware of these risks and implement
	//   a robust backup strategy or application level replication of the data.
	//   Local storage is typically suited for high-performance workloads requiring
	//   low latency and high throughput, where the application layer can handle
	//   failures. It is not recommended for workloads demanding high availability
	//   or data durability. Example use-cases include caching, temporary data
	//   or immutable workloads such as operating system images without local data.
	// * `local-durable`: Local durable storage is similar to local storage
	//   but is designed to provide data durability while providing high-performance.
	//   It is typically implemented using a redundant storage device or
	//   replicated storage solution. Local durable storage is suitable for
	//   workloads requiring high performance and low latency, while also
	//   ensuring data durability at the cost of availability. The time to
	//   restore data may vary depending on the CSP and the
	//   will be significantly higher then using `remote-durable` storage.
	//   Example use-cases include replicated paxos or raft based databases or
	//   replicated databases using synchronous replication, in addition to
	//   file storage.
	// * `remote-durable`: Remote storage is a network-attached storage solution
	//   designed to provide data redundancy and high availability. While
	//   typically slower than local storage, remote storage offers the
	//   advantage of being accessible by different hypervisors.
	//   This means the storage can be used by different instances running
	//   on separate hypervisors, but only one instance at a time. This
	//   enabled the recreation of the instance with the same storage on a
	//   different hypervisor and therefore greatly reduces the recovery
	//   time in case of failure of the hypervisor. Remote storage cannot be
	//   attached to multiple instances simultaneously.
	//   Example use-cases include file storage or replicated databases
	//   using asynchronous replication.
	Type StorageSkuSpecType `json:"type"`
}

// StorageSkuSpecType Type of storage SKU. Can be one of the following:
//
//   - `local-ephemeral`: Local storage is directly attached to the hypervisor
//     hosting the instance. In the event of a hypervisor failure or instance
//     restart, the data may either be lost or become unavailable. The failure
//     mode depends on the Cloud Service Provider (CSP).
//     Users of local storage should be aware of these risks and implement
//     a robust backup strategy or application level replication of the data.
//     Local storage is typically suited for high-performance workloads requiring
//     low latency and high throughput, where the application layer can handle
//     failures. It is not recommended for workloads demanding high availability
//     or data durability. Example use-cases include caching, temporary data
//     or immutable workloads such as operating system images without local data.
//   - `local-durable`: Local durable storage is similar to local storage
//     but is designed to provide data durability while providing high-performance.
//     It is typically implemented using a redundant storage device or
//     replicated storage solution. Local durable storage is suitable for
//     workloads requiring high performance and low latency, while also
//     ensuring data durability at the cost of availability. The time to
//     restore data may vary depending on the CSP and the
//     will be significantly higher then using `remote-durable` storage.
//     Example use-cases include replicated paxos or raft based databases or
//     replicated databases using synchronous replication, in addition to
//     file storage.
//   - `remote-durable`: Remote storage is a network-attached storage solution
//     designed to provide data redundancy and high availability. While
//     typically slower than local storage, remote storage offers the
//     advantage of being accessible by different hypervisors.
//     This means the storage can be used by different instances running
//     on separate hypervisors, but only one instance at a time. This
//     enabled the recreation of the instance with the same storage on a
//     different hypervisor and therefore greatly reduces the recovery
//     time in case of failure of the hypervisor. Remote storage cannot be
//     attached to multiple instances simultaneously.
//     Example use-cases include file storage or replicated databases
//     using asynchronous replication.
type StorageSkuSpecType string

// SubnetSpec Detailed specification of the subnet. Automatic address
// assignment is supported, similar to the network configuration. The
// subnet's prefix length must be smaller than the network's prefix
// length, ensuring proper subdivision of the address space.
// The first and last IP addresses in the subnet are reserved
// the network address and broadcast address, respectively.
//
// Most CSP will not allow to use a different IPv6 prefix length than /64.
type SubnetSpec struct {
	// Cidr Combined IPv4 and IPv6 CIDR block for a subnet. Depending on the network
	// configuration, either the IPv4 or IPv6 range can be omitted. So the following
	// combinations are possible:
	//
	// * IPv4 only
	// * IPv6 only
	// * IPv4 and IPv6 (Dual Stack)
	Cidr Cidr `json:"cidr"`

	// RouteTableRef Reference to the route table used by default for all NICs in this Subnet.
	// If not provided, the routeTableRef associated with the network of the subnet will be used.
	RouteTableRef *Reference `json:"routeTableRef,omitempty"`

	// SkuRef Reference to the SKU used by default for all NICs in this Network.
	// Can be overridden by the NIC
	SkuRef *Reference `json:"skuRef,omitempty"`

	// Zone Reference to a specific zone within a region
	Zone Zone `json:"zone"`
}

// TenantMetadata Metadata for resources with tenant constraints
type TenantMetadata struct {
	// Tenant Tenant identifier
	Tenant string `json:"tenant"`
}

// TypeMetadata Metadata for all resources with type information.
type TypeMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// Kind Type of the resource
	Kind TypeMetadataKind `json:"kind"`

	// Ref Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
	// The reference can be used to refer to a resource in other resources.
	Ref *Reference `json:"ref,omitempty"`
}

// TypeMetadataKind Type of the resource
type TypeMetadataKind string

// VolumeReference Represents a connection between a Block Storage and an a user of the block storage.
type VolumeReference struct {
	// DeviceRef Reference to the block storage used to store the volume.
	DeviceRef Reference `json:"deviceRef"`

	// Type The connection type depends on the type of device and type of block storage.
	Type *VolumeReferenceType `json:"type,omitempty"`
}

// VolumeReferenceType The connection type depends on the type of device and type of block storage.
type VolumeReferenceType string

// WorkspaceMetadata Metadata for resources with workspace constraints
type WorkspaceMetadata struct {
	// Workspace Workspace identifier
	Workspace string `json:"workspace"`
}

// WorkspaceSpec Specification of the workspace, including its capabilities and extensions.
type WorkspaceSpec = map[string]interface{}

// Zone Reference to a specific zone within a region
type Zone = string

// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
// The number of annotations is eventually limited by the CSP.
type Annotations map[string]string

// Cidr Combined IPv4 and IPv6 CIDR block for a subnet. Depending on the network
// configuration, either the IPv4 or IPv6 range can be omitted. So the following
// combinations are possible:
//
// * IPv4 only
// * IPv6 only
// * IPv4 and IPv6 (Dual Stack)
type Cidr struct {
	// Ipv4 IPv4 CIDR block for the subnet.
	Ipv4 *string `json:"ipv4,omitempty"`

	// Ipv6 IPv6 CIDR block for the subnet.
	Ipv6 *string `json:"ipv6,omitempty"`
}

// AcceptHeader defines model for acceptHeader.
type AcceptHeader string

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// TenantPathParam defines model for tenantPathParam.
type TenantPathParam = string

// WorkspacePathParam defines model for workspacePathParam.
type WorkspacePathParam = string

// ListActivityLogsParams defines parameters for ListActivityLogs.
type ListActivityLogsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: \*key\*=\*value\* - substring (contains) match on both key and value. Each `*` can appear at start, end or in the middle to mean "any characters". Example: \*env\*=\*prod\* matches a label key containing "env" whose value contains "prod".
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListActivityLogsParamsAccept `json:"Accept,omitempty"`
}

// ListActivityLogsParamsAccept defines parameters for ListActivityLogs.
type ListActivityLogsParamsAccept string

// AsReferenceURN returns the union data inside the Reference as a ReferenceURN
func (t Reference) AsReferenceURN() (ReferenceURN, error) {
	var body ReferenceURN
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReferenceURN overwrites any union data inside the Reference as the provided ReferenceURN
func (t *Reference) FromReferenceURN(v ReferenceURN) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReferenceURN performs a merge with any union data inside the Reference, using the provided ReferenceURN
func (t *Reference) MergeReferenceURN(v ReferenceURN) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReferenceObject returns the union data inside the Reference as a ReferenceObject
func (t Reference) AsReferenceObject() (ReferenceObject, error) {
	var body ReferenceObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReferenceObject overwrites any union data inside the Reference as the provided ReferenceObject
func (t *Reference) FromReferenceObject(v ReferenceObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReferenceObject performs a merge with any union data inside the Reference, using the provided ReferenceObject
func (t *Reference) MergeReferenceObject(v ReferenceObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Reference) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Reference) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBlockStorageSpec returns the union data inside the RequestObject_Body as a BlockStorageSpec
func (t RequestObject_Body) AsBlockStorageSpec() (BlockStorageSpec, error) {
	var body BlockStorageSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlockStorageSpec overwrites any union data inside the RequestObject_Body as the provided BlockStorageSpec
func (t *RequestObject_Body) FromBlockStorageSpec(v BlockStorageSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlockStorageSpec performs a merge with any union data inside the RequestObject_Body, using the provided BlockStorageSpec
func (t *RequestObject_Body) MergeBlockStorageSpec(v BlockStorageSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceSkuSpec returns the union data inside the RequestObject_Body as a InstanceSkuSpec
func (t RequestObject_Body) AsInstanceSkuSpec() (InstanceSkuSpec, error) {
	var body InstanceSkuSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceSkuSpec overwrites any union data inside the RequestObject_Body as the provided InstanceSkuSpec
func (t *RequestObject_Body) FromInstanceSkuSpec(v InstanceSkuSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceSkuSpec performs a merge with any union data inside the RequestObject_Body, using the provided InstanceSkuSpec
func (t *RequestObject_Body) MergeInstanceSkuSpec(v InstanceSkuSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceSpec returns the union data inside the RequestObject_Body as a InstanceSpec
func (t RequestObject_Body) AsInstanceSpec() (InstanceSpec, error) {
	var body InstanceSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceSpec overwrites any union data inside the RequestObject_Body as the provided InstanceSpec
func (t *RequestObject_Body) FromInstanceSpec(v InstanceSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceSpec performs a merge with any union data inside the RequestObject_Body, using the provided InstanceSpec
func (t *RequestObject_Body) MergeInstanceSpec(v InstanceSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetworkLoadBalancerSpec returns the union data inside the RequestObject_Body as a NetworkLoadBalancerSpec
func (t RequestObject_Body) AsNetworkLoadBalancerSpec() (NetworkLoadBalancerSpec, error) {
	var body NetworkLoadBalancerSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkLoadBalancerSpec overwrites any union data inside the RequestObject_Body as the provided NetworkLoadBalancerSpec
func (t *RequestObject_Body) FromNetworkLoadBalancerSpec(v NetworkLoadBalancerSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkLoadBalancerSpec performs a merge with any union data inside the RequestObject_Body, using the provided NetworkLoadBalancerSpec
func (t *RequestObject_Body) MergeNetworkLoadBalancerSpec(v NetworkLoadBalancerSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetworkSkuSpec returns the union data inside the RequestObject_Body as a NetworkSkuSpec
func (t RequestObject_Body) AsNetworkSkuSpec() (NetworkSkuSpec, error) {
	var body NetworkSkuSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkSkuSpec overwrites any union data inside the RequestObject_Body as the provided NetworkSkuSpec
func (t *RequestObject_Body) FromNetworkSkuSpec(v NetworkSkuSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkSkuSpec performs a merge with any union data inside the RequestObject_Body, using the provided NetworkSkuSpec
func (t *RequestObject_Body) MergeNetworkSkuSpec(v NetworkSkuSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetworkSpec returns the union data inside the RequestObject_Body as a NetworkSpec
func (t RequestObject_Body) AsNetworkSpec() (NetworkSpec, error) {
	var body NetworkSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkSpec overwrites any union data inside the RequestObject_Body as the provided NetworkSpec
func (t *RequestObject_Body) FromNetworkSpec(v NetworkSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkSpec performs a merge with any union data inside the RequestObject_Body, using the provided NetworkSpec
func (t *RequestObject_Body) MergeNetworkSpec(v NetworkSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNicSpec returns the union data inside the RequestObject_Body as a NicSpec
func (t RequestObject_Body) AsNicSpec() (NicSpec, error) {
	var body NicSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNicSpec overwrites any union data inside the RequestObject_Body as the provided NicSpec
func (t *RequestObject_Body) FromNicSpec(v NicSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNicSpec performs a merge with any union data inside the RequestObject_Body, using the provided NicSpec
func (t *RequestObject_Body) MergeNicSpec(v NicSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsObjectStorageAccountSpec returns the union data inside the RequestObject_Body as a ObjectStorageAccountSpec
func (t RequestObject_Body) AsObjectStorageAccountSpec() (ObjectStorageAccountSpec, error) {
	var body ObjectStorageAccountSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObjectStorageAccountSpec overwrites any union data inside the RequestObject_Body as the provided ObjectStorageAccountSpec
func (t *RequestObject_Body) FromObjectStorageAccountSpec(v ObjectStorageAccountSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObjectStorageAccountSpec performs a merge with any union data inside the RequestObject_Body, using the provided ObjectStorageAccountSpec
func (t *RequestObject_Body) MergeObjectStorageAccountSpec(v ObjectStorageAccountSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPublicIpSpec returns the union data inside the RequestObject_Body as a PublicIpSpec
func (t RequestObject_Body) AsPublicIpSpec() (PublicIpSpec, error) {
	var body PublicIpSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPublicIpSpec overwrites any union data inside the RequestObject_Body as the provided PublicIpSpec
func (t *RequestObject_Body) FromPublicIpSpec(v PublicIpSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePublicIpSpec performs a merge with any union data inside the RequestObject_Body, using the provided PublicIpSpec
func (t *RequestObject_Body) MergePublicIpSpec(v PublicIpSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRoleAssignmentSpec returns the union data inside the RequestObject_Body as a RoleAssignmentSpec
func (t RequestObject_Body) AsRoleAssignmentSpec() (RoleAssignmentSpec, error) {
	var body RoleAssignmentSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRoleAssignmentSpec overwrites any union data inside the RequestObject_Body as the provided RoleAssignmentSpec
func (t *RequestObject_Body) FromRoleAssignmentSpec(v RoleAssignmentSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRoleAssignmentSpec performs a merge with any union data inside the RequestObject_Body, using the provided RoleAssignmentSpec
func (t *RequestObject_Body) MergeRoleAssignmentSpec(v RoleAssignmentSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRoleSpec returns the union data inside the RequestObject_Body as a RoleSpec
func (t RequestObject_Body) AsRoleSpec() (RoleSpec, error) {
	var body RoleSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRoleSpec overwrites any union data inside the RequestObject_Body as the provided RoleSpec
func (t *RequestObject_Body) FromRoleSpec(v RoleSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRoleSpec performs a merge with any union data inside the RequestObject_Body, using the provided RoleSpec
func (t *RequestObject_Body) MergeRoleSpec(v RoleSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityGroupSpec returns the union data inside the RequestObject_Body as a SecurityGroupSpec
func (t RequestObject_Body) AsSecurityGroupSpec() (SecurityGroupSpec, error) {
	var body SecurityGroupSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityGroupSpec overwrites any union data inside the RequestObject_Body as the provided SecurityGroupSpec
func (t *RequestObject_Body) FromSecurityGroupSpec(v SecurityGroupSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityGroupSpec performs a merge with any union data inside the RequestObject_Body, using the provided SecurityGroupSpec
func (t *RequestObject_Body) MergeSecurityGroupSpec(v SecurityGroupSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStorageSkuSpec returns the union data inside the RequestObject_Body as a StorageSkuSpec
func (t RequestObject_Body) AsStorageSkuSpec() (StorageSkuSpec, error) {
	var body StorageSkuSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStorageSkuSpec overwrites any union data inside the RequestObject_Body as the provided StorageSkuSpec
func (t *RequestObject_Body) FromStorageSkuSpec(v StorageSkuSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStorageSkuSpec performs a merge with any union data inside the RequestObject_Body, using the provided StorageSkuSpec
func (t *RequestObject_Body) MergeStorageSkuSpec(v StorageSkuSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubnetSpec returns the union data inside the RequestObject_Body as a SubnetSpec
func (t RequestObject_Body) AsSubnetSpec() (SubnetSpec, error) {
	var body SubnetSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubnetSpec overwrites any union data inside the RequestObject_Body as the provided SubnetSpec
func (t *RequestObject_Body) FromSubnetSpec(v SubnetSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubnetSpec performs a merge with any union data inside the RequestObject_Body, using the provided SubnetSpec
func (t *RequestObject_Body) MergeSubnetSpec(v SubnetSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkspaceSpec returns the union data inside the RequestObject_Body as a WorkspaceSpec
func (t RequestObject_Body) AsWorkspaceSpec() (WorkspaceSpec, error) {
	var body WorkspaceSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkspaceSpec overwrites any union data inside the RequestObject_Body as the provided WorkspaceSpec
func (t *RequestObject_Body) FromWorkspaceSpec(v WorkspaceSpec) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkspaceSpec performs a merge with any union data inside the RequestObject_Body, using the provided WorkspaceSpec
func (t *RequestObject_Body) MergeWorkspaceSpec(v WorkspaceSpec) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequestObject_Body) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RequestObject_Body) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListActivityLogs request
	ListActivityLogs(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, params *ListActivityLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListActivityLogs(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, params *ListActivityLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListActivityLogsRequest(c.Server, tenant, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListActivityLogsRequest generates requests for ListActivityLogs
func NewListActivityLogsRequest(server string, tenant TenantPathParam, workspace WorkspacePathParam, params *ListActivityLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1beta1/tenants/%s/workspaces/%s/activity-logs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListActivityLogsWithResponse request
	ListActivityLogsWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, params *ListActivityLogsParams, reqEditors ...RequestEditorFn) (*ListActivityLogsResponse, error)
}

type ListActivityLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActivityLogIterator
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r ListActivityLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListActivityLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListActivityLogsWithResponse request returning *ListActivityLogsResponse
func (c *ClientWithResponses) ListActivityLogsWithResponse(ctx context.Context, tenant TenantPathParam, workspace WorkspacePathParam, params *ListActivityLogsParams, reqEditors ...RequestEditorFn) (*ListActivityLogsResponse, error) {
	rsp, err := c.ListActivityLogs(ctx, tenant, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListActivityLogsResponse(rsp)
}

// ParseListActivityLogsResponse parses an HTTP response from a ListActivityLogsWithResponse call
func ParseListActivityLogsResponse(rsp *http.Response) (*ListActivityLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListActivityLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActivityLogIterator
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List activity logs
	// (GET /v1beta1/tenants/{tenant}/workspaces/{workspace}/activity-logs)
	ListActivityLogs(w http.ResponseWriter, r *http.Request, tenant TenantPathParam, workspace WorkspacePathParam, params ListActivityLogsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListActivityLogs operation middleware
func (siw *ServerInterfaceWrapper) ListActivityLogs(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant TenantPathParam

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace WorkspacePathParam

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListActivityLogsParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListActivityLogsParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListActivityLogs(w, r, tenant, workspace, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/v1beta1/tenants/{tenant}/workspaces/{workspace}/activity-logs", wrapper.ListActivityLogs)

	return m
}
