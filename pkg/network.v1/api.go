//go:build go1.22

// Package network provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package network

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for LanKind.
const (
	LanKindLan LanKind = "lan"
)

// Defines values for NetworkSkuKind.
const (
	NetworkSkuKindNetworkSku NetworkSkuKind = "network-sku"
)

// Defines values for NicKind.
const (
	NicKindNic NicKind = "nic"
)

// Defines values for NicPrivateIpAdressType.
const (
	NicPrivateIpAdressTypeIPv4 NicPrivateIpAdressType = "IPv4"
)

// Defines values for PublicIpKind.
const (
	PublicIpKindPublicIp PublicIpKind = "public-ip"
)

// Defines values for PublicIpSpecIpVersion.
const (
	PublicIpSpecIpVersionIPv4 PublicIpSpecIpVersion = "IPv4"
)

// Defines values for PublicIpSpecType.
const (
	Dynamic PublicIpSpecType = "Dynamic"
	Static  PublicIpSpecType = "Static"
)

// Defines values for ResourceQuotaKind.
const (
	Quota ResourceQuotaKind = "quota"
)

// Defines values for ResourceStatePhase.
const (
	ResourceStatePhaseActive    ResourceStatePhase = "active"
	ResourceStatePhaseCreating  ResourceStatePhase = "creating"
	ResourceStatePhaseDeleting  ResourceStatePhase = "deleting"
	ResourceStatePhaseError     ResourceStatePhase = "error"
	ResourceStatePhasePending   ResourceStatePhase = "pending"
	ResourceStatePhaseSuspended ResourceStatePhase = "suspended"
	ResourceStatePhaseUpdating  ResourceStatePhase = "updating"
)

// Defines values for RouteStatusManagedBy.
const (
	Service RouteStatusManagedBy = "service"
	User    RouteStatusManagedBy = "user"
)

// Defines values for RouteStatusState.
const (
	RouteStatusStateActive    RouteStatusState = "active"
	RouteStatusStateBlackhole RouteStatusState = "blackhole"
)

// Defines values for SecurityGroupKind.
const (
	SecurityGroupKindSecurityGroup SecurityGroupKind = "security-group"
)

// Defines values for SecurityGroupRuleKind.
const (
	SecurityGroupRuleKindSecurityGroupRule SecurityGroupRuleKind = "security-group-rule"
)

// Defines values for SecurityGroupRuleSourceType.
const (
	SecurityGroupRuleSourceTypeCidr           SecurityGroupRuleSourceType = "cidr"
	SecurityGroupRuleSourceTypePublicInternet SecurityGroupRuleSourceType = "publicInternet"
	SecurityGroupRuleSourceTypeSecurityGroup  SecurityGroupRuleSourceType = "securityGroup"
)

// Defines values for SecurityGroupRuleSpecDirection.
const (
	Egress  SecurityGroupRuleSpecDirection = "egress"
	Ingress SecurityGroupRuleSpecDirection = "ingress"
)

// Defines values for SecurityGroupRuleSpecProtocol.
const (
	All  SecurityGroupRuleSpecProtocol = "all"
	Icmp SecurityGroupRuleSpecProtocol = "icmp"
	Tcp  SecurityGroupRuleSpecProtocol = "tcp"
	Udp  SecurityGroupRuleSpecProtocol = "udp"
)

// Defines values for SubnetKind.
const (
	SubnetKindSubnet SubnetKind = "subnet"
)

// Defines values for SubnetGatewayType.
const (
	SubnetGatewayTypeAuto        SubnetGatewayType = "auto"
	SubnetGatewayTypeInstanceRef SubnetGatewayType = "instanceRef"
	SubnetGatewayTypeInternalIp  SubnetGatewayType = "internalIp"
)

// Defines values for SubnetSpecDefaultGatewayType.
const (
	SubnetSpecDefaultGatewayTypeAuto        SubnetSpecDefaultGatewayType = "auto"
	SubnetSpecDefaultGatewayTypeInstanceRef SubnetSpecDefaultGatewayType = "instanceRef"
	SubnetSpecDefaultGatewayTypeInternalIp  SubnetSpecDefaultGatewayType = "internalIp"
)

// Defines values for SubnetSpecDhcpEnabled.
const (
	True SubnetSpecDhcpEnabled = true
)

// Defines values for AcceptHeader.
const (
	AcceptHeaderApplicationjson            AcceptHeader = "application/json"
	AcceptHeaderApplicationjsonDeletedOnly AcceptHeader = "application/json; deleted=only"
	AcceptHeaderApplicationjsonDeletedTrue AcceptHeader = "application/json; deleted=true"
)

// Defines values for ListNetworkQuotasParamsAccept.
const (
	ListNetworkQuotasParamsAcceptApplicationjson            ListNetworkQuotasParamsAccept = "application/json"
	ListNetworkQuotasParamsAcceptApplicationjsonDeletedOnly ListNetworkQuotasParamsAccept = "application/json; deleted=only"
	ListNetworkQuotasParamsAcceptApplicationjsonDeletedTrue ListNetworkQuotasParamsAccept = "application/json; deleted=true"
)

// Defines values for ListNetworkSkusParamsAccept.
const (
	ListNetworkSkusParamsAcceptApplicationjson            ListNetworkSkusParamsAccept = "application/json"
	ListNetworkSkusParamsAcceptApplicationjsonDeletedOnly ListNetworkSkusParamsAccept = "application/json; deleted=only"
	ListNetworkSkusParamsAcceptApplicationjsonDeletedTrue ListNetworkSkusParamsAccept = "application/json; deleted=true"
)

// Defines values for ListLANsParamsAccept.
const (
	ListLANsParamsAcceptApplicationjson            ListLANsParamsAccept = "application/json"
	ListLANsParamsAcceptApplicationjsonDeletedOnly ListLANsParamsAccept = "application/json; deleted=only"
	ListLANsParamsAcceptApplicationjsonDeletedTrue ListLANsParamsAccept = "application/json; deleted=true"
)

// Defines values for ListNicsParamsAccept.
const (
	ListNicsParamsAcceptApplicationjson            ListNicsParamsAccept = "application/json"
	ListNicsParamsAcceptApplicationjsonDeletedOnly ListNicsParamsAccept = "application/json; deleted=only"
	ListNicsParamsAcceptApplicationjsonDeletedTrue ListNicsParamsAccept = "application/json; deleted=true"
)

// Defines values for GetNicParamsAccept.
const (
	GetNicParamsAcceptApplicationjson            GetNicParamsAccept = "application/json"
	GetNicParamsAcceptApplicationjsonDeletedOnly GetNicParamsAccept = "application/json; deleted=only"
	GetNicParamsAcceptApplicationjsonDeletedTrue GetNicParamsAccept = "application/json; deleted=true"
)

// Defines values for ListRoutingTablesParamsAccept.
const (
	ListRoutingTablesParamsAcceptApplicationjson            ListRoutingTablesParamsAccept = "application/json"
	ListRoutingTablesParamsAcceptApplicationjsonDeletedOnly ListRoutingTablesParamsAccept = "application/json; deleted=only"
	ListRoutingTablesParamsAcceptApplicationjsonDeletedTrue ListRoutingTablesParamsAccept = "application/json; deleted=true"
)

// Defines values for ListSecurityGroupsParamsAccept.
const (
	ListSecurityGroupsParamsAcceptApplicationjson            ListSecurityGroupsParamsAccept = "application/json"
	ListSecurityGroupsParamsAcceptApplicationjsonDeletedOnly ListSecurityGroupsParamsAccept = "application/json; deleted=only"
	ListSecurityGroupsParamsAcceptApplicationjsonDeletedTrue ListSecurityGroupsParamsAccept = "application/json; deleted=true"
)

// Defines values for ListSubnetsParamsAccept.
const (
	ListSubnetsParamsAcceptApplicationjson            ListSubnetsParamsAccept = "application/json"
	ListSubnetsParamsAcceptApplicationjsonDeletedOnly ListSubnetsParamsAccept = "application/json; deleted=only"
	ListSubnetsParamsAcceptApplicationjsonDeletedTrue ListSubnetsParamsAccept = "application/json; deleted=true"
)

// Defines values for ListPublicIPsParamsAccept.
const (
	ListPublicIPsParamsAcceptApplicationjson            ListPublicIPsParamsAccept = "application/json"
	ListPublicIPsParamsAcceptApplicationjsonDeletedOnly ListPublicIPsParamsAccept = "application/json; deleted=only"
	ListPublicIPsParamsAcceptApplicationjsonDeletedTrue ListPublicIPsParamsAccept = "application/json; deleted=true"
)

// Error A generic error response
type Error struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error400 defines model for Error400.
type Error400 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error401 defines model for Error401.
type Error401 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error403 defines model for Error403.
type Error403 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error404 defines model for Error404.
type Error404 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error412 defines model for Error412.
type Error412 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error422 defines model for Error422.
type Error422 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error500 defines model for Error500.
type Error500 struct {
	Errors []ErrorDetail `json:"errors"`
}

// ErrorDetail A detailed error response
type ErrorDetail struct {
	// Code An application-specific error code, expressed as a string value.
	Code string `json:"code"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta map[string]interface{} `json:"meta"`

	// Source An object containing references to the source of the error.
	Source *ErrorSource `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem.
	Title string `json:"title"`
}

// ErrorSource An object containing references to the source of the error.
type ErrorSource struct {
	// Parameter A string indicating which URI query parameter caused the error.
	Parameter string `json:"parameter"`

	// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
	Pointer string `json:"pointer"`
}

// Lan defines model for Lan.
type Lan struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *LanKind                  `json:"kind,omitempty"`
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`
	Spec     *LanSpec                  `json:"spec,omitempty"`

	// Status Conditions type `connectivity` indicates the status of the network connection.
	// The status can be `connected` or `disconnected`.
	Status *LanStatus `json:"status,omitempty"`
}

// LanKind Type of the resource
type LanKind string

// LanSpec defines model for LanSpec.
type LanSpec struct {
	Profile *struct {
		// NetworkSkuRef Reference to the SKU used for this LAN
		NetworkSkuRef *string        `json:"networkSkuRef,omitempty"`
		SkuExtensions *SkuExtensions `json:"skuExtensions,omitempty"`
	} `json:"profile,omitempty"`
}

// LanStatus Conditions type `connectivity` indicates the status of the network connection.
// The status can be `connected` or `disconnected`.
type LanStatus struct {
	Conditions *[]StatusCondition `json:"conditions,omitempty"`

	// State Generic state definition for all resources. All states are optional, but must not have more states.
	// If a provider wants to present fine granular states, please use conditions.
	State *ResourceState `json:"state,omitempty"`
}

// NetworkSku Represents a Stock Keeping Unit (SKU) for network resources.
//
// Network SKUs define performance tiers for network bandwidth and characteristics.
// capabilities can be found also in the metadata.labels sections and are searchable.
type NetworkSku struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *NetworkSkuKind           `json:"kind,omitempty"`
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`
	Spec     *NetworkSkuSpec           `json:"spec,omitempty"`

	// Status Current status of the resource
	Status *Status `json:"status,omitempty"`
}

// NetworkSkuKind Type of the resource
type NetworkSkuKind string

// NetworkSkuSpec defines model for NetworkSkuSpec.
type NetworkSkuSpec struct {
	// Capabilities Network performance capabilities
	Capabilities *map[string]interface{} `json:"capabilities,omitempty"`
	Description  *string                 `json:"description,omitempty"`

	// Extensions Additional network feature extensions
	Extensions *[]string `json:"extensions,omitempty"`

	// MandatoryParameters Mandatory parameters for network resources
	MandatoryParameters *[]string `json:"mandatoryParameters,omitempty"`

	// Provider Provider namespace for network SKUs
	Provider *string `json:"provider,omitempty"`

	// Tier Network performance tier
	Tier *string `json:"tier,omitempty"`
}

// Nic Network Interface Card (NIC) representing a network interface for a compute resource
type Nic struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *NicKind                 `json:"kind,omitempty"`
	Metadata RegionalResourceMetadata `json:"metadata"`

	// Spec Specification of the Network Interface Card
	Spec   NicSpec   `json:"spec"`
	Status NicStatus `json:"status"`
}

// NicKind Type of the resource
type NicKind string

// NicPrivateIp defines model for NicPrivateIp.
type NicPrivateIp struct {
	AdressType *NicPrivateIpAdressType `json:"adressType,omitempty"`
	IpAddress  *string                 `json:"ipAddress,omitempty"`
}

// NicPrivateIpAdressType defines model for NicPrivateIp.AdressType.
type NicPrivateIpAdressType string

// NicSpec Specification of the Network Interface Card
type NicSpec struct {
	// PublicIPRef References to public IP addresses associated with this NIC. The IP may be external and not directly visible on the server/NIC itself. Maximum one IP allowed.
	PublicIPRef *string `json:"publicIPRef,omitempty"`

	// StaticPrivateIPs List of static private IP addresses for this NIC. Can only be used when the subnet has dhcpEnabled=false.
	StaticPrivateIPs *[]NicPrivateIp `json:"staticPrivateIPs,omitempty"`

	// SubnetRef Subnet this NIC is connected to
	SubnetRef *string `json:"subnetRef,omitempty"`
}

// NicStatus defines model for NicStatus.
type NicStatus struct {
	Conditions       []StatusCondition `json:"conditions"`
	PrivateIPs       *[]NicPrivateIp   `json:"privateIPs,omitempty"`
	PublicIPRef      *[]string         `json:"publicIPRef,omitempty"`
	SecurityGroupRef *string           `json:"securityGroupRef,omitempty"`

	// State Generic state definition for all resources. All states are optional, but must not have more states.
	// If a provider wants to present fine granular states, please use conditions.
	State     *ResourceState `json:"state,omitempty"`
	SubnetRef *string        `json:"subnetRef,omitempty"`
}

// PortRange Specific port or port range for the rule
type PortRange struct {
	From *int `json:"from,omitempty"`
	To   *int `json:"to,omitempty"`
}

// PublicIp Represents a public IP address that can be assigned to network resources
type PublicIp struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *PublicIpKind             `json:"kind,omitempty"`
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`

	// Spec Specification of the public IP
	Spec *PublicIpSpec `json:"spec,omitempty"`

	// Status Current status of the public IP.
	// Condition type `allocation` indicates the status of the public IP allocation.
	// The status can be `allocated` or `released`.
	// Condition type  `binding` indicates the status of the IP binding to a resource.
	// The status can be `bound` or `unbound`.
	Status *PublicIpStatus `json:"status,omitempty"`
}

// PublicIpKind Type of the resource
type PublicIpKind string

// PublicIpAssignment defines model for PublicIpAssignment.
type PublicIpAssignment struct {
	// Kind Kind of resource the IP is assigned to
	Kind *string `json:"kind,omitempty"`

	// Name Name of the resource the IP is assigned to
	Name *string `json:"name,omitempty"`
}

// PublicIpSpec Specification of the public IP
type PublicIpSpec struct {
	// AssignedTo References to resources this IP is assigned to
	AssignedTo *[]PublicIpAssignment `json:"assignedTo,omitempty"`

	// IpAddress The public IP address
	IpAddress *string `json:"ipAddress,omitempty"`

	// IpVersion IP version of the address (limited to IPv4 for now)
	IpVersion *PublicIpSpecIpVersion `json:"ipVersion,omitempty"`

	// Type Type of public IP allocation
	Type *PublicIpSpecType `json:"type,omitempty"`
}

// PublicIpSpecIpVersion IP version of the address (limited to IPv4 for now)
type PublicIpSpecIpVersion string

// PublicIpSpecType Type of public IP allocation
type PublicIpSpecType string

// PublicIpStatus Current status of the public IP.
// Condition type `allocation` indicates the status of the public IP allocation.
// The status can be `allocated` or `released`.
// Condition type  `binding` indicates the status of the IP binding to a resource.
// The status can be `bound` or `unbound`.
type PublicIpStatus struct {
	Conditions *[]StatusCondition `json:"conditions,omitempty"`

	// State Generic state definition for all resources. All states are optional, but must not have more states.
	// If a provider wants to present fine granular states, please use conditions.
	State *ResourceState `json:"state,omitempty"`
}

// RegionalResourceMetadata defines model for RegionalResourceMetadata.
type RegionalResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels map[string]interface{} `json:"labels"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Location Reference to the region where the resource is located
	Location *struct {
		Region string `json:"region"`
	} `json:"location,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name string `json:"name"`
}

// ResourceMetadata Base metadata for all resources, with optional location references
type ResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels map[string]interface{} `json:"labels"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name string `json:"name"`
}

// ResourceQuota defines model for ResourceQuota.
type ResourceQuota struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *ResourceQuotaKind        `json:"kind,omitempty"`
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`

	// Spec Represents the ResourceQuota for the single ResourceType of the Resource Provider
	Spec   *ResourceQuotaSpec   `json:"spec,omitempty"`
	Status *ResourceQuotaStatus `json:"status,omitempty"`
}

// ResourceQuotaKind Type of the resource
type ResourceQuotaKind string

// ResourceQuotaSpec Represents the ResourceQuota for the single ResourceType of the Resource Provider
type ResourceQuotaSpec struct {
	// Value limit number of resourceType instances, set null for unlimited
	Value *int `json:"value"`
}

// ResourceQuotaStatus defines model for ResourceQuotaStatus.
type ResourceQuotaStatus struct {
	Conditions []StatusCondition `json:"conditions"`
	Current    *ResourceQuota    `json:"current,omitempty"`
	Usage      *ResourceQuota    `json:"usage,omitempty"`
}

// ResourceState Generic state definition for all resources. All states are optional, but must not have more states.
// If a provider wants to present fine granular states, please use conditions.
type ResourceState struct {
	// Phase Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fullfill the request; would be related to provider issue or customer related input.
	Phase *ResourceStatePhase `json:"phase,omitempty"`
}

// ResourceStatePhase Current phase of the resource:
// - pending: not available, waiting for other resources
// - creating: not available, creation started
// - active: available for data layer usage
// - updating: available for data layer usage
// - deleting: maybe still available for data layer user, can fail any moment
// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
// - error: failed to fullfill the request; would be related to provider issue or customer related input.
type ResourceStatePhase string

// ResponseMetadata defines model for ResponseMetadata.
type ResponseMetadata struct {
	// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
	SkipToken *string `json:"skipToken,omitempty"`
}

// Route defines model for Route.
type Route struct {
	Spec   *RouteSpec   `json:"spec,omitempty"`
	Status *RouteStatus `json:"status,omitempty"`
}

// RouteSpec defines model for RouteSpec.
type RouteSpec struct {
	// DestinationCidrBlock The CIDR block for the destination
	DestinationCidrBlock *string `json:"destinationCidrBlock,omitempty"`

	// Target The target for the route (e.g., igw-id, nat-gateway-id)
	Target *string `json:"target,omitempty"`
}

// RouteStatus defines model for RouteStatus.
type RouteStatus struct {
	Conditions *[]StatusCondition `json:"conditions,omitempty"`

	// ManagedBy Whether the route is managed by the user or a service
	ManagedBy *RouteStatusManagedBy `json:"managedBy,omitempty"`

	// State The state of the route
	State *RouteStatusState `json:"state,omitempty"`
}

// RouteStatusManagedBy Whether the route is managed by the user or a service
type RouteStatusManagedBy string

// RouteStatusState The state of the route
type RouteStatusState string

// RoutingTable defines model for RoutingTable.
type RoutingTable struct {
	Spec   *RoutingTableSpec   `json:"spec,omitempty"`
	Status *RoutingTableStatus `json:"status,omitempty"`
}

// RoutingTableSpec defines model for RoutingTableSpec.
type RoutingTableSpec struct {
	Routes *[]Route `json:"routes,omitempty"`
}

// RoutingTableStatus defines model for RoutingTableStatus.
type RoutingTableStatus struct {
	Conditions []StatusCondition `json:"conditions"`
	Routes     *[]Route          `json:"routes,omitempty"`
}

// SecurityGroup A Security Group defines network access rules for a group of compute instances.
//
// Key Concepts:
// - Rules define bi-directional or uni-directional network communication
// - Supports routing between security groups
// - Enables granular control over public internet access
// - Implements stateful connection tracking
//
// Connection Tracking:
// When a connection is initiated from an allowed source, return traffic is automatically permitted,
// even if not explicitly defined in the rules. This ensures seamless, bi-directional communication
// for established connections.
//
// Routing and Communication Patterns:
// - Group-to-Group Rules: Define explicit communication paths between security groups
// - PublicInternet Target: Allows precise control over internet-facing traffic
// - Ingress/Egress Control: Fine-grained rules for incoming and outgoing traffic
type SecurityGroup struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *SecurityGroupKind        `json:"kind,omitempty"`
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`

	// Spec Specification of the security group
	Spec *SecurityGroupSpec `json:"spec,omitempty"`

	// Status Current status of the security group
	// Condition type `rules` indicates the status of the security group rules.
	// The status can be `applied` or `pending`.
	Status *SecurityGroupStatus `json:"status,omitempty"`
}

// SecurityGroupKind Type of the resource
type SecurityGroupKind string

// SecurityGroupRule Represents a security group rule
type SecurityGroupRule struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *SecurityGroupRuleKind    `json:"kind,omitempty"`
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`
	Spec     *SecurityGroupRuleSpec    `json:"spec,omitempty"`

	// Status Current status of the resource
	Status *Status `json:"status,omitempty"`
}

// SecurityGroupRuleKind Type of the resource
type SecurityGroupRuleKind string

// SecurityGroupRuleSource Source of the traffic. Can be a security group, CIDR range, or 'publicInternet'.
// 'publicInternet' allows explicit control over internet-facing traffic.
type SecurityGroupRuleSource struct {
	Type *SecurityGroupRuleSourceType `json:"type,omitempty"`

	// Value - For securityGroup: name of the source security group
	// - For cidr: IPv4 CIDR range
	// - For publicInternet: 'any' or a IPv4 CIDR Range
	Value *string `json:"value,omitempty"`
}

// SecurityGroupRuleSourceType defines model for SecurityGroupRuleSource.Type.
type SecurityGroupRuleSourceType string

// SecurityGroupRuleSpec defines model for SecurityGroupRuleSpec.
type SecurityGroupRuleSpec struct {
	// Description Human-readable description of the rule's purpose
	Description *string `json:"description,omitempty"`

	// Direction - ingress: Only incoming traffic is allowed
	// - egress: Only outgoing traffic is allowed
	// - bidirectional: Traffic can flow both ways
	Direction *SecurityGroupRuleSpecDirection `json:"direction,omitempty"`

	// PortRange Specific port or port range for the rule
	PortRange *PortRange `json:"portRange,omitempty"`

	// Priority Rule priority (lower number = higher priority)
	Priority *int `json:"priority,omitempty"`

	// Protocol Network protocol for the rule
	Protocol *SecurityGroupRuleSpecProtocol `json:"protocol,omitempty"`

	// Source Source of the traffic. Can be a security group, CIDR range, or 'publicInternet'.
	// 'publicInternet' allows explicit control over internet-facing traffic.
	Source *SecurityGroupRuleSource `json:"source,omitempty"`
}

// SecurityGroupRuleSpecDirection - ingress: Only incoming traffic is allowed
// - egress: Only outgoing traffic is allowed
// - bidirectional: Traffic can flow both ways
type SecurityGroupRuleSpecDirection string

// SecurityGroupRuleSpecProtocol Network protocol for the rule
type SecurityGroupRuleSpecProtocol string

// SecurityGroupSpec Specification of the security group
type SecurityGroupSpec struct {
	// Rules Network access rules defining communication between security groups and external networks.
	//
	// Rule Evaluation:
	// - Rules are processed in order of priority (lower number = higher priority)
	// - First matching rule determines the action (allow/deny)
	// - Default behavior is to deny all traffic not explicitly allowed
	Rules *[]SecurityGroupRule `json:"rules,omitempty"`
}

// SecurityGroupStatus Current status of the security group
// Condition type `rules` indicates the status of the security group rules.
// The status can be `applied` or `pending`.
type SecurityGroupStatus struct {
	Conditions *[]StatusCondition `json:"conditions,omitempty"`

	// State Generic state definition for all resources. All states are optional, but must not have more states.
	// If a provider wants to present fine granular states, please use conditions.
	State *ResourceState `json:"state,omitempty"`
}

// SkuExtensions defines model for SkuExtensions.
type SkuExtensions map[string]interface{}

// Status Current status of the resource
type Status struct {
	Conditions []StatusCondition `json:"conditions"`
}

// StatusCondition StatusCondition describes the state of a resource at a certain point.
// Conditions are provider-specific and can represent different states depending on the
// resource type and provider implementation.
type StatusCondition struct {
	// LastTransitionTime LastTransitionTime is the last time the condition transitioned from one
	// status to another. This should be when the underlying condition changed.
	// If that is not known, then using the time when the API field changed is
	// acceptable.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message A human-readable message indicating details about the transition.
	Message *string `json:"message,omitempty"`

	// Reason The reason for the condition's last transition in CamelCase.
	// The specific set of reason values is provider-specific and should be
	// documented by the provider.
	Reason *string `json:"reason,omitempty"`

	// Status Status of the condition.
	Status string `json:"status"`

	// Type Type of condition. The condition type is provider-specific and should
	// reflect the specific states relevant to your resource.
	Type string `json:"type"`
}

// Subnet A Subnet represents a logical subdivision of a LAN's IP address space.
//
// Key Network Routing Concepts:
// - Defines a range of IP addresses for compute instances
// - Supports custom default gateway configuration
// - Enables network segmentation and isolation
//
// Default Gateway Behavior:
// - 'auto': Automatically selects the first usable IP in the subnet range
// - Custom configuration allows routing through specific instances or IPs
// - Useful for implementing advanced network topologies like:
//   - Application-level firewalls
//   - Custom routing through network appliances
//   - Multi-tier network architectures
type Subnet struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *SubnetKind            `json:"kind,omitempty"`
	Metadata *ZonalResourceMetadata `json:"metadata,omitempty"`

	// Spec Specification of the subnet
	Spec *SubnetSpec `json:"spec,omitempty"`

	// Status Current status of the subnet.
	// Condition type `gateway` indicates the status of the subnet's default gateway.
	// The status can be `configured` or `unconfigured`.
	Status *SubnetStatus `json:"status,omitempty"`
}

// SubnetKind Type of the resource
type SubnetKind string

// SubnetGateway Actual default gateway configuration
type SubnetGateway struct {
	Type  *SubnetGatewayType `json:"type,omitempty"`
	Value *string            `json:"value,omitempty"`
}

// SubnetGatewayType defines model for SubnetGateway.Type.
type SubnetGatewayType string

// SubnetSpec Specification of the subnet
type SubnetSpec struct {
	Cidr *Cidr `json:"cidr,omitempty"`

	// DefaultGateway Configuration for the subnet's default gateway.
	// Provides flexibility in routing traffic.
	DefaultGateway *struct {
		Type *SubnetSpecDefaultGatewayType `json:"type,omitempty"`

		// Value - For 'instanceRef': Name of the compute instance acting as gateway
		// - For 'internalIp': Specific IP address to use as gateway
		Value *string `json:"value,omitempty"`
	} `json:"defaultGateway,omitempty"`

	// DhcpEnabled for now we allow only dhcp enabled
	DhcpEnabled *SubnetSpecDhcpEnabled `json:"dhcpEnabled,omitempty"`
	Profile     *struct {
		// NetworkSkuRef Reference to a network SKU defining bandwidth performance.
		// Allows selection of network performance tier.
		// Pattern: '^seca\.(10|100|1000)$'
		NetworkSkuRef *string `json:"networkSkuRef,omitempty"`
	} `json:"profile,omitempty"`
}

// SubnetSpecDefaultGatewayType defines model for SubnetSpec.DefaultGateway.Type.
type SubnetSpecDefaultGatewayType string

// SubnetSpecDhcpEnabled for now we allow only dhcp enabled
type SubnetSpecDhcpEnabled bool

// SubnetStatus Current status of the subnet.
// Condition type `gateway` indicates the status of the subnet's default gateway.
// The status can be `configured` or `unconfigured`.
type SubnetStatus struct {
	Conditions *[]StatusCondition `json:"conditions,omitempty"`

	// DefaultGateway Actual default gateway configuration
	DefaultGateway *SubnetGateway `json:"defaultGateway,omitempty"`
	Ipv4Range      *string        `json:"ipv4Range,omitempty"`

	// State Generic state definition for all resources. All states are optional, but must not have more states.
	// If a provider wants to present fine granular states, please use conditions.
	State *ResourceState `json:"state,omitempty"`
	Zone  *string        `json:"zone,omitempty"`
}

// ZonalResourceMetadata defines model for ZonalResourceMetadata.
type ZonalResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels map[string]interface{} `json:"labels"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Location Reference to the specific location (region/zone) where the resource is located
	Location *struct {
		Region string `json:"region"`
		Zone   string `json:"zone"`
	} `json:"location,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name string `json:"name"`
}

// Cidr defines model for cidr.
type Cidr struct {
	// Ipv4Range IPv4 address range for the subnet.
	// Must be unique within the LAN and cannot be modified after creation.
	// Example: '192.168.1.0/24'
	Ipv4Range *string `json:"ipv4Range,omitempty"`
}

// AcceptHeader defines model for acceptHeader.
type AcceptHeader string

// IfUnmodifiedSince defines model for ifUnmodifiedSince.
type IfUnmodifiedSince = time.Time

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// TenantID defines model for tenantID.
type TenantID = string

// ListNetworkQuotasParams defines parameters for ListNetworkQuotas.
type ListNetworkQuotasParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListNetworkQuotasParamsAccept `json:"Accept,omitempty"`
}

// ListNetworkQuotasParamsAccept defines parameters for ListNetworkQuotas.
type ListNetworkQuotasParamsAccept string

// CreateOrUpdateNetworkQuotaParams defines parameters for CreateOrUpdateNetworkQuota.
type CreateOrUpdateNetworkQuotaParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListNetworkSkusParams defines parameters for ListNetworkSkus.
type ListNetworkSkusParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListNetworkSkusParamsAccept `json:"Accept,omitempty"`
}

// ListNetworkSkusParamsAccept defines parameters for ListNetworkSkus.
type ListNetworkSkusParamsAccept string

// ListLANsParams defines parameters for ListLANs.
type ListLANsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListLANsParamsAccept `json:"Accept,omitempty"`
}

// ListLANsParamsAccept defines parameters for ListLANs.
type ListLANsParamsAccept string

// CreateOrUpdateLANParams defines parameters for CreateOrUpdateLAN.
type CreateOrUpdateLANParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListNicsParams defines parameters for ListNics.
type ListNicsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListNicsParamsAccept `json:"Accept,omitempty"`
}

// ListNicsParamsAccept defines parameters for ListNics.
type ListNicsParamsAccept string

// CreateOrUpdateNicParams defines parameters for CreateOrUpdateNic.
type CreateOrUpdateNicParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// DeleteNicParams defines parameters for DeleteNic.
type DeleteNicParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// GetNicParams defines parameters for GetNic.
type GetNicParams struct {
	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *GetNicParamsAccept `json:"Accept,omitempty"`
}

// GetNicParamsAccept defines parameters for GetNic.
type GetNicParamsAccept string

// ListRoutingTablesParams defines parameters for ListRoutingTables.
type ListRoutingTablesParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListRoutingTablesParamsAccept `json:"Accept,omitempty"`
}

// ListRoutingTablesParamsAccept defines parameters for ListRoutingTables.
type ListRoutingTablesParamsAccept string

// CreateOrUpdateRoutingTableParams defines parameters for CreateOrUpdateRoutingTable.
type CreateOrUpdateRoutingTableParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListSecurityGroupsParams defines parameters for ListSecurityGroups.
type ListSecurityGroupsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListSecurityGroupsParamsAccept `json:"Accept,omitempty"`
}

// ListSecurityGroupsParamsAccept defines parameters for ListSecurityGroups.
type ListSecurityGroupsParamsAccept string

// CreateOrUpdateSecurityGroupParams defines parameters for CreateOrUpdateSecurityGroup.
type CreateOrUpdateSecurityGroupParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListSubnetsParams defines parameters for ListSubnets.
type ListSubnetsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListSubnetsParamsAccept `json:"Accept,omitempty"`
}

// ListSubnetsParamsAccept defines parameters for ListSubnets.
type ListSubnetsParamsAccept string

// CreateOrUpdateSubnetParams defines parameters for CreateOrUpdateSubnet.
type CreateOrUpdateSubnetParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListPublicIPsParams defines parameters for ListPublicIPs.
type ListPublicIPsParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListPublicIPsParamsAccept `json:"Accept,omitempty"`
}

// ListPublicIPsParamsAccept defines parameters for ListPublicIPs.
type ListPublicIPsParamsAccept string

// DeletePublicIPParams defines parameters for DeletePublicIP.
type DeletePublicIPParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// PutPublicIPParams defines parameters for PutPublicIP.
type PutPublicIPParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateNetworkQuotaJSONRequestBody defines body for CreateOrUpdateNetworkQuota for application/json ContentType.
type CreateOrUpdateNetworkQuotaJSONRequestBody = ResourceQuota

// CreateOrUpdateLANJSONRequestBody defines body for CreateOrUpdateLAN for application/json ContentType.
type CreateOrUpdateLANJSONRequestBody = Lan

// CreateOrUpdateNicJSONRequestBody defines body for CreateOrUpdateNic for application/json ContentType.
type CreateOrUpdateNicJSONRequestBody = Nic

// CreateOrUpdateRoutingTableJSONRequestBody defines body for CreateOrUpdateRoutingTable for application/json ContentType.
type CreateOrUpdateRoutingTableJSONRequestBody = RoutingTable

// CreateOrUpdateSecurityGroupJSONRequestBody defines body for CreateOrUpdateSecurityGroup for application/json ContentType.
type CreateOrUpdateSecurityGroupJSONRequestBody = SecurityGroup

// CreateOrUpdateSubnetJSONRequestBody defines body for CreateOrUpdateSubnet for application/json ContentType.
type CreateOrUpdateSubnetJSONRequestBody = Subnet

// PutPublicIPJSONRequestBody defines body for PutPublicIP for application/json ContentType.
type PutPublicIPJSONRequestBody = PublicIp

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListNetworkQuotas request
	ListNetworkQuotas(ctx context.Context, id TenantID, params *ListNetworkQuotasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateNetworkQuotaWithBody request with any body
	CreateOrUpdateNetworkQuotaWithBody(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateNetworkQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateNetworkQuota(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateNetworkQuotaParams, body CreateOrUpdateNetworkQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNetworkSkus request
	ListNetworkSkus(ctx context.Context, id TenantID, params *ListNetworkSkusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkSku request
	GetNetworkSku(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLANs request
	ListLANs(ctx context.Context, id TenantID, workspace string, params *ListLANsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLAN request
	DeleteLAN(ctx context.Context, id TenantID, workspace string, lan string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLAN request
	GetLAN(ctx context.Context, id TenantID, workspace string, lan string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateLANWithBody request with any body
	CreateOrUpdateLANWithBody(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateLANParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateLAN(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateLANParams, body CreateOrUpdateLANJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNics request
	ListNics(ctx context.Context, id TenantID, workspace string, lan string, params *ListNicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateNicWithBody request with any body
	CreateOrUpdateNicWithBody(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateNicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateNic(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateNicParams, body CreateOrUpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNic request
	DeleteNic(ctx context.Context, id TenantID, workspace string, lan string, name string, params *DeleteNicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNic request
	GetNic(ctx context.Context, id TenantID, workspace string, lan string, name string, params *GetNicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRoutingTables request
	ListRoutingTables(ctx context.Context, id TenantID, workspace string, lan string, params *ListRoutingTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRoutingTable request
	DeleteRoutingTable(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoutingTable request
	GetRoutingTable(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateRoutingTableWithBody request with any body
	CreateOrUpdateRoutingTableWithBody(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateRoutingTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateRoutingTable(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateRoutingTableParams, body CreateOrUpdateRoutingTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSecurityGroups request
	ListSecurityGroups(ctx context.Context, id TenantID, workspace string, lan string, params *ListSecurityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecurityGroup request
	DeleteSecurityGroup(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecurityGroup request
	GetSecurityGroup(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateSecurityGroupWithBody request with any body
	CreateOrUpdateSecurityGroupWithBody(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSecurityGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateSecurityGroup(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSecurityGroupParams, body CreateOrUpdateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSubnets request
	ListSubnets(ctx context.Context, id TenantID, workspace string, lan string, params *ListSubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubnet request
	DeleteSubnet(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubnet request
	GetSubnet(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateSubnetWithBody request with any body
	CreateOrUpdateSubnetWithBody(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSubnetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateSubnet(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSubnetParams, body CreateOrUpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPublicIPs request
	ListPublicIPs(ctx context.Context, id TenantID, workspace string, params *ListPublicIPsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePublicIP request
	DeletePublicIP(ctx context.Context, id TenantID, workspace string, name string, params *DeletePublicIPParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicIP request
	GetPublicIP(ctx context.Context, id TenantID, workspace string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutPublicIPWithBody request with any body
	PutPublicIPWithBody(ctx context.Context, id TenantID, workspace string, name string, params *PutPublicIPParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutPublicIP(ctx context.Context, id TenantID, workspace string, name string, params *PutPublicIPParams, body PutPublicIPJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListNetworkQuotas(ctx context.Context, id TenantID, params *ListNetworkQuotasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNetworkQuotasRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateNetworkQuotaWithBody(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateNetworkQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateNetworkQuotaRequestWithBody(c.Server, id, resourceType, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateNetworkQuota(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateNetworkQuotaParams, body CreateOrUpdateNetworkQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateNetworkQuotaRequest(c.Server, id, resourceType, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNetworkSkus(ctx context.Context, id TenantID, params *ListNetworkSkusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNetworkSkusRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkSku(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkSkuRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLANs(ctx context.Context, id TenantID, workspace string, params *ListLANsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLANsRequest(c.Server, id, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLAN(ctx context.Context, id TenantID, workspace string, lan string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLANRequest(c.Server, id, workspace, lan)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLAN(ctx context.Context, id TenantID, workspace string, lan string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLANRequest(c.Server, id, workspace, lan)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateLANWithBody(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateLANParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateLANRequestWithBody(c.Server, id, workspace, lan, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateLAN(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateLANParams, body CreateOrUpdateLANJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateLANRequest(c.Server, id, workspace, lan, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNics(ctx context.Context, id TenantID, workspace string, lan string, params *ListNicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNicsRequest(c.Server, id, workspace, lan, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateNicWithBody(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateNicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateNicRequestWithBody(c.Server, id, workspace, lan, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateNic(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateNicParams, body CreateOrUpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateNicRequest(c.Server, id, workspace, lan, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNic(ctx context.Context, id TenantID, workspace string, lan string, name string, params *DeleteNicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNicRequest(c.Server, id, workspace, lan, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNic(ctx context.Context, id TenantID, workspace string, lan string, name string, params *GetNicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNicRequest(c.Server, id, workspace, lan, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRoutingTables(ctx context.Context, id TenantID, workspace string, lan string, params *ListRoutingTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRoutingTablesRequest(c.Server, id, workspace, lan, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoutingTable(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoutingTableRequest(c.Server, id, workspace, lan, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoutingTable(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoutingTableRequest(c.Server, id, workspace, lan, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateRoutingTableWithBody(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateRoutingTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateRoutingTableRequestWithBody(c.Server, id, workspace, lan, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateRoutingTable(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateRoutingTableParams, body CreateOrUpdateRoutingTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateRoutingTableRequest(c.Server, id, workspace, lan, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSecurityGroups(ctx context.Context, id TenantID, workspace string, lan string, params *ListSecurityGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSecurityGroupsRequest(c.Server, id, workspace, lan, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityGroup(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityGroupRequest(c.Server, id, workspace, lan, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecurityGroup(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecurityGroupRequest(c.Server, id, workspace, lan, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateSecurityGroupWithBody(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSecurityGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateSecurityGroupRequestWithBody(c.Server, id, workspace, lan, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateSecurityGroup(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSecurityGroupParams, body CreateOrUpdateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateSecurityGroupRequest(c.Server, id, workspace, lan, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSubnets(ctx context.Context, id TenantID, workspace string, lan string, params *ListSubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSubnetsRequest(c.Server, id, workspace, lan, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubnet(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubnetRequest(c.Server, id, workspace, lan, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubnet(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubnetRequest(c.Server, id, workspace, lan, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateSubnetWithBody(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSubnetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateSubnetRequestWithBody(c.Server, id, workspace, lan, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateSubnet(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSubnetParams, body CreateOrUpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateSubnetRequest(c.Server, id, workspace, lan, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPublicIPs(ctx context.Context, id TenantID, workspace string, params *ListPublicIPsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPublicIPsRequest(c.Server, id, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePublicIP(ctx context.Context, id TenantID, workspace string, name string, params *DeletePublicIPParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePublicIPRequest(c.Server, id, workspace, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicIP(ctx context.Context, id TenantID, workspace string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicIPRequest(c.Server, id, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPublicIPWithBody(ctx context.Context, id TenantID, workspace string, name string, params *PutPublicIPParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPublicIPRequestWithBody(c.Server, id, workspace, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPublicIP(ctx context.Context, id TenantID, workspace string, name string, params *PutPublicIPParams, body PutPublicIPJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPublicIPRequest(c.Server, id, workspace, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListNetworkQuotasRequest generates requests for ListNetworkQuotas
func NewListNetworkQuotasRequest(server string, id TenantID, params *ListNetworkQuotasParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/quotas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewCreateOrUpdateNetworkQuotaRequest calls the generic CreateOrUpdateNetworkQuota builder with application/json body
func NewCreateOrUpdateNetworkQuotaRequest(server string, id TenantID, resourceType string, params *CreateOrUpdateNetworkQuotaParams, body CreateOrUpdateNetworkQuotaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateNetworkQuotaRequestWithBody(server, id, resourceType, params, "application/json", bodyReader)
}

// NewCreateOrUpdateNetworkQuotaRequestWithBody generates requests for CreateOrUpdateNetworkQuota with any type of body
func NewCreateOrUpdateNetworkQuotaRequestWithBody(server string, id TenantID, resourceType string, params *CreateOrUpdateNetworkQuotaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourceType", runtime.ParamLocationPath, resourceType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/quotas/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewListNetworkSkusRequest generates requests for ListNetworkSkus
func NewListNetworkSkusRequest(server string, id TenantID, params *ListNetworkSkusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/skus", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewGetNetworkSkuRequest generates requests for GetNetworkSku
func NewGetNetworkSkuRequest(server string, id TenantID, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/skus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLANsRequest generates requests for ListLANs
func NewListLANsRequest(server string, id TenantID, workspace string, params *ListLANsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteLANRequest generates requests for DeleteLAN
func NewDeleteLANRequest(server string, id TenantID, workspace string, lan string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLANRequest generates requests for GetLAN
func NewGetLANRequest(server string, id TenantID, workspace string, lan string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateLANRequest calls the generic CreateOrUpdateLAN builder with application/json body
func NewCreateOrUpdateLANRequest(server string, id TenantID, workspace string, lan string, params *CreateOrUpdateLANParams, body CreateOrUpdateLANJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateLANRequestWithBody(server, id, workspace, lan, params, "application/json", bodyReader)
}

// NewCreateOrUpdateLANRequestWithBody generates requests for CreateOrUpdateLAN with any type of body
func NewCreateOrUpdateLANRequestWithBody(server string, id TenantID, workspace string, lan string, params *CreateOrUpdateLANParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewListNicsRequest generates requests for ListNics
func NewListNicsRequest(server string, id TenantID, workspace string, lan string, params *ListNicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/nics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewCreateOrUpdateNicRequest calls the generic CreateOrUpdateNic builder with application/json body
func NewCreateOrUpdateNicRequest(server string, id TenantID, workspace string, lan string, params *CreateOrUpdateNicParams, body CreateOrUpdateNicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateNicRequestWithBody(server, id, workspace, lan, params, "application/json", bodyReader)
}

// NewCreateOrUpdateNicRequestWithBody generates requests for CreateOrUpdateNic with any type of body
func NewCreateOrUpdateNicRequestWithBody(server string, id TenantID, workspace string, lan string, params *CreateOrUpdateNicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/nics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteNicRequest generates requests for DeleteNic
func NewDeleteNicRequest(server string, id TenantID, workspace string, lan string, name string, params *DeleteNicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/nics/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewGetNicRequest generates requests for GetNic
func NewGetNicRequest(server string, id TenantID, workspace string, lan string, name string, params *GetNicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/nics/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewListRoutingTablesRequest generates requests for ListRoutingTables
func NewListRoutingTablesRequest(server string, id TenantID, workspace string, lan string, params *ListRoutingTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/routing-tables", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteRoutingTableRequest generates requests for DeleteRoutingTable
func NewDeleteRoutingTableRequest(server string, id TenantID, workspace string, lan string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/routing-tables/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoutingTableRequest generates requests for GetRoutingTable
func NewGetRoutingTableRequest(server string, id TenantID, workspace string, lan string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/routing-tables/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateRoutingTableRequest calls the generic CreateOrUpdateRoutingTable builder with application/json body
func NewCreateOrUpdateRoutingTableRequest(server string, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateRoutingTableParams, body CreateOrUpdateRoutingTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateRoutingTableRequestWithBody(server, id, workspace, lan, name, params, "application/json", bodyReader)
}

// NewCreateOrUpdateRoutingTableRequestWithBody generates requests for CreateOrUpdateRoutingTable with any type of body
func NewCreateOrUpdateRoutingTableRequestWithBody(server string, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateRoutingTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/routing-tables/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewListSecurityGroupsRequest generates requests for ListSecurityGroups
func NewListSecurityGroupsRequest(server string, id TenantID, workspace string, lan string, params *ListSecurityGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/security-groups", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteSecurityGroupRequest generates requests for DeleteSecurityGroup
func NewDeleteSecurityGroupRequest(server string, id TenantID, workspace string, lan string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/security-groups/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecurityGroupRequest generates requests for GetSecurityGroup
func NewGetSecurityGroupRequest(server string, id TenantID, workspace string, lan string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/security-groups/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateSecurityGroupRequest calls the generic CreateOrUpdateSecurityGroup builder with application/json body
func NewCreateOrUpdateSecurityGroupRequest(server string, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSecurityGroupParams, body CreateOrUpdateSecurityGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateSecurityGroupRequestWithBody(server, id, workspace, lan, name, params, "application/json", bodyReader)
}

// NewCreateOrUpdateSecurityGroupRequestWithBody generates requests for CreateOrUpdateSecurityGroup with any type of body
func NewCreateOrUpdateSecurityGroupRequestWithBody(server string, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSecurityGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/security-groups/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewListSubnetsRequest generates requests for ListSubnets
func NewListSubnetsRequest(server string, id TenantID, workspace string, lan string, params *ListSubnetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/subnets", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteSubnetRequest generates requests for DeleteSubnet
func NewDeleteSubnetRequest(server string, id TenantID, workspace string, lan string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/subnets/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubnetRequest generates requests for GetSubnet
func NewGetSubnetRequest(server string, id TenantID, workspace string, lan string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/subnets/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateSubnetRequest calls the generic CreateOrUpdateSubnet builder with application/json body
func NewCreateOrUpdateSubnetRequest(server string, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSubnetParams, body CreateOrUpdateSubnetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateSubnetRequestWithBody(server, id, workspace, lan, name, params, "application/json", bodyReader)
}

// NewCreateOrUpdateSubnetRequestWithBody generates requests for CreateOrUpdateSubnet with any type of body
func NewCreateOrUpdateSubnetRequestWithBody(server string, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSubnetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "lan", runtime.ParamLocationPath, lan)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/lans/%s/subnets/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewListPublicIPsRequest generates requests for ListPublicIPs
func NewListPublicIPsRequest(server string, id TenantID, workspace string, params *ListPublicIPsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/public-ips", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeletePublicIPRequest generates requests for DeletePublicIP
func NewDeletePublicIPRequest(server string, id TenantID, workspace string, name string, params *DeletePublicIPParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/public-ips/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewGetPublicIPRequest generates requests for GetPublicIP
func NewGetPublicIPRequest(server string, id TenantID, workspace string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/public-ips/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutPublicIPRequest calls the generic PutPublicIP builder with application/json body
func NewPutPublicIPRequest(server string, id TenantID, workspace string, name string, params *PutPublicIPParams, body PutPublicIPJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutPublicIPRequestWithBody(server, id, workspace, name, params, "application/json", bodyReader)
}

// NewPutPublicIPRequestWithBody generates requests for PutPublicIP with any type of body
func NewPutPublicIPRequestWithBody(server string, id TenantID, workspace string, name string, params *PutPublicIPParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/public-ips/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListNetworkQuotasWithResponse request
	ListNetworkQuotasWithResponse(ctx context.Context, id TenantID, params *ListNetworkQuotasParams, reqEditors ...RequestEditorFn) (*ListNetworkQuotasResponse, error)

	// CreateOrUpdateNetworkQuotaWithBodyWithResponse request with any body
	CreateOrUpdateNetworkQuotaWithBodyWithResponse(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateNetworkQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateNetworkQuotaResponse, error)

	CreateOrUpdateNetworkQuotaWithResponse(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateNetworkQuotaParams, body CreateOrUpdateNetworkQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateNetworkQuotaResponse, error)

	// ListNetworkSkusWithResponse request
	ListNetworkSkusWithResponse(ctx context.Context, id TenantID, params *ListNetworkSkusParams, reqEditors ...RequestEditorFn) (*ListNetworkSkusResponse, error)

	// GetNetworkSkuWithResponse request
	GetNetworkSkuWithResponse(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*GetNetworkSkuResponse, error)

	// ListLANsWithResponse request
	ListLANsWithResponse(ctx context.Context, id TenantID, workspace string, params *ListLANsParams, reqEditors ...RequestEditorFn) (*ListLANsResponse, error)

	// DeleteLANWithResponse request
	DeleteLANWithResponse(ctx context.Context, id TenantID, workspace string, lan string, reqEditors ...RequestEditorFn) (*DeleteLANResponse, error)

	// GetLANWithResponse request
	GetLANWithResponse(ctx context.Context, id TenantID, workspace string, lan string, reqEditors ...RequestEditorFn) (*GetLANResponse, error)

	// CreateOrUpdateLANWithBodyWithResponse request with any body
	CreateOrUpdateLANWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateLANParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateLANResponse, error)

	CreateOrUpdateLANWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateLANParams, body CreateOrUpdateLANJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateLANResponse, error)

	// ListNicsWithResponse request
	ListNicsWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *ListNicsParams, reqEditors ...RequestEditorFn) (*ListNicsResponse, error)

	// CreateOrUpdateNicWithBodyWithResponse request with any body
	CreateOrUpdateNicWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateNicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateNicResponse, error)

	CreateOrUpdateNicWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateNicParams, body CreateOrUpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateNicResponse, error)

	// DeleteNicWithResponse request
	DeleteNicWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *DeleteNicParams, reqEditors ...RequestEditorFn) (*DeleteNicResponse, error)

	// GetNicWithResponse request
	GetNicWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *GetNicParams, reqEditors ...RequestEditorFn) (*GetNicResponse, error)

	// ListRoutingTablesWithResponse request
	ListRoutingTablesWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *ListRoutingTablesParams, reqEditors ...RequestEditorFn) (*ListRoutingTablesResponse, error)

	// DeleteRoutingTableWithResponse request
	DeleteRoutingTableWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*DeleteRoutingTableResponse, error)

	// GetRoutingTableWithResponse request
	GetRoutingTableWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*GetRoutingTableResponse, error)

	// CreateOrUpdateRoutingTableWithBodyWithResponse request with any body
	CreateOrUpdateRoutingTableWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateRoutingTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoutingTableResponse, error)

	CreateOrUpdateRoutingTableWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateRoutingTableParams, body CreateOrUpdateRoutingTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoutingTableResponse, error)

	// ListSecurityGroupsWithResponse request
	ListSecurityGroupsWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *ListSecurityGroupsParams, reqEditors ...RequestEditorFn) (*ListSecurityGroupsResponse, error)

	// DeleteSecurityGroupWithResponse request
	DeleteSecurityGroupWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupResponse, error)

	// GetSecurityGroupWithResponse request
	GetSecurityGroupWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*GetSecurityGroupResponse, error)

	// CreateOrUpdateSecurityGroupWithBodyWithResponse request with any body
	CreateOrUpdateSecurityGroupWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSecurityGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateSecurityGroupResponse, error)

	CreateOrUpdateSecurityGroupWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSecurityGroupParams, body CreateOrUpdateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateSecurityGroupResponse, error)

	// ListSubnetsWithResponse request
	ListSubnetsWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *ListSubnetsParams, reqEditors ...RequestEditorFn) (*ListSubnetsResponse, error)

	// DeleteSubnetWithResponse request
	DeleteSubnetWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error)

	// GetSubnetWithResponse request
	GetSubnetWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*GetSubnetResponse, error)

	// CreateOrUpdateSubnetWithBodyWithResponse request with any body
	CreateOrUpdateSubnetWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSubnetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateSubnetResponse, error)

	CreateOrUpdateSubnetWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSubnetParams, body CreateOrUpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateSubnetResponse, error)

	// ListPublicIPsWithResponse request
	ListPublicIPsWithResponse(ctx context.Context, id TenantID, workspace string, params *ListPublicIPsParams, reqEditors ...RequestEditorFn) (*ListPublicIPsResponse, error)

	// DeletePublicIPWithResponse request
	DeletePublicIPWithResponse(ctx context.Context, id TenantID, workspace string, name string, params *DeletePublicIPParams, reqEditors ...RequestEditorFn) (*DeletePublicIPResponse, error)

	// GetPublicIPWithResponse request
	GetPublicIPWithResponse(ctx context.Context, id TenantID, workspace string, name string, reqEditors ...RequestEditorFn) (*GetPublicIPResponse, error)

	// PutPublicIPWithBodyWithResponse request with any body
	PutPublicIPWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, name string, params *PutPublicIPParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPublicIPResponse, error)

	PutPublicIPWithResponse(ctx context.Context, id TenantID, workspace string, name string, params *PutPublicIPParams, body PutPublicIPJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPublicIPResponse, error)
}

type ListNetworkQuotasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]ResourceQuota  `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListNetworkQuotasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNetworkQuotasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateNetworkQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateNetworkQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateNetworkQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNetworkSkusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]NetworkSku     `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListNetworkSkusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNetworkSkusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkSkuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkSku
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetNetworkSkuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkSkuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLANsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]Lan            `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListLANsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLANsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLANResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteLANResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLANResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLANResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Lan
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetLANResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLANResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateLANResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateLANResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateLANResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]Nic            `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListNicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateNicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Nic
	JSON201      *Nic
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Nic
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetNicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRoutingTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]RoutingTable   `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListRoutingTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRoutingTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoutingTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteRoutingTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoutingTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoutingTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoutingTable
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetRoutingTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoutingTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateRoutingTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateRoutingTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateRoutingTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSecurityGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]SecurityGroup  `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListSecurityGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSecurityGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecurityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteSecurityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecurityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecurityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityGroup
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetSecurityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecurityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateSecurityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateSecurityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateSecurityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSubnetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]Subnet         `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListSubnetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSubnetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubnetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubnetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Subnet
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateSubnetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateSubnetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateSubnetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPublicIPsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]PublicIp       `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListPublicIPsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPublicIPsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePublicIPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeletePublicIPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePublicIPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicIPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicIp
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetPublicIPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicIPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutPublicIPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicIp
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r PutPublicIPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutPublicIPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListNetworkQuotasWithResponse request returning *ListNetworkQuotasResponse
func (c *ClientWithResponses) ListNetworkQuotasWithResponse(ctx context.Context, id TenantID, params *ListNetworkQuotasParams, reqEditors ...RequestEditorFn) (*ListNetworkQuotasResponse, error) {
	rsp, err := c.ListNetworkQuotas(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNetworkQuotasResponse(rsp)
}

// CreateOrUpdateNetworkQuotaWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateNetworkQuotaResponse
func (c *ClientWithResponses) CreateOrUpdateNetworkQuotaWithBodyWithResponse(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateNetworkQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateNetworkQuotaResponse, error) {
	rsp, err := c.CreateOrUpdateNetworkQuotaWithBody(ctx, id, resourceType, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateNetworkQuotaResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateNetworkQuotaWithResponse(ctx context.Context, id TenantID, resourceType string, params *CreateOrUpdateNetworkQuotaParams, body CreateOrUpdateNetworkQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateNetworkQuotaResponse, error) {
	rsp, err := c.CreateOrUpdateNetworkQuota(ctx, id, resourceType, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateNetworkQuotaResponse(rsp)
}

// ListNetworkSkusWithResponse request returning *ListNetworkSkusResponse
func (c *ClientWithResponses) ListNetworkSkusWithResponse(ctx context.Context, id TenantID, params *ListNetworkSkusParams, reqEditors ...RequestEditorFn) (*ListNetworkSkusResponse, error) {
	rsp, err := c.ListNetworkSkus(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNetworkSkusResponse(rsp)
}

// GetNetworkSkuWithResponse request returning *GetNetworkSkuResponse
func (c *ClientWithResponses) GetNetworkSkuWithResponse(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*GetNetworkSkuResponse, error) {
	rsp, err := c.GetNetworkSku(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkSkuResponse(rsp)
}

// ListLANsWithResponse request returning *ListLANsResponse
func (c *ClientWithResponses) ListLANsWithResponse(ctx context.Context, id TenantID, workspace string, params *ListLANsParams, reqEditors ...RequestEditorFn) (*ListLANsResponse, error) {
	rsp, err := c.ListLANs(ctx, id, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLANsResponse(rsp)
}

// DeleteLANWithResponse request returning *DeleteLANResponse
func (c *ClientWithResponses) DeleteLANWithResponse(ctx context.Context, id TenantID, workspace string, lan string, reqEditors ...RequestEditorFn) (*DeleteLANResponse, error) {
	rsp, err := c.DeleteLAN(ctx, id, workspace, lan, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLANResponse(rsp)
}

// GetLANWithResponse request returning *GetLANResponse
func (c *ClientWithResponses) GetLANWithResponse(ctx context.Context, id TenantID, workspace string, lan string, reqEditors ...RequestEditorFn) (*GetLANResponse, error) {
	rsp, err := c.GetLAN(ctx, id, workspace, lan, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLANResponse(rsp)
}

// CreateOrUpdateLANWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateLANResponse
func (c *ClientWithResponses) CreateOrUpdateLANWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateLANParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateLANResponse, error) {
	rsp, err := c.CreateOrUpdateLANWithBody(ctx, id, workspace, lan, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateLANResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateLANWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateLANParams, body CreateOrUpdateLANJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateLANResponse, error) {
	rsp, err := c.CreateOrUpdateLAN(ctx, id, workspace, lan, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateLANResponse(rsp)
}

// ListNicsWithResponse request returning *ListNicsResponse
func (c *ClientWithResponses) ListNicsWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *ListNicsParams, reqEditors ...RequestEditorFn) (*ListNicsResponse, error) {
	rsp, err := c.ListNics(ctx, id, workspace, lan, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNicsResponse(rsp)
}

// CreateOrUpdateNicWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateNicResponse
func (c *ClientWithResponses) CreateOrUpdateNicWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateNicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateNicResponse, error) {
	rsp, err := c.CreateOrUpdateNicWithBody(ctx, id, workspace, lan, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateNicResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateNicWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *CreateOrUpdateNicParams, body CreateOrUpdateNicJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateNicResponse, error) {
	rsp, err := c.CreateOrUpdateNic(ctx, id, workspace, lan, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateNicResponse(rsp)
}

// DeleteNicWithResponse request returning *DeleteNicResponse
func (c *ClientWithResponses) DeleteNicWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *DeleteNicParams, reqEditors ...RequestEditorFn) (*DeleteNicResponse, error) {
	rsp, err := c.DeleteNic(ctx, id, workspace, lan, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNicResponse(rsp)
}

// GetNicWithResponse request returning *GetNicResponse
func (c *ClientWithResponses) GetNicWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *GetNicParams, reqEditors ...RequestEditorFn) (*GetNicResponse, error) {
	rsp, err := c.GetNic(ctx, id, workspace, lan, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNicResponse(rsp)
}

// ListRoutingTablesWithResponse request returning *ListRoutingTablesResponse
func (c *ClientWithResponses) ListRoutingTablesWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *ListRoutingTablesParams, reqEditors ...RequestEditorFn) (*ListRoutingTablesResponse, error) {
	rsp, err := c.ListRoutingTables(ctx, id, workspace, lan, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRoutingTablesResponse(rsp)
}

// DeleteRoutingTableWithResponse request returning *DeleteRoutingTableResponse
func (c *ClientWithResponses) DeleteRoutingTableWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*DeleteRoutingTableResponse, error) {
	rsp, err := c.DeleteRoutingTable(ctx, id, workspace, lan, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoutingTableResponse(rsp)
}

// GetRoutingTableWithResponse request returning *GetRoutingTableResponse
func (c *ClientWithResponses) GetRoutingTableWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*GetRoutingTableResponse, error) {
	rsp, err := c.GetRoutingTable(ctx, id, workspace, lan, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoutingTableResponse(rsp)
}

// CreateOrUpdateRoutingTableWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateRoutingTableResponse
func (c *ClientWithResponses) CreateOrUpdateRoutingTableWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateRoutingTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoutingTableResponse, error) {
	rsp, err := c.CreateOrUpdateRoutingTableWithBody(ctx, id, workspace, lan, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateRoutingTableResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateRoutingTableWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateRoutingTableParams, body CreateOrUpdateRoutingTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoutingTableResponse, error) {
	rsp, err := c.CreateOrUpdateRoutingTable(ctx, id, workspace, lan, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateRoutingTableResponse(rsp)
}

// ListSecurityGroupsWithResponse request returning *ListSecurityGroupsResponse
func (c *ClientWithResponses) ListSecurityGroupsWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *ListSecurityGroupsParams, reqEditors ...RequestEditorFn) (*ListSecurityGroupsResponse, error) {
	rsp, err := c.ListSecurityGroups(ctx, id, workspace, lan, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSecurityGroupsResponse(rsp)
}

// DeleteSecurityGroupWithResponse request returning *DeleteSecurityGroupResponse
func (c *ClientWithResponses) DeleteSecurityGroupWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*DeleteSecurityGroupResponse, error) {
	rsp, err := c.DeleteSecurityGroup(ctx, id, workspace, lan, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityGroupResponse(rsp)
}

// GetSecurityGroupWithResponse request returning *GetSecurityGroupResponse
func (c *ClientWithResponses) GetSecurityGroupWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*GetSecurityGroupResponse, error) {
	rsp, err := c.GetSecurityGroup(ctx, id, workspace, lan, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecurityGroupResponse(rsp)
}

// CreateOrUpdateSecurityGroupWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateSecurityGroupResponse
func (c *ClientWithResponses) CreateOrUpdateSecurityGroupWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSecurityGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateSecurityGroupResponse, error) {
	rsp, err := c.CreateOrUpdateSecurityGroupWithBody(ctx, id, workspace, lan, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateSecurityGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateSecurityGroupWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSecurityGroupParams, body CreateOrUpdateSecurityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateSecurityGroupResponse, error) {
	rsp, err := c.CreateOrUpdateSecurityGroup(ctx, id, workspace, lan, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateSecurityGroupResponse(rsp)
}

// ListSubnetsWithResponse request returning *ListSubnetsResponse
func (c *ClientWithResponses) ListSubnetsWithResponse(ctx context.Context, id TenantID, workspace string, lan string, params *ListSubnetsParams, reqEditors ...RequestEditorFn) (*ListSubnetsResponse, error) {
	rsp, err := c.ListSubnets(ctx, id, workspace, lan, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSubnetsResponse(rsp)
}

// DeleteSubnetWithResponse request returning *DeleteSubnetResponse
func (c *ClientWithResponses) DeleteSubnetWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*DeleteSubnetResponse, error) {
	rsp, err := c.DeleteSubnet(ctx, id, workspace, lan, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubnetResponse(rsp)
}

// GetSubnetWithResponse request returning *GetSubnetResponse
func (c *ClientWithResponses) GetSubnetWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, reqEditors ...RequestEditorFn) (*GetSubnetResponse, error) {
	rsp, err := c.GetSubnet(ctx, id, workspace, lan, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubnetResponse(rsp)
}

// CreateOrUpdateSubnetWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateSubnetResponse
func (c *ClientWithResponses) CreateOrUpdateSubnetWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSubnetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateSubnetResponse, error) {
	rsp, err := c.CreateOrUpdateSubnetWithBody(ctx, id, workspace, lan, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateSubnetResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateSubnetWithResponse(ctx context.Context, id TenantID, workspace string, lan string, name string, params *CreateOrUpdateSubnetParams, body CreateOrUpdateSubnetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateSubnetResponse, error) {
	rsp, err := c.CreateOrUpdateSubnet(ctx, id, workspace, lan, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateSubnetResponse(rsp)
}

// ListPublicIPsWithResponse request returning *ListPublicIPsResponse
func (c *ClientWithResponses) ListPublicIPsWithResponse(ctx context.Context, id TenantID, workspace string, params *ListPublicIPsParams, reqEditors ...RequestEditorFn) (*ListPublicIPsResponse, error) {
	rsp, err := c.ListPublicIPs(ctx, id, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPublicIPsResponse(rsp)
}

// DeletePublicIPWithResponse request returning *DeletePublicIPResponse
func (c *ClientWithResponses) DeletePublicIPWithResponse(ctx context.Context, id TenantID, workspace string, name string, params *DeletePublicIPParams, reqEditors ...RequestEditorFn) (*DeletePublicIPResponse, error) {
	rsp, err := c.DeletePublicIP(ctx, id, workspace, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePublicIPResponse(rsp)
}

// GetPublicIPWithResponse request returning *GetPublicIPResponse
func (c *ClientWithResponses) GetPublicIPWithResponse(ctx context.Context, id TenantID, workspace string, name string, reqEditors ...RequestEditorFn) (*GetPublicIPResponse, error) {
	rsp, err := c.GetPublicIP(ctx, id, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicIPResponse(rsp)
}

// PutPublicIPWithBodyWithResponse request with arbitrary body returning *PutPublicIPResponse
func (c *ClientWithResponses) PutPublicIPWithBodyWithResponse(ctx context.Context, id TenantID, workspace string, name string, params *PutPublicIPParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPublicIPResponse, error) {
	rsp, err := c.PutPublicIPWithBody(ctx, id, workspace, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPublicIPResponse(rsp)
}

func (c *ClientWithResponses) PutPublicIPWithResponse(ctx context.Context, id TenantID, workspace string, name string, params *PutPublicIPParams, body PutPublicIPJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPublicIPResponse, error) {
	rsp, err := c.PutPublicIP(ctx, id, workspace, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPublicIPResponse(rsp)
}

// ParseListNetworkQuotasResponse parses an HTTP response from a ListNetworkQuotasWithResponse call
func ParseListNetworkQuotasResponse(rsp *http.Response) (*ListNetworkQuotasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNetworkQuotasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]ResourceQuota  `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateNetworkQuotaResponse parses an HTTP response from a CreateOrUpdateNetworkQuotaWithResponse call
func ParseCreateOrUpdateNetworkQuotaResponse(rsp *http.Response) (*CreateOrUpdateNetworkQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateNetworkQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListNetworkSkusResponse parses an HTTP response from a ListNetworkSkusWithResponse call
func ParseListNetworkSkusResponse(rsp *http.Response) (*ListNetworkSkusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNetworkSkusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]NetworkSku     `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNetworkSkuResponse parses an HTTP response from a GetNetworkSkuWithResponse call
func ParseGetNetworkSkuResponse(rsp *http.Response) (*GetNetworkSkuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkSkuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkSku
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListLANsResponse parses an HTTP response from a ListLANsWithResponse call
func ParseListLANsResponse(rsp *http.Response) (*ListLANsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLANsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]Lan            `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLANResponse parses an HTTP response from a DeleteLANWithResponse call
func ParseDeleteLANResponse(rsp *http.Response) (*DeleteLANResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLANResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLANResponse parses an HTTP response from a GetLANWithResponse call
func ParseGetLANResponse(rsp *http.Response) (*GetLANResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLANResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Lan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateLANResponse parses an HTTP response from a CreateOrUpdateLANWithResponse call
func ParseCreateOrUpdateLANResponse(rsp *http.Response) (*CreateOrUpdateLANResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateLANResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListNicsResponse parses an HTTP response from a ListNicsWithResponse call
func ParseListNicsResponse(rsp *http.Response) (*ListNicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]Nic            `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateNicResponse parses an HTTP response from a CreateOrUpdateNicWithResponse call
func ParseCreateOrUpdateNicResponse(rsp *http.Response) (*CreateOrUpdateNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nic
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Nic
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNicResponse parses an HTTP response from a DeleteNicWithResponse call
func ParseDeleteNicResponse(rsp *http.Response) (*DeleteNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNicResponse parses an HTTP response from a GetNicWithResponse call
func ParseGetNicResponse(rsp *http.Response) (*GetNicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nic
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRoutingTablesResponse parses an HTTP response from a ListRoutingTablesWithResponse call
func ParseListRoutingTablesResponse(rsp *http.Response) (*ListRoutingTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRoutingTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]RoutingTable   `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRoutingTableResponse parses an HTTP response from a DeleteRoutingTableWithResponse call
func ParseDeleteRoutingTableResponse(rsp *http.Response) (*DeleteRoutingTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoutingTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRoutingTableResponse parses an HTTP response from a GetRoutingTableWithResponse call
func ParseGetRoutingTableResponse(rsp *http.Response) (*GetRoutingTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoutingTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoutingTable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateRoutingTableResponse parses an HTTP response from a CreateOrUpdateRoutingTableWithResponse call
func ParseCreateOrUpdateRoutingTableResponse(rsp *http.Response) (*CreateOrUpdateRoutingTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateRoutingTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSecurityGroupsResponse parses an HTTP response from a ListSecurityGroupsWithResponse call
func ParseListSecurityGroupsResponse(rsp *http.Response) (*ListSecurityGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSecurityGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]SecurityGroup  `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSecurityGroupResponse parses an HTTP response from a DeleteSecurityGroupWithResponse call
func ParseDeleteSecurityGroupResponse(rsp *http.Response) (*DeleteSecurityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecurityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSecurityGroupResponse parses an HTTP response from a GetSecurityGroupWithResponse call
func ParseGetSecurityGroupResponse(rsp *http.Response) (*GetSecurityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecurityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateSecurityGroupResponse parses an HTTP response from a CreateOrUpdateSecurityGroupWithResponse call
func ParseCreateOrUpdateSecurityGroupResponse(rsp *http.Response) (*CreateOrUpdateSecurityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateSecurityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSubnetsResponse parses an HTTP response from a ListSubnetsWithResponse call
func ParseListSubnetsResponse(rsp *http.Response) (*ListSubnetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSubnetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]Subnet         `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSubnetResponse parses an HTTP response from a DeleteSubnetWithResponse call
func ParseDeleteSubnetResponse(rsp *http.Response) (*DeleteSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSubnetResponse parses an HTTP response from a GetSubnetWithResponse call
func ParseGetSubnetResponse(rsp *http.Response) (*GetSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Subnet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateSubnetResponse parses an HTTP response from a CreateOrUpdateSubnetWithResponse call
func ParseCreateOrUpdateSubnetResponse(rsp *http.Response) (*CreateOrUpdateSubnetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateSubnetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPublicIPsResponse parses an HTTP response from a ListPublicIPsWithResponse call
func ParseListPublicIPsResponse(rsp *http.Response) (*ListPublicIPsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPublicIPsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]PublicIp       `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePublicIPResponse parses an HTTP response from a DeletePublicIPWithResponse call
func ParseDeletePublicIPResponse(rsp *http.Response) (*DeletePublicIPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePublicIPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPublicIPResponse parses an HTTP response from a GetPublicIPWithResponse call
func ParseGetPublicIPResponse(rsp *http.Response) (*GetPublicIPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicIPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicIp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutPublicIPResponse parses an HTTP response from a PutPublicIPWithResponse call
func ParsePutPublicIPResponse(rsp *http.Response) (*PutPublicIPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutPublicIPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicIp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List current Network Provider Resource Quotas
	// (GET /v1/tenants/{id}/quotas)
	ListNetworkQuotas(w http.ResponseWriter, r *http.Request, id TenantID, params ListNetworkQuotasParams)
	// Create or update the resource quota for the Network Resource Provider
	// (PUT /v1/tenants/{id}/quotas/{resourceType})
	CreateOrUpdateNetworkQuota(w http.ResponseWriter, r *http.Request, id TenantID, resourceType string, params CreateOrUpdateNetworkQuotaParams)
	// List available network SKUs
	// (GET /v1/tenants/{id}/skus)
	ListNetworkSkus(w http.ResponseWriter, r *http.Request, id TenantID, params ListNetworkSkusParams)
	// Get details of a specific network SKU
	// (GET /v1/tenants/{id}/skus/{name})
	GetNetworkSku(w http.ResponseWriter, r *http.Request, id TenantID, name string)
	// List all LANs
	// (GET /v1/tenants/{id}/workspaces/{workspace}/lans)
	ListLANs(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, params ListLANsParams)
	// Delete a specific LAN
	// (DELETE /v1/tenants/{id}/workspaces/{workspace}/lans/{lan})
	DeleteLAN(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string)
	// Get a specific LAN
	// (GET /v1/tenants/{id}/workspaces/{workspace}/lans/{lan})
	GetLAN(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string)
	// Create or update a specific LAN
	// (PUT /v1/tenants/{id}/workspaces/{workspace}/lans/{lan})
	CreateOrUpdateLAN(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, params CreateOrUpdateLANParams)
	// List all NICs in a LAN
	// (GET /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/nics)
	ListNics(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, params ListNicsParams)
	// Create or update a NIC
	// (PUT /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/nics)
	CreateOrUpdateNic(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, params CreateOrUpdateNicParams)
	// Delete a NIC
	// (DELETE /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/nics/{name})
	DeleteNic(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, name string, params DeleteNicParams)
	// Get a specific NIC
	// (GET /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/nics/{name})
	GetNic(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, name string, params GetNicParams)
	// List all routing tables for a LAN
	// (GET /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/routing-tables)
	ListRoutingTables(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, params ListRoutingTablesParams)
	// Delete a routing table
	// (DELETE /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/routing-tables/{name})
	DeleteRoutingTable(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, name string)
	// Get a specific routing table
	// (GET /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/routing-tables/{name})
	GetRoutingTable(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, name string)
	// Create or update a routing table
	// (PUT /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/routing-tables/{name})
	CreateOrUpdateRoutingTable(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, name string, params CreateOrUpdateRoutingTableParams)
	// List all security groups in a LAN
	// (GET /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/security-groups)
	ListSecurityGroups(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, params ListSecurityGroupsParams)
	// Delete a specific security group in a LAN
	// (DELETE /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/security-groups/{name})
	DeleteSecurityGroup(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, name string)
	// Get a specific security group in a LAN
	// (GET /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/security-groups/{name})
	GetSecurityGroup(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, name string)
	// Create or update a specific security group in a LAN
	// (PUT /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/security-groups/{name})
	CreateOrUpdateSecurityGroup(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, name string, params CreateOrUpdateSecurityGroupParams)
	// List all subnets in a LAN
	// (GET /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/subnets)
	ListSubnets(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, params ListSubnetsParams)
	// Delete a specific subnet in a LAN
	// (DELETE /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/subnets/{name})
	DeleteSubnet(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, name string)
	// Get a specific subnet in a LAN
	// (GET /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/subnets/{name})
	GetSubnet(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, name string)
	// Create or update a specific subnet in a LAN
	// (PUT /v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/subnets/{name})
	CreateOrUpdateSubnet(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, lan string, name string, params CreateOrUpdateSubnetParams)
	// List Public IPs
	// (GET /v1/tenants/{id}/workspaces/{workspace}/public-ips)
	ListPublicIPs(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, params ListPublicIPsParams)
	// Delete Public IP
	// (DELETE /v1/tenants/{id}/workspaces/{workspace}/public-ips/{name})
	DeletePublicIP(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, name string, params DeletePublicIPParams)
	// Get Public IP
	// (GET /v1/tenants/{id}/workspaces/{workspace}/public-ips/{name})
	GetPublicIP(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, name string)
	// Create or Update Public IP
	// (PUT /v1/tenants/{id}/workspaces/{workspace}/public-ips/{name})
	PutPublicIP(w http.ResponseWriter, r *http.Request, id TenantID, workspace string, name string, params PutPublicIPParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListNetworkQuotas operation middleware
func (siw *ServerInterfaceWrapper) ListNetworkQuotas(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNetworkQuotasParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListNetworkQuotasParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNetworkQuotas(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateNetworkQuota operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateNetworkQuota(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "resourceType" -------------
	var resourceType string

	err = runtime.BindStyledParameterWithOptions("simple", "resourceType", r.PathValue("resourceType"), &resourceType, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "resourceType", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateNetworkQuotaParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateNetworkQuota(w, r, id, resourceType, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListNetworkSkus operation middleware
func (siw *ServerInterfaceWrapper) ListNetworkSkus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNetworkSkusParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListNetworkSkusParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNetworkSkus(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetNetworkSku operation middleware
func (siw *ServerInterfaceWrapper) GetNetworkSku(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNetworkSku(w, r, id, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListLANs operation middleware
func (siw *ServerInterfaceWrapper) ListLANs(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListLANsParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListLANsParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListLANs(w, r, id, workspace, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteLAN operation middleware
func (siw *ServerInterfaceWrapper) DeleteLAN(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteLAN(w, r, id, workspace, lan)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetLAN operation middleware
func (siw *ServerInterfaceWrapper) GetLAN(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLAN(w, r, id, workspace, lan)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateLAN operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateLAN(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateLANParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateLAN(w, r, id, workspace, lan, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListNics operation middleware
func (siw *ServerInterfaceWrapper) ListNics(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNicsParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListNicsParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNics(w, r, id, workspace, lan, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateNic operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateNic(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateNicParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateNic(w, r, id, workspace, lan, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteNic operation middleware
func (siw *ServerInterfaceWrapper) DeleteNic(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteNicParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteNic(w, r, id, workspace, lan, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetNic operation middleware
func (siw *ServerInterfaceWrapper) GetNic(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNicParams

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept GetNicParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNic(w, r, id, workspace, lan, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListRoutingTables operation middleware
func (siw *ServerInterfaceWrapper) ListRoutingTables(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRoutingTablesParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListRoutingTablesParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRoutingTables(w, r, id, workspace, lan, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteRoutingTable operation middleware
func (siw *ServerInterfaceWrapper) DeleteRoutingTable(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRoutingTable(w, r, id, workspace, lan, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRoutingTable operation middleware
func (siw *ServerInterfaceWrapper) GetRoutingTable(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRoutingTable(w, r, id, workspace, lan, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateRoutingTable operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateRoutingTable(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateRoutingTableParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateRoutingTable(w, r, id, workspace, lan, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListSecurityGroups operation middleware
func (siw *ServerInterfaceWrapper) ListSecurityGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSecurityGroupsParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListSecurityGroupsParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSecurityGroups(w, r, id, workspace, lan, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteSecurityGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteSecurityGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSecurityGroup(w, r, id, workspace, lan, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSecurityGroup operation middleware
func (siw *ServerInterfaceWrapper) GetSecurityGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSecurityGroup(w, r, id, workspace, lan, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateSecurityGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateSecurityGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateSecurityGroupParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateSecurityGroup(w, r, id, workspace, lan, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListSubnets operation middleware
func (siw *ServerInterfaceWrapper) ListSubnets(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSubnetsParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListSubnetsParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSubnets(w, r, id, workspace, lan, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteSubnet operation middleware
func (siw *ServerInterfaceWrapper) DeleteSubnet(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSubnet(w, r, id, workspace, lan, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSubnet operation middleware
func (siw *ServerInterfaceWrapper) GetSubnet(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSubnet(w, r, id, workspace, lan, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateSubnet operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateSubnet(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "lan" -------------
	var lan string

	err = runtime.BindStyledParameterWithOptions("simple", "lan", r.PathValue("lan"), &lan, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "lan", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateSubnetParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateSubnet(w, r, id, workspace, lan, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListPublicIPs operation middleware
func (siw *ServerInterfaceWrapper) ListPublicIPs(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPublicIPsParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListPublicIPsParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPublicIPs(w, r, id, workspace, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePublicIP operation middleware
func (siw *ServerInterfaceWrapper) DeletePublicIP(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeletePublicIPParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePublicIP(w, r, id, workspace, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPublicIP operation middleware
func (siw *ServerInterfaceWrapper) GetPublicIP(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPublicIP(w, r, id, workspace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutPublicIP operation middleware
func (siw *ServerInterfaceWrapper) PutPublicIP(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace string

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PutPublicIPParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutPublicIP(w, r, id, workspace, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/quotas", wrapper.ListNetworkQuotas)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/quotas/{resourceType}", wrapper.CreateOrUpdateNetworkQuota)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/skus", wrapper.ListNetworkSkus)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/skus/{name}", wrapper.GetNetworkSku)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans", wrapper.ListLANs)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}", wrapper.DeleteLAN)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}", wrapper.GetLAN)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}", wrapper.CreateOrUpdateLAN)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/nics", wrapper.ListNics)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/nics", wrapper.CreateOrUpdateNic)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/nics/{name}", wrapper.DeleteNic)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/nics/{name}", wrapper.GetNic)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/routing-tables", wrapper.ListRoutingTables)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/routing-tables/{name}", wrapper.DeleteRoutingTable)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/routing-tables/{name}", wrapper.GetRoutingTable)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/routing-tables/{name}", wrapper.CreateOrUpdateRoutingTable)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/security-groups", wrapper.ListSecurityGroups)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/security-groups/{name}", wrapper.DeleteSecurityGroup)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/security-groups/{name}", wrapper.GetSecurityGroup)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/security-groups/{name}", wrapper.CreateOrUpdateSecurityGroup)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/subnets", wrapper.ListSubnets)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/subnets/{name}", wrapper.DeleteSubnet)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/subnets/{name}", wrapper.GetSubnet)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/lans/{lan}/subnets/{name}", wrapper.CreateOrUpdateSubnet)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/public-ips", wrapper.ListPublicIPs)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/public-ips/{name}", wrapper.DeletePublicIP)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/public-ips/{name}", wrapper.GetPublicIP)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/workspaces/{workspace}/public-ips/{name}", wrapper.PutPublicIP)

	return m
}
