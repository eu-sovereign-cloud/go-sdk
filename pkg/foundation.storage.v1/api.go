//go:build go1.22

// Package storage provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package storage

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ImageSpecBoot.
const (
	BIOS ImageSpecBoot = "BIOS"
	UEFI ImageSpecBoot = "UEFI"
)

// Defines values for ImageSpecCpuArchitecture.
const (
	Amd64 ImageSpecCpuArchitecture = "amd64"
	Arm64 ImageSpecCpuArchitecture = "arm64"
)

// Defines values for ImageSpecInitializer.
const (
	Cloudinit22 ImageSpecInitializer = "cloudinit-22"
	None        ImageSpecInitializer = "none"
)

// Defines values for RegionalResourceMetadataKind.
const (
	RegionalResourceMetadataKindActivityLog          RegionalResourceMetadataKind = "activity-log"
	RegionalResourceMetadataKindBlockStorage         RegionalResourceMetadataKind = "block-storage"
	RegionalResourceMetadataKindImage                RegionalResourceMetadataKind = "image"
	RegionalResourceMetadataKindInstance             RegionalResourceMetadataKind = "instance"
	RegionalResourceMetadataKindInstanceSku          RegionalResourceMetadataKind = "instance-sku"
	RegionalResourceMetadataKindNetwork              RegionalResourceMetadataKind = "network"
	RegionalResourceMetadataKindNetworkLoadBalancer  RegionalResourceMetadataKind = "network-load-balancer"
	RegionalResourceMetadataKindNetworkSku           RegionalResourceMetadataKind = "network-sku"
	RegionalResourceMetadataKindNic                  RegionalResourceMetadataKind = "nic"
	RegionalResourceMetadataKindObjectStorageAccount RegionalResourceMetadataKind = "object-storage-account"
	RegionalResourceMetadataKindPublicIp             RegionalResourceMetadataKind = "public-ip"
	RegionalResourceMetadataKindRegion               RegionalResourceMetadataKind = "region"
	RegionalResourceMetadataKindRole                 RegionalResourceMetadataKind = "role"
	RegionalResourceMetadataKindRoleAssignment       RegionalResourceMetadataKind = "role-assignment"
	RegionalResourceMetadataKindRoutingTable         RegionalResourceMetadataKind = "routing-table"
	RegionalResourceMetadataKindSecurityGroup        RegionalResourceMetadataKind = "security-group"
	RegionalResourceMetadataKindSecurityGroupRule    RegionalResourceMetadataKind = "security-group-rule"
	RegionalResourceMetadataKindStorageSku           RegionalResourceMetadataKind = "storage-sku"
	RegionalResourceMetadataKindSubnet               RegionalResourceMetadataKind = "subnet"
	RegionalResourceMetadataKindWorkspace            RegionalResourceMetadataKind = "workspace"
)

// Defines values for ResourceState.
const (
	ResourceStateActive    ResourceState = "active"
	ResourceStateCreating  ResourceState = "creating"
	ResourceStateDeleting  ResourceState = "deleting"
	ResourceStateError     ResourceState = "error"
	ResourceStatePending   ResourceState = "pending"
	ResourceStateSuspended ResourceState = "suspended"
	ResourceStateUpdating  ResourceState = "updating"
)

// Defines values for StorageSkuSpecType.
const (
	LocalDurable   StorageSkuSpecType = "local-durable"
	LocalEphemeral StorageSkuSpecType = "local-ephemeral"
	RemoteDurable  StorageSkuSpecType = "remote-durable"
)

// Defines values for TypeMetadataKind.
const (
	TypeMetadataKindActivityLog          TypeMetadataKind = "activity-log"
	TypeMetadataKindBlockStorage         TypeMetadataKind = "block-storage"
	TypeMetadataKindImage                TypeMetadataKind = "image"
	TypeMetadataKindInstance             TypeMetadataKind = "instance"
	TypeMetadataKindInstanceSku          TypeMetadataKind = "instance-sku"
	TypeMetadataKindNetwork              TypeMetadataKind = "network"
	TypeMetadataKindNetworkLoadBalancer  TypeMetadataKind = "network-load-balancer"
	TypeMetadataKindNetworkSku           TypeMetadataKind = "network-sku"
	TypeMetadataKindNic                  TypeMetadataKind = "nic"
	TypeMetadataKindObjectStorageAccount TypeMetadataKind = "object-storage-account"
	TypeMetadataKindPublicIp             TypeMetadataKind = "public-ip"
	TypeMetadataKindRegion               TypeMetadataKind = "region"
	TypeMetadataKindRole                 TypeMetadataKind = "role"
	TypeMetadataKindRoleAssignment       TypeMetadataKind = "role-assignment"
	TypeMetadataKindRoutingTable         TypeMetadataKind = "routing-table"
	TypeMetadataKindSecurityGroup        TypeMetadataKind = "security-group"
	TypeMetadataKindSecurityGroupRule    TypeMetadataKind = "security-group-rule"
	TypeMetadataKindStorageSku           TypeMetadataKind = "storage-sku"
	TypeMetadataKindSubnet               TypeMetadataKind = "subnet"
	TypeMetadataKindWorkspace            TypeMetadataKind = "workspace"
)

// Defines values for ZonalResourceMetadataKind.
const (
	ZonalResourceMetadataKindActivityLog          ZonalResourceMetadataKind = "activity-log"
	ZonalResourceMetadataKindBlockStorage         ZonalResourceMetadataKind = "block-storage"
	ZonalResourceMetadataKindImage                ZonalResourceMetadataKind = "image"
	ZonalResourceMetadataKindInstance             ZonalResourceMetadataKind = "instance"
	ZonalResourceMetadataKindInstanceSku          ZonalResourceMetadataKind = "instance-sku"
	ZonalResourceMetadataKindNetwork              ZonalResourceMetadataKind = "network"
	ZonalResourceMetadataKindNetworkLoadBalancer  ZonalResourceMetadataKind = "network-load-balancer"
	ZonalResourceMetadataKindNetworkSku           ZonalResourceMetadataKind = "network-sku"
	ZonalResourceMetadataKindNic                  ZonalResourceMetadataKind = "nic"
	ZonalResourceMetadataKindObjectStorageAccount ZonalResourceMetadataKind = "object-storage-account"
	ZonalResourceMetadataKindPublicIp             ZonalResourceMetadataKind = "public-ip"
	ZonalResourceMetadataKindRegion               ZonalResourceMetadataKind = "region"
	ZonalResourceMetadataKindRole                 ZonalResourceMetadataKind = "role"
	ZonalResourceMetadataKindRoleAssignment       ZonalResourceMetadataKind = "role-assignment"
	ZonalResourceMetadataKindRoutingTable         ZonalResourceMetadataKind = "routing-table"
	ZonalResourceMetadataKindSecurityGroup        ZonalResourceMetadataKind = "security-group"
	ZonalResourceMetadataKindSecurityGroupRule    ZonalResourceMetadataKind = "security-group-rule"
	ZonalResourceMetadataKindStorageSku           ZonalResourceMetadataKind = "storage-sku"
	ZonalResourceMetadataKindSubnet               ZonalResourceMetadataKind = "subnet"
	ZonalResourceMetadataKindWorkspace            ZonalResourceMetadataKind = "workspace"
)

// Defines values for AcceptHeader.
const (
	AcceptHeaderApplicationjson            AcceptHeader = "application/json"
	AcceptHeaderApplicationjsonDeletedOnly AcceptHeader = "application/json; deleted=only"
	AcceptHeaderApplicationjsonDeletedTrue AcceptHeader = "application/json; deleted=true"
)

// Defines values for ListImagesParamsAccept.
const (
	ListImagesParamsAcceptApplicationjson            ListImagesParamsAccept = "application/json"
	ListImagesParamsAcceptApplicationjsonDeletedOnly ListImagesParamsAccept = "application/json; deleted=only"
	ListImagesParamsAcceptApplicationjsonDeletedTrue ListImagesParamsAccept = "application/json; deleted=true"
)

// Defines values for ListSkusParamsAccept.
const (
	ListSkusParamsAcceptApplicationjson            ListSkusParamsAccept = "application/json"
	ListSkusParamsAcceptApplicationjsonDeletedOnly ListSkusParamsAccept = "application/json; deleted=only"
	ListSkusParamsAcceptApplicationjsonDeletedTrue ListSkusParamsAccept = "application/json; deleted=true"
)

// Defines values for ListBlockStoragesParamsAccept.
const (
	ListBlockStoragesParamsAcceptApplicationjson            ListBlockStoragesParamsAccept = "application/json"
	ListBlockStoragesParamsAcceptApplicationjsonDeletedOnly ListBlockStoragesParamsAccept = "application/json; deleted=only"
	ListBlockStoragesParamsAcceptApplicationjsonDeletedTrue ListBlockStoragesParamsAccept = "application/json; deleted=true"
)

// BlockStorageIterator Iterator for block-storages
type BlockStorageIterator struct {
	// Items List of block-storages
	Items []BlockStorage `json:"items"`

	// Metadata Metadata for response objects.
	Metadata ResponseMetadata `json:"metadata"`
}

// BlockStorage defines model for BlockStorage.
type BlockStorage struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for zonal resources with name, permission, modification, type, tenant, region, and zone information.
	Metadata *ZonalResourceMetadata `json:"metadata,omitempty"`

	// Spec References the SKU used for this block.
	// If a reference to the source image is used as the base for creating this block storage.
	Spec BlockStorageSpec `json:"spec"`

	// Status The status of the block storage.
	Status *BlockStorageStatus `json:"status,omitempty"`
}

// BlockStorageSpec References the SKU used for this block.
// If a reference to the source image is used as the base for creating this block storage.
type BlockStorageSpec struct {
	// SizeGB Size of the block storage in GB.
	SizeGB int `json:"sizeGB"`

	// SkuRef Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
	// The reference can be used to refer to a resource in other resources.
	SkuRef Reference `json:"skuRef"`

	// SourceImageRef Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
	// The reference can be used to refer to a resource in other resources.
	SourceImageRef *Reference `json:"sourceImageRef,omitempty"`
}

// BlockStorageStatus defines model for BlockStorageStatus.
type BlockStorageStatus struct {
	// AttachedTo Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
	// The reference can be used to refer to a resource in other resources.
	AttachedTo *Reference        `json:"attachedTo,omitempty"`
	Conditions []StatusCondition `json:"conditions"`

	// SizeGB Size of the block storage in GB.
	SizeGB int `json:"sizeGB"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *ResourceState `json:"state,omitempty"`
}

// Error A detailed error response see https://datatracker.ietf.org/doc/html/rfc7807.
type Error struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta    *map[string]interface{} `json:"meta,omitempty"`
	Sources *[]ErrorSource          `json:"sources,omitempty"`

	// Status The HTTP status type ([http://secapi.eu/errors/-rfc7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem
	// type.  It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`

	// Type The type of error, expressed as a URI.
	Type string `json:"type"`
}

// Error400 defines model for Error400.
type Error400 struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta    *map[string]interface{} `json:"meta,omitempty"`
	Sources *[]ErrorSource          `json:"sources,omitempty"`

	// Status The HTTP status type ([http://secapi.eu/errors/-rfc7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem
	// type.  It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`

	// Type The type of error, expressed as a URI.
	Type string `json:"type"`
}

// Error401 defines model for Error401.
type Error401 struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta    *map[string]interface{} `json:"meta,omitempty"`
	Sources *[]ErrorSource          `json:"sources,omitempty"`

	// Status The HTTP status type ([http://secapi.eu/errors/-rfc7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem
	// type.  It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`

	// Type The type of error, expressed as a URI.
	Type string `json:"type"`
}

// Error403 defines model for Error403.
type Error403 struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta    *map[string]interface{} `json:"meta,omitempty"`
	Sources *[]ErrorSource          `json:"sources,omitempty"`

	// Status The HTTP status type ([http://secapi.eu/errors/-rfc7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem
	// type.  It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`

	// Type The type of error, expressed as a URI.
	Type string `json:"type"`
}

// Error404 defines model for Error404.
type Error404 struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta    *map[string]interface{} `json:"meta,omitempty"`
	Sources *[]ErrorSource          `json:"sources,omitempty"`

	// Status The HTTP status type ([http://secapi.eu/errors/-rfc7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem
	// type.  It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`

	// Type The type of error, expressed as a URI.
	Type string `json:"type"`
}

// Error409 defines model for Error409.
type Error409 struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta    *map[string]interface{} `json:"meta,omitempty"`
	Sources *[]ErrorSource          `json:"sources,omitempty"`

	// Status The HTTP status type ([http://secapi.eu/errors/-rfc7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem
	// type.  It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`

	// Type The type of error, expressed as a URI.
	Type string `json:"type"`
}

// Error412 defines model for Error412.
type Error412 struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta    *map[string]interface{} `json:"meta,omitempty"`
	Sources *[]ErrorSource          `json:"sources,omitempty"`

	// Status The HTTP status type ([http://secapi.eu/errors/-rfc7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem
	// type.  It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`

	// Type The type of error, expressed as a URI.
	Type string `json:"type"`
}

// Error422 defines model for Error422.
type Error422 struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta    *map[string]interface{} `json:"meta,omitempty"`
	Sources *[]ErrorSource          `json:"sources,omitempty"`

	// Status The HTTP status type ([http://secapi.eu/errors/-rfc7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem
	// type.  It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`

	// Type The type of error, expressed as a URI.
	Type string `json:"type"`
}

// Error500 defines model for Error500.
type Error500 struct {
	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	// It may or may not yield further information if dereferenced.
	Instance string `json:"instance"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta    *map[string]interface{} `json:"meta,omitempty"`
	Sources *[]ErrorSource          `json:"sources,omitempty"`

	// Status The HTTP status type ([http://secapi.eu/errors/-rfc7231], Section 6)
	// generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem
	// type.  It SHOULD NOT change from occurrence to occurrence of the
	// problem, except for purposes of localization (e.g., using
	// proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`

	// Type The type of error, expressed as a URI.
	Type string `json:"type"`
}

// ErrorSource An object containing references to the source of the error.
type ErrorSource struct {
	// Parameter A string indicating which URI query parameter caused the error.
	Parameter string `json:"parameter"`

	// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
	Pointer string `json:"pointer"`
}

// Image defines model for Image.
type Image struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for regional resources with name, permission, modification, type, tenant, and region information.
	Metadata *RegionalResourceMetadata `json:"metadata,omitempty"`

	// Spec Detailed specification of the Image resource.
	// The Image is derived from a block storage resource identified by
	// `blockStorageRef` and serves as a template for creating
	// compute instances. For additional information, refer to the
	// [Image Handling](/docs/content/Other/image-handling) section.
	Spec ImageSpec `json:"spec"`

	// Status Status of the Image, including the size of the Image in MB.
	Status *ImageStatus `json:"status,omitempty"`
}

// ImageIterator Iterator for images
type ImageIterator struct {
	// Items List of images
	Items []Image `json:"items"`

	// Metadata Metadata for response objects.
	Metadata ResponseMetadata `json:"metadata"`
}

// ImageSpec Detailed specification of the Image resource.
// The Image is derived from a block storage resource identified by
// `blockStorageRef` and serves as a template for creating
// compute instances. For additional information, refer to the
// [Image Handling](/docs/content/Other/image-handling) section.
type ImageSpec struct {
	// BlockStorageRef Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
	// The reference can be used to refer to a resource in other resources.
	BlockStorageRef Reference `json:"blockStorageRef"`

	// Boot Boot type for the Image
	Boot *ImageSpecBoot `json:"boot,omitempty"`

	// CpuArchitecture CPU architecture for the Image
	CpuArchitecture ImageSpecCpuArchitecture `json:"cpuArchitecture"`

	// Initializer Initializer for the Image
	Initializer *ImageSpecInitializer `json:"initializer,omitempty"`
}

// ImageSpecBoot Boot type for the Image
type ImageSpecBoot string

// ImageSpecCpuArchitecture CPU architecture for the Image
type ImageSpecCpuArchitecture string

// ImageSpecInitializer Initializer for the Image
type ImageSpecInitializer string

// ImageStatus defines model for ImageStatus.
type ImageStatus struct {
	Conditions []StatusCondition `json:"conditions"`

	// SizeMB Size of the Image in MB
	SizeMB *int `json:"sizeMB,omitempty"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *ResourceState `json:"state,omitempty"`
}

// ModificationMetadata Base metadata for all resources with optional region references
type ModificationMetadata struct {
	// CreatedAt Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// LastModifiedAt Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedAt time.Time `json:"lastModifiedAt"`

	// ResourceVersion Incremented on every modification of the resource. Used for optimistic concurrency control.
	ResourceVersion int `json:"resourceVersion"`
}

// NameMetadata Metadata for resource names
type NameMetadata struct {
	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name string `json:"name"`
}

// PermissionMetadata Metadata for permission management
type PermissionMetadata struct {
	Provider string `json:"provider"`
	Resource string `json:"resource"`
	Verb     string `json:"verb"`
}

// Reference Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
// The reference can be used to refer to a resource in other resources.
type Reference struct {
	union json.RawMessage
}

// ReferenceObject A reference to a resource using an object. The object contains the
// same information as the ReferenceURN, but is represented as a structured object.
// The advantage of this representation is that it can be used to reference
// resources in different workspaces or regions without the need to specify
// the full URN.
type ReferenceObject struct {
	// Provider Provider of the resource. If not set, the provider is inferred from the context.
	Provider *string `json:"provider,omitempty"`

	// Region Region of the resource. If not set, the region is inferred from the context.
	Region *string `json:"region,omitempty"`

	// Resource Name and type of the resource. Must be in the format `<type>/<name>`.
	// The type is the resource type, and the name is the resource name.
	Resource string `json:"resource"`

	// Tenant Tenant of the resource. If not set, the tenant is inferred from the context.
	Tenant *string `json:"tenant,omitempty"`

	// Workspace Workspace of the resource. If not set, the workspace is inferred from the context.
	Workspace *string `json:"workspace,omitempty"`
}

// ReferenceURN A unique resource name used to reference this resource in other resources. The reference
// is represented as the full URN (Uniform Resource Name) name of the resource.
//
// ### Automatic Prefix Inference
//
// In most cases, the prefix of the URN can be automatically derived in the given context.
// To simplify usage, only the resource type and name might be specified as a reference
// using the `<type>/<name>` notation. The suffix can be made more specific by adding
// additional segments separated by slashes.
//
// The prefix is automatically inferred from the context. For example, if the resource is a
// block storage in the same workspace the reference can be specified as
// `block-storages/my-block-storage`. If the resource is a block storage in a different workspace, the
// reference can be specified as `workspaces/ws-1/block-storages/my-block-storage`.
//
// For automatic prefix inference, the following rules apply:
// - the version is inferred from the current resource version
// - the workspace is inferred from the current workspace
// - the region is inferred from the current region
// - the provider is inferred from the type and context of the usage
//
// The prefix inference is resolved on admission into the full URN format, which makes it
// mostly suitable for human use.
type ReferenceURN = string

// RegionalMetadata Metadata for regional resources
type RegionalMetadata struct {
	// Region Reference to the region where the resource is located
	Region string `json:"region"`

	// Workspace Workspace identifier
	Workspace *string `json:"workspace,omitempty"`
}

// RegionalResourceMetadata defines model for RegionalResourceMetadata.
type RegionalResourceMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// CreatedAt Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Kind Type of the resource
	Kind RegionalResourceMetadataKind `json:"kind"`

	// LastModifiedAt Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedAt time.Time `json:"lastModifiedAt"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name     string `json:"name"`
	Provider string `json:"provider"`

	// Ref Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
	// The reference can be used to refer to a resource in other resources.
	Ref *Reference `json:"ref,omitempty"`

	// Region Reference to the region where the resource is located
	Region   string `json:"region"`
	Resource string `json:"resource"`

	// ResourceVersion Incremented on every modification of the resource. Used for optimistic concurrency control.
	ResourceVersion int `json:"resourceVersion"`

	// Tenant Tenant identifier
	Tenant string `json:"tenant"`
	Verb   string `json:"verb"`

	// Workspace Workspace identifier
	Workspace *string `json:"workspace,omitempty"`
}

// RegionalResourceMetadataKind Type of the resource
type RegionalResourceMetadataKind string

// ResourceState Current phase of the resource:
// - pending: not available, waiting for other resources
// - creating: not available, creation started
// - active: available for data layer usage
// - updating: available for data layer usage
// - deleting: maybe still available for data layer user, can fail any moment
// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
// - error: failed to fulfill the request; would be related to provider issue or customer related input.
type ResourceState string

// ResponseMetadata defines model for ResponseMetadata.
type ResponseMetadata struct {
	Provider string `json:"provider"`
	Resource string `json:"resource"`

	// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
	SkipToken *string `json:"skipToken,omitempty"`
	Verb      string  `json:"verb"`
}

// SkuIterator Iterator for skus
type SkuIterator struct {
	// Items List of skus
	Items []StorageSku `json:"items"`

	// Metadata Metadata for response objects.
	Metadata ResponseMetadata `json:"metadata"`
}

// SkuResourceMetadata Metadata for resource names
type SkuResourceMetadata = NameMetadata

// Status Current status of the resource
type Status struct {
	Conditions []StatusCondition `json:"conditions"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State *ResourceState `json:"state,omitempty"`
}

// StatusCondition StatusCondition describes the state of a resource at a certain point.
// Conditions are provider-specific and can represent different states depending on the
// resource type and provider implementation.
type StatusCondition struct {
	// LastTransitionAt LastTransitionAt is the last time the condition transitioned from one
	// status to another. This should be when the underlying condition changed.
	// If that is not known, then using the time when the API field changed is
	// acceptable.
	LastTransitionAt time.Time `json:"lastTransitionAt"`

	// Message A human-readable message indicating details about the transition.
	Message *string `json:"message,omitempty"`

	// Reason The reason for the condition's last transition in CamelCase.
	// The specific set of reason values is provider-specific and should be
	// documented by the provider.
	Reason *string `json:"reason,omitempty"`

	// State Current phase of the resource:
	// - pending: not available, waiting for other resources
	// - creating: not available, creation started
	// - active: available for data layer usage
	// - updating: available for data layer usage
	// - deleting: maybe still available for data layer user, can fail any moment
	// - suspended: not available, provider specific behavior (payment issue, user decided to suspend)
	// - error: failed to fulfill the request; would be related to provider issue or customer related input.
	State ResourceState `json:"state"`

	// Type Type of condition. The condition type is provider-specific and should
	// reflect the specific states relevant to your resource.
	Type *string `json:"type,omitempty"`
}

// StorageSku defines model for StorageSku.
type StorageSku struct {
	// Annotations System-defined key/value pairs to annotate the resource.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions System-defined key/value pairs to document available extensions.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels System-defined key/value pairs to filter resources.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Metadata for SKU resources.
	Metadata *SkuResourceMetadata `json:"metadata,omitempty"`

	// Spec Specification of the storage SKU, including its capabilities and extensions.
	Spec *StorageSkuSpec `json:"spec,omitempty"`
}

// StorageSkuSpec Specification of the storage SKU, including its capabilities and extensions.
type StorageSkuSpec struct {
	// Iops The number of IOPS (Input/Output Operations Per Second) guaranteed for
	// the storage SKU.
	Iops int `json:"iops"`

	// MinVolumeSize Minimum volume size for guaranteed performance, in GB.
	MinVolumeSize int `json:"minVolumeSize"`

	// Type Type of storage SKU. Can be one of the following:
	//
	// * `local-ephemeral`: Local storage is directly attached to the hypervisor
	//   hosting the instance. In the event of a hypervisor failure or instance
	//   restart, the data may either be lost or become unavailable. The failure
	//   mode depends on the Cloud Service Provider (CSP).
	//   Users of local storage should be aware of these risks and implement
	//   a robust backup strategy or application level replication of the data.
	//   Local storage is typically suited for high-performance workloads requiring
	//   low latency and high throughput, where the application layer can handle
	//   failures. It is not recommended for workloads demanding high availability
	//   or data durability. Example use-cases include caching, temporary data
	//   or immutable workloads such as operating system images without local data.
	// * `local-durable`: Local durable storage is similar to local storage
	//   but is designed to provide data durability while providing high-performance.
	//   It is typically implemented using a redundant storage device or
	//   replicated storage solution. Local durable storage is suitable for
	//   workloads requiring high performance and low latency, while also
	//   ensuring data durability at the cost of availability. The time to
	//   restore data may vary depending on the CSP and the
	//   will be significantly higher then using `remote-durable` storage.
	//   Example use-cases include replicated paxos or raft based databases or
	//   replicated databases using synchronous replication, in addition to
	//   file storage.
	// * `remote-durable`: Remote storage is a network-attached storage solution
	//   designed to provide data redundancy and high availability. While
	//   typically slower than local storage, remote storage offers the
	//   advantage of being accessible by different hypervisors.
	//   This means the storage can be used by different instances running
	//   on separate hypervisors, but only one instance at a time. This
	//   enabled the recreation of the instance with the same storage on a
	//   different hypervisor and therefore greatly reduces the recovery
	//   time in case of failure of the hypervisor. Remote storage cannot be
	//   attached to multiple instances simultaneously.
	//   Example use-cases include file storage or replicated databases
	//   using asynchronous replication.
	Type StorageSkuSpecType `json:"type"`
}

// StorageSkuSpecType Type of storage SKU. Can be one of the following:
//
//   - `local-ephemeral`: Local storage is directly attached to the hypervisor
//     hosting the instance. In the event of a hypervisor failure or instance
//     restart, the data may either be lost or become unavailable. The failure
//     mode depends on the Cloud Service Provider (CSP).
//     Users of local storage should be aware of these risks and implement
//     a robust backup strategy or application level replication of the data.
//     Local storage is typically suited for high-performance workloads requiring
//     low latency and high throughput, where the application layer can handle
//     failures. It is not recommended for workloads demanding high availability
//     or data durability. Example use-cases include caching, temporary data
//     or immutable workloads such as operating system images without local data.
//   - `local-durable`: Local durable storage is similar to local storage
//     but is designed to provide data durability while providing high-performance.
//     It is typically implemented using a redundant storage device or
//     replicated storage solution. Local durable storage is suitable for
//     workloads requiring high performance and low latency, while also
//     ensuring data durability at the cost of availability. The time to
//     restore data may vary depending on the CSP and the
//     will be significantly higher then using `remote-durable` storage.
//     Example use-cases include replicated paxos or raft based databases or
//     replicated databases using synchronous replication, in addition to
//     file storage.
//   - `remote-durable`: Remote storage is a network-attached storage solution
//     designed to provide data redundancy and high availability. While
//     typically slower than local storage, remote storage offers the
//     advantage of being accessible by different hypervisors.
//     This means the storage can be used by different instances running
//     on separate hypervisors, but only one instance at a time. This
//     enabled the recreation of the instance with the same storage on a
//     different hypervisor and therefore greatly reduces the recovery
//     time in case of failure of the hypervisor. Remote storage cannot be
//     attached to multiple instances simultaneously.
//     Example use-cases include file storage or replicated databases
//     using asynchronous replication.
type StorageSkuSpecType string

// SystemResourceMetadata Metadata for user-defined resource properties
type SystemResourceMetadata struct {
	// Annotations System-defined key/value pairs to annotate the resource.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions System-defined key/value pairs to document available extensions.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels System-defined key/value pairs to filter resources.
	Labels *map[string]string `json:"labels,omitempty"`
}

// TenantMetadata Metadata for global resources with tenant constraints
type TenantMetadata struct {
	// Tenant Tenant identifier
	Tenant string `json:"tenant"`
}

// TypeMetadata Metadata for all resources with type information.
type TypeMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// Kind Type of the resource
	Kind TypeMetadataKind `json:"kind"`

	// Ref Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
	// The reference can be used to refer to a resource in other resources.
	Ref *Reference `json:"ref,omitempty"`
}

// TypeMetadataKind Type of the resource
type TypeMetadataKind string

// UserResourceMetadata Metadata for user-defined resource properties
type UserResourceMetadata struct {
	// Annotations User-defined key/value pairs that are mutable and can be used to add annotations.
	// The number of annotations is eventually limited by the CSP.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Extensions User-defined key/value pairs that are mutable and can be used to add extensions.
	// Extensions are subject to validation by the CSP, and any value that is not accepted will be rejected during admission.
	Extensions *map[string]string `json:"extensions,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to
	// organize and categorize resources. They can be used to filter resources.
	// The number of labels is eventually limited by the CSP.
	Labels *map[string]string `json:"labels,omitempty"`
}

// ZonalMetadata Metadata for zonal resources
type ZonalMetadata struct {
	// Zone Reference to a specific zone within a region
	Zone Zone `json:"zone"`
}

// ZonalResourceMetadata defines model for ZonalResourceMetadata.
type ZonalResourceMetadata struct {
	// ApiVersion API version of the resource
	ApiVersion string `json:"apiVersion"`

	// CreatedAt Indicates the time when the resource was created. The field is set by the provider and should not be modified by the user.
	CreatedAt time.Time `json:"createdAt"`

	// DeletedAt If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Kind Type of the resource
	Kind ZonalResourceMetadataKind `json:"kind"`

	// LastModifiedAt Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedAt time.Time `json:"lastModifiedAt"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character.
	// Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots.
	// Each segment follows the same rules.
	Name     string `json:"name"`
	Provider string `json:"provider"`

	// Ref Reference to a resource. The reference is represented as the full URN (Uniform Resource Name) name of the resource.
	// The reference can be used to refer to a resource in other resources.
	Ref *Reference `json:"ref,omitempty"`

	// Region Reference to the region where the resource is located
	Region   string `json:"region"`
	Resource string `json:"resource"`

	// ResourceVersion Incremented on every modification of the resource. Used for optimistic concurrency control.
	ResourceVersion int `json:"resourceVersion"`

	// Tenant Tenant identifier
	Tenant string `json:"tenant"`
	Verb   string `json:"verb"`

	// Workspace Workspace identifier
	Workspace *string `json:"workspace,omitempty"`

	// Zone Reference to a specific zone within a region
	Zone Zone `json:"zone"`
}

// ZonalResourceMetadataKind Type of the resource
type ZonalResourceMetadataKind string

// Zone Reference to a specific zone within a region
type Zone = string

// AcceptHeader defines model for acceptHeader.
type AcceptHeader string

// IfUnmodifiedSince defines model for ifUnmodifiedSince.
type IfUnmodifiedSince = int

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// ResourceName defines model for resourceName.
type ResourceName = string

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// Tenant defines model for tenant.
type Tenant = string

// Workspace defines model for workspace.
type Workspace = string

// ListImagesParams defines parameters for ListImages.
type ListImagesParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListImagesParamsAccept `json:"Accept,omitempty"`
}

// ListImagesParamsAccept defines parameters for ListImages.
type ListImagesParamsAccept string

// DeleteImageParams defines parameters for DeleteImage.
type DeleteImageParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateImageParams defines parameters for CreateOrUpdateImage.
type CreateOrUpdateImageParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListSkusParams defines parameters for ListSkus.
type ListSkusParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListSkusParamsAccept `json:"Accept,omitempty"`
}

// ListSkusParamsAccept defines parameters for ListSkus.
type ListSkusParamsAccept string

// ListBlockStoragesParams defines parameters for ListBlockStorages.
type ListBlockStoragesParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListBlockStoragesParamsAccept `json:"Accept,omitempty"`
}

// ListBlockStoragesParamsAccept defines parameters for ListBlockStorages.
type ListBlockStoragesParamsAccept string

// DeleteBlockStorageParams defines parameters for DeleteBlockStorage.
type DeleteBlockStorageParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateBlockStorageParams defines parameters for CreateOrUpdateBlockStorage.
type CreateOrUpdateBlockStorageParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified version.
	// Uses metadata.resourceVersion for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateImageJSONRequestBody defines body for CreateOrUpdateImage for application/json ContentType.
type CreateOrUpdateImageJSONRequestBody = Image

// CreateOrUpdateBlockStorageJSONRequestBody defines body for CreateOrUpdateBlockStorage for application/json ContentType.
type CreateOrUpdateBlockStorageJSONRequestBody = BlockStorage

// AsReferenceURN returns the union data inside the Reference as a ReferenceURN
func (t Reference) AsReferenceURN() (ReferenceURN, error) {
	var body ReferenceURN
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReferenceURN overwrites any union data inside the Reference as the provided ReferenceURN
func (t *Reference) FromReferenceURN(v ReferenceURN) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReferenceURN performs a merge with any union data inside the Reference, using the provided ReferenceURN
func (t *Reference) MergeReferenceURN(v ReferenceURN) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReferenceObject returns the union data inside the Reference as a ReferenceObject
func (t Reference) AsReferenceObject() (ReferenceObject, error) {
	var body ReferenceObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReferenceObject overwrites any union data inside the Reference as the provided ReferenceObject
func (t *Reference) FromReferenceObject(v ReferenceObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReferenceObject performs a merge with any union data inside the Reference, using the provided ReferenceObject
func (t *Reference) MergeReferenceObject(v ReferenceObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Reference) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Reference) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListImages request
	ListImages(ctx context.Context, tenant Tenant, params *ListImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImage request
	DeleteImage(ctx context.Context, tenant Tenant, name ResourceName, params *DeleteImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImage request
	GetImage(ctx context.Context, tenant Tenant, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateImageWithBody request with any body
	CreateOrUpdateImageWithBody(ctx context.Context, tenant Tenant, name ResourceName, params *CreateOrUpdateImageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateImage(ctx context.Context, tenant Tenant, name ResourceName, params *CreateOrUpdateImageParams, body CreateOrUpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSkus request
	ListSkus(ctx context.Context, tenant Tenant, params *ListSkusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSku request
	GetSku(ctx context.Context, tenant Tenant, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBlockStorages request
	ListBlockStorages(ctx context.Context, tenant Tenant, workspace Workspace, params *ListBlockStoragesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBlockStorage request
	DeleteBlockStorage(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, params *DeleteBlockStorageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockStorage request
	GetBlockStorage(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateBlockStorageWithBody request with any body
	CreateOrUpdateBlockStorageWithBody(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, params *CreateOrUpdateBlockStorageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateBlockStorage(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, params *CreateOrUpdateBlockStorageParams, body CreateOrUpdateBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListImages(ctx context.Context, tenant Tenant, params *ListImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListImagesRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImage(ctx context.Context, tenant Tenant, name ResourceName, params *DeleteImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageRequest(c.Server, tenant, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImage(ctx context.Context, tenant Tenant, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImageRequest(c.Server, tenant, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateImageWithBody(ctx context.Context, tenant Tenant, name ResourceName, params *CreateOrUpdateImageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateImageRequestWithBody(c.Server, tenant, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateImage(ctx context.Context, tenant Tenant, name ResourceName, params *CreateOrUpdateImageParams, body CreateOrUpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateImageRequest(c.Server, tenant, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSkus(ctx context.Context, tenant Tenant, params *ListSkusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSkusRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSku(ctx context.Context, tenant Tenant, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSkuRequest(c.Server, tenant, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBlockStorages(ctx context.Context, tenant Tenant, workspace Workspace, params *ListBlockStoragesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBlockStoragesRequest(c.Server, tenant, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBlockStorage(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, params *DeleteBlockStorageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBlockStorageRequest(c.Server, tenant, workspace, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockStorage(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockStorageRequest(c.Server, tenant, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateBlockStorageWithBody(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, params *CreateOrUpdateBlockStorageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateBlockStorageRequestWithBody(c.Server, tenant, workspace, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateBlockStorage(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, params *CreateOrUpdateBlockStorageParams, body CreateOrUpdateBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateBlockStorageRequest(c.Server, tenant, workspace, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListImagesRequest generates requests for ListImages
func NewListImagesRequest(server string, tenant Tenant, params *ListImagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteImageRequest generates requests for DeleteImage
func NewDeleteImageRequest(server string, tenant Tenant, name ResourceName, params *DeleteImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewGetImageRequest generates requests for GetImage
func NewGetImageRequest(server string, tenant Tenant, name ResourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateImageRequest calls the generic CreateOrUpdateImage builder with application/json body
func NewCreateOrUpdateImageRequest(server string, tenant Tenant, name ResourceName, params *CreateOrUpdateImageParams, body CreateOrUpdateImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateImageRequestWithBody(server, tenant, name, params, "application/json", bodyReader)
}

// NewCreateOrUpdateImageRequestWithBody generates requests for CreateOrUpdateImage with any type of body
func NewCreateOrUpdateImageRequestWithBody(server string, tenant Tenant, name ResourceName, params *CreateOrUpdateImageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/images/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewListSkusRequest generates requests for ListSkus
func NewListSkusRequest(server string, tenant Tenant, params *ListSkusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/skus", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewGetSkuRequest generates requests for GetSku
func NewGetSkuRequest(server string, tenant Tenant, name ResourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/skus/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBlockStoragesRequest generates requests for ListBlockStorages
func NewListBlockStoragesRequest(server string, tenant Tenant, workspace Workspace, params *ListBlockStoragesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/block-storages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteBlockStorageRequest generates requests for DeleteBlockStorage
func NewDeleteBlockStorageRequest(server string, tenant Tenant, workspace Workspace, name ResourceName, params *DeleteBlockStorageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/block-storages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewGetBlockStorageRequest generates requests for GetBlockStorage
func NewGetBlockStorageRequest(server string, tenant Tenant, workspace Workspace, name ResourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/block-storages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateBlockStorageRequest calls the generic CreateOrUpdateBlockStorage builder with application/json body
func NewCreateOrUpdateBlockStorageRequest(server string, tenant Tenant, workspace Workspace, name ResourceName, params *CreateOrUpdateBlockStorageParams, body CreateOrUpdateBlockStorageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateBlockStorageRequestWithBody(server, tenant, workspace, name, params, "application/json", bodyReader)
}

// NewCreateOrUpdateBlockStorageRequestWithBody generates requests for CreateOrUpdateBlockStorage with any type of body
func NewCreateOrUpdateBlockStorageRequestWithBody(server string, tenant Tenant, workspace Workspace, name ResourceName, params *CreateOrUpdateBlockStorageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/workspaces/%s/block-storages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListImagesWithResponse request
	ListImagesWithResponse(ctx context.Context, tenant Tenant, params *ListImagesParams, reqEditors ...RequestEditorFn) (*ListImagesResponse, error)

	// DeleteImageWithResponse request
	DeleteImageWithResponse(ctx context.Context, tenant Tenant, name ResourceName, params *DeleteImageParams, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error)

	// GetImageWithResponse request
	GetImageWithResponse(ctx context.Context, tenant Tenant, name ResourceName, reqEditors ...RequestEditorFn) (*GetImageResponse, error)

	// CreateOrUpdateImageWithBodyWithResponse request with any body
	CreateOrUpdateImageWithBodyWithResponse(ctx context.Context, tenant Tenant, name ResourceName, params *CreateOrUpdateImageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateImageResponse, error)

	CreateOrUpdateImageWithResponse(ctx context.Context, tenant Tenant, name ResourceName, params *CreateOrUpdateImageParams, body CreateOrUpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateImageResponse, error)

	// ListSkusWithResponse request
	ListSkusWithResponse(ctx context.Context, tenant Tenant, params *ListSkusParams, reqEditors ...RequestEditorFn) (*ListSkusResponse, error)

	// GetSkuWithResponse request
	GetSkuWithResponse(ctx context.Context, tenant Tenant, name ResourceName, reqEditors ...RequestEditorFn) (*GetSkuResponse, error)

	// ListBlockStoragesWithResponse request
	ListBlockStoragesWithResponse(ctx context.Context, tenant Tenant, workspace Workspace, params *ListBlockStoragesParams, reqEditors ...RequestEditorFn) (*ListBlockStoragesResponse, error)

	// DeleteBlockStorageWithResponse request
	DeleteBlockStorageWithResponse(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, params *DeleteBlockStorageParams, reqEditors ...RequestEditorFn) (*DeleteBlockStorageResponse, error)

	// GetBlockStorageWithResponse request
	GetBlockStorageWithResponse(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, reqEditors ...RequestEditorFn) (*GetBlockStorageResponse, error)

	// CreateOrUpdateBlockStorageWithBodyWithResponse request with any body
	CreateOrUpdateBlockStorageWithBodyWithResponse(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, params *CreateOrUpdateBlockStorageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateBlockStorageResponse, error)

	CreateOrUpdateBlockStorageWithResponse(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, params *CreateOrUpdateBlockStorageParams, body CreateOrUpdateBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateBlockStorageResponse, error)
}

type ListImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImageIterator
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r ListImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON409      *Error409
	JSON412      *Error412
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Image
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Image
	JSON201      *Image
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON409      *Error409
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSkusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SkuIterator
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r ListSkusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSkusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSkuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageSku
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetSkuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSkuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBlockStoragesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockStorageIterator
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r ListBlockStoragesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBlockStoragesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBlockStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON409      *Error409
	JSON412      *Error412
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteBlockStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBlockStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockStorage
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetBlockStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateBlockStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockStorage
	JSON201      *BlockStorage
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON409      *Error409
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateBlockStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateBlockStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListImagesWithResponse request returning *ListImagesResponse
func (c *ClientWithResponses) ListImagesWithResponse(ctx context.Context, tenant Tenant, params *ListImagesParams, reqEditors ...RequestEditorFn) (*ListImagesResponse, error) {
	rsp, err := c.ListImages(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListImagesResponse(rsp)
}

// DeleteImageWithResponse request returning *DeleteImageResponse
func (c *ClientWithResponses) DeleteImageWithResponse(ctx context.Context, tenant Tenant, name ResourceName, params *DeleteImageParams, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error) {
	rsp, err := c.DeleteImage(ctx, tenant, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageResponse(rsp)
}

// GetImageWithResponse request returning *GetImageResponse
func (c *ClientWithResponses) GetImageWithResponse(ctx context.Context, tenant Tenant, name ResourceName, reqEditors ...RequestEditorFn) (*GetImageResponse, error) {
	rsp, err := c.GetImage(ctx, tenant, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImageResponse(rsp)
}

// CreateOrUpdateImageWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateImageResponse
func (c *ClientWithResponses) CreateOrUpdateImageWithBodyWithResponse(ctx context.Context, tenant Tenant, name ResourceName, params *CreateOrUpdateImageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateImageResponse, error) {
	rsp, err := c.CreateOrUpdateImageWithBody(ctx, tenant, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateImageResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateImageWithResponse(ctx context.Context, tenant Tenant, name ResourceName, params *CreateOrUpdateImageParams, body CreateOrUpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateImageResponse, error) {
	rsp, err := c.CreateOrUpdateImage(ctx, tenant, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateImageResponse(rsp)
}

// ListSkusWithResponse request returning *ListSkusResponse
func (c *ClientWithResponses) ListSkusWithResponse(ctx context.Context, tenant Tenant, params *ListSkusParams, reqEditors ...RequestEditorFn) (*ListSkusResponse, error) {
	rsp, err := c.ListSkus(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSkusResponse(rsp)
}

// GetSkuWithResponse request returning *GetSkuResponse
func (c *ClientWithResponses) GetSkuWithResponse(ctx context.Context, tenant Tenant, name ResourceName, reqEditors ...RequestEditorFn) (*GetSkuResponse, error) {
	rsp, err := c.GetSku(ctx, tenant, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSkuResponse(rsp)
}

// ListBlockStoragesWithResponse request returning *ListBlockStoragesResponse
func (c *ClientWithResponses) ListBlockStoragesWithResponse(ctx context.Context, tenant Tenant, workspace Workspace, params *ListBlockStoragesParams, reqEditors ...RequestEditorFn) (*ListBlockStoragesResponse, error) {
	rsp, err := c.ListBlockStorages(ctx, tenant, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBlockStoragesResponse(rsp)
}

// DeleteBlockStorageWithResponse request returning *DeleteBlockStorageResponse
func (c *ClientWithResponses) DeleteBlockStorageWithResponse(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, params *DeleteBlockStorageParams, reqEditors ...RequestEditorFn) (*DeleteBlockStorageResponse, error) {
	rsp, err := c.DeleteBlockStorage(ctx, tenant, workspace, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBlockStorageResponse(rsp)
}

// GetBlockStorageWithResponse request returning *GetBlockStorageResponse
func (c *ClientWithResponses) GetBlockStorageWithResponse(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, reqEditors ...RequestEditorFn) (*GetBlockStorageResponse, error) {
	rsp, err := c.GetBlockStorage(ctx, tenant, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockStorageResponse(rsp)
}

// CreateOrUpdateBlockStorageWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateBlockStorageResponse
func (c *ClientWithResponses) CreateOrUpdateBlockStorageWithBodyWithResponse(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, params *CreateOrUpdateBlockStorageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateBlockStorageResponse, error) {
	rsp, err := c.CreateOrUpdateBlockStorageWithBody(ctx, tenant, workspace, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateBlockStorageResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateBlockStorageWithResponse(ctx context.Context, tenant Tenant, workspace Workspace, name ResourceName, params *CreateOrUpdateBlockStorageParams, body CreateOrUpdateBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateBlockStorageResponse, error) {
	rsp, err := c.CreateOrUpdateBlockStorage(ctx, tenant, workspace, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateBlockStorageResponse(rsp)
}

// ParseListImagesResponse parses an HTTP response from a ListImagesWithResponse call
func ParseListImagesResponse(rsp *http.Response) (*ListImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImageIterator
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteImageResponse parses an HTTP response from a DeleteImageWithResponse call
func ParseDeleteImageResponse(rsp *http.Response) (*DeleteImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetImageResponse parses an HTTP response from a GetImageWithResponse call
func ParseGetImageResponse(rsp *http.Response) (*GetImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateImageResponse parses an HTTP response from a CreateOrUpdateImageWithResponse call
func ParseCreateOrUpdateImageResponse(rsp *http.Response) (*CreateOrUpdateImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Image
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSkusResponse parses an HTTP response from a ListSkusWithResponse call
func ParseListSkusResponse(rsp *http.Response) (*ListSkusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSkusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SkuIterator
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSkuResponse parses an HTTP response from a GetSkuWithResponse call
func ParseGetSkuResponse(rsp *http.Response) (*GetSkuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSkuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageSku
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBlockStoragesResponse parses an HTTP response from a ListBlockStoragesWithResponse call
func ParseListBlockStoragesResponse(rsp *http.Response) (*ListBlockStoragesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBlockStoragesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockStorageIterator
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBlockStorageResponse parses an HTTP response from a DeleteBlockStorageWithResponse call
func ParseDeleteBlockStorageResponse(rsp *http.Response) (*DeleteBlockStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBlockStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBlockStorageResponse parses an HTTP response from a GetBlockStorageWithResponse call
func ParseGetBlockStorageResponse(rsp *http.Response) (*GetBlockStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateBlockStorageResponse parses an HTTP response from a CreateOrUpdateBlockStorageWithResponse call
func ParseCreateOrUpdateBlockStorageResponse(rsp *http.Response) (*CreateOrUpdateBlockStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateBlockStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BlockStorage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List images
	// (GET /v1/tenants/{tenant}/images)
	ListImages(w http.ResponseWriter, r *http.Request, tenant Tenant, params ListImagesParams)
	// Delete image
	// (DELETE /v1/tenants/{tenant}/images/{name})
	DeleteImage(w http.ResponseWriter, r *http.Request, tenant Tenant, name ResourceName, params DeleteImageParams)
	// Get image
	// (GET /v1/tenants/{tenant}/images/{name})
	GetImage(w http.ResponseWriter, r *http.Request, tenant Tenant, name ResourceName)
	// Create or update image
	// (PUT /v1/tenants/{tenant}/images/{name})
	CreateOrUpdateImage(w http.ResponseWriter, r *http.Request, tenant Tenant, name ResourceName, params CreateOrUpdateImageParams)
	// List skus
	// (GET /v1/tenants/{tenant}/skus)
	ListSkus(w http.ResponseWriter, r *http.Request, tenant Tenant, params ListSkusParams)
	// Get sku
	// (GET /v1/tenants/{tenant}/skus/{name})
	GetSku(w http.ResponseWriter, r *http.Request, tenant Tenant, name ResourceName)
	// List block-storages
	// (GET /v1/tenants/{tenant}/workspaces/{workspace}/block-storages)
	ListBlockStorages(w http.ResponseWriter, r *http.Request, tenant Tenant, workspace Workspace, params ListBlockStoragesParams)
	// Delete block-storage
	// (DELETE /v1/tenants/{tenant}/workspaces/{workspace}/block-storages/{name})
	DeleteBlockStorage(w http.ResponseWriter, r *http.Request, tenant Tenant, workspace Workspace, name ResourceName, params DeleteBlockStorageParams)
	// Get block-storage
	// (GET /v1/tenants/{tenant}/workspaces/{workspace}/block-storages/{name})
	GetBlockStorage(w http.ResponseWriter, r *http.Request, tenant Tenant, workspace Workspace, name ResourceName)
	// Create or update block-storage
	// (PUT /v1/tenants/{tenant}/workspaces/{workspace}/block-storages/{name})
	CreateOrUpdateBlockStorage(w http.ResponseWriter, r *http.Request, tenant Tenant, workspace Workspace, name ResourceName, params CreateOrUpdateBlockStorageParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListImages operation middleware
func (siw *ServerInterfaceWrapper) ListImages(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant Tenant

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListImagesParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListImagesParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListImages(w, r, tenant, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteImage operation middleware
func (siw *ServerInterfaceWrapper) DeleteImage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant Tenant

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteImageParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteImage(w, r, tenant, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetImage operation middleware
func (siw *ServerInterfaceWrapper) GetImage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant Tenant

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetImage(w, r, tenant, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateImage operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateImage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant Tenant

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateImageParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateImage(w, r, tenant, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListSkus operation middleware
func (siw *ServerInterfaceWrapper) ListSkus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant Tenant

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSkusParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListSkusParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSkus(w, r, tenant, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSku operation middleware
func (siw *ServerInterfaceWrapper) GetSku(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant Tenant

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSku(w, r, tenant, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListBlockStorages operation middleware
func (siw *ServerInterfaceWrapper) ListBlockStorages(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant Tenant

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace Workspace

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBlockStoragesParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListBlockStoragesParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListBlockStorages(w, r, tenant, workspace, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteBlockStorage operation middleware
func (siw *ServerInterfaceWrapper) DeleteBlockStorage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant Tenant

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace Workspace

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteBlockStorageParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBlockStorage(w, r, tenant, workspace, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetBlockStorage operation middleware
func (siw *ServerInterfaceWrapper) GetBlockStorage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant Tenant

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace Workspace

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBlockStorage(w, r, tenant, workspace, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateBlockStorage operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateBlockStorage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tenant" -------------
	var tenant Tenant

	err = runtime.BindStyledParameterWithOptions("simple", "tenant", r.PathValue("tenant"), &tenant, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tenant", Err: err})
		return
	}

	// ------------- Path parameter "workspace" -------------
	var workspace Workspace

	err = runtime.BindStyledParameterWithOptions("simple", "workspace", r.PathValue("workspace"), &workspace, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workspace", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name ResourceName

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateBlockStorageParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateBlockStorage(w, r, tenant, workspace, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{tenant}/images", wrapper.ListImages)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{tenant}/images/{name}", wrapper.DeleteImage)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{tenant}/images/{name}", wrapper.GetImage)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{tenant}/images/{name}", wrapper.CreateOrUpdateImage)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{tenant}/skus", wrapper.ListSkus)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{tenant}/skus/{name}", wrapper.GetSku)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{tenant}/workspaces/{workspace}/block-storages", wrapper.ListBlockStorages)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{tenant}/workspaces/{workspace}/block-storages/{name}", wrapper.DeleteBlockStorage)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{tenant}/workspaces/{workspace}/block-storages/{name}", wrapper.GetBlockStorage)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{tenant}/workspaces/{workspace}/block-storages/{name}", wrapper.CreateOrUpdateBlockStorage)

	return m
}
