//go:build go1.22

// Package authorization provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package authorization

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for RoleKind.
const (
	RoleKindRole RoleKind = "role"
)

// Defines values for RoleAssignmentKind.
const (
	RoleAssignmentKindRoleAssignment RoleAssignmentKind = "role-assignment"
)

// Defines values for AcceptHeader.
const (
	AcceptHeaderApplicationjson            AcceptHeader = "application/json"
	AcceptHeaderApplicationjsonDeletedOnly AcceptHeader = "application/json; deleted=only"
	AcceptHeaderApplicationjsonDeletedTrue AcceptHeader = "application/json; deleted=true"
)

// Defines values for ListRoleAssignmentsParamsAccept.
const (
	ListRoleAssignmentsParamsAcceptApplicationjson            ListRoleAssignmentsParamsAccept = "application/json"
	ListRoleAssignmentsParamsAcceptApplicationjsonDeletedOnly ListRoleAssignmentsParamsAccept = "application/json; deleted=only"
	ListRoleAssignmentsParamsAcceptApplicationjsonDeletedTrue ListRoleAssignmentsParamsAccept = "application/json; deleted=true"
)

// Defines values for ListRolesParamsAccept.
const (
	Applicationjson            ListRolesParamsAccept = "application/json"
	ApplicationjsonDeletedOnly ListRolesParamsAccept = "application/json; deleted=only"
	ApplicationjsonDeletedTrue ListRolesParamsAccept = "application/json; deleted=true"
)

// Error A generic error response
type Error struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error400 defines model for Error400.
type Error400 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error401 defines model for Error401.
type Error401 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error403 defines model for Error403.
type Error403 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error404 defines model for Error404.
type Error404 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error412 defines model for Error412.
type Error412 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error422 defines model for Error422.
type Error422 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error500 defines model for Error500.
type Error500 struct {
	Errors []ErrorDetail `json:"errors"`
}

// ErrorDetail A detailed error response
type ErrorDetail struct {
	// Code An application-specific error code, expressed as a string value.
	Code string `json:"code"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta map[string]interface{} `json:"meta"`

	// Source An object containing references to the source of the error.
	Source *ErrorSource `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem.
	Title string `json:"title"`
}

// ErrorSource An object containing references to the source of the error.
type ErrorSource struct {
	// Parameter A string indicating which URI query parameter caused the error.
	Parameter string `json:"parameter"`

	// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
	Pointer string `json:"pointer"`
}

// GlobalResourceMetadata defines model for GlobalResourceMetadata.
type GlobalResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels map[string]interface{} `json:"labels"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name string `json:"name"`
}

// ResourceMetadata Base metadata for all resources, with optional location references
type ResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels map[string]interface{} `json:"labels"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name string `json:"name"`
}

// ResponseMetadata defines model for ResponseMetadata.
type ResponseMetadata struct {
	// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
	SkipToken *string `json:"skipToken,omitempty"`
}

// Role defines model for Role.
type Role struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *RoleKind               `json:"kind,omitempty"`
	Metadata *GlobalResourceMetadata `json:"metadata,omitempty"`
	Spec     *RoleSpec               `json:"spec,omitempty"`

	// Status Current status of the resource
	Status *Status `json:"status,omitempty"`
}

// RoleKind Type of the resource
type RoleKind string

// RoleAssignment defines model for RoleAssignment.
type RoleAssignment struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *RoleAssignmentKind     `json:"kind,omitempty"`
	Metadata *GlobalResourceMetadata `json:"metadata,omitempty"`
	Spec     *RoleAssignmentSpec     `json:"spec,omitempty"`

	// Status Current status of the resource
	Status *Status `json:"status,omitempty"`
}

// RoleAssignmentKind Type of the resource
type RoleAssignmentKind string

// RoleAssignmentSpec defines model for RoleAssignmentSpec.
type RoleAssignmentSpec struct {
	// Roles List of assigned role names
	Roles *[]string `json:"roles,omitempty"`

	// Scopes List of Scopes to whom the roles are assigned
	Scopes *[]string `json:"scopes,omitempty"`

	// Subs List of subject IDs (from JWT) to whom the roles are assigned
	Subs *[]string `json:"subs,omitempty"`
}

// RoleSpec defines model for RoleSpec.
type RoleSpec struct {
	// Permissions List of permissions granted by this role
	Permissions *[]string `json:"permissions,omitempty"`
}

// Status Current status of the resource
type Status struct {
	Conditions []StatusCondition `json:"conditions"`
}

// StatusCondition StatusCondition describes the state of a resource at a certain point.
// Conditions are provider-specific and can represent different states depending on the
// resource type and provider implementation.
type StatusCondition struct {
	// LastTransitionTime LastTransitionTime is the last time the condition transitioned from one
	// status to another. This should be when the underlying condition changed.
	// If that is not known, then using the time when the API field changed is
	// acceptable.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message A human-readable message indicating details about the transition.
	Message *string `json:"message,omitempty"`

	// Reason The reason for the condition's last transition in CamelCase.
	// The specific set of reason values is provider-specific and should be
	// documented by the provider.
	Reason *string `json:"reason,omitempty"`

	// Status Status of the condition.
	Status string `json:"status"`

	// Type Type of condition. The condition type is provider-specific and should
	// reflect the specific states relevant to your resource.
	Type string `json:"type"`
}

// AcceptHeader defines model for acceptHeader.
type AcceptHeader string

// IfUnmodifiedSince defines model for ifUnmodifiedSince.
type IfUnmodifiedSince = time.Time

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// TenantID defines model for tenantID.
type TenantID = string

// ListRoleAssignmentsParams defines parameters for ListRoleAssignments.
type ListRoleAssignmentsParams struct {
	// Name Filter assignments by role assignment group name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListRoleAssignmentsParamsAccept `json:"Accept,omitempty"`
}

// ListRoleAssignmentsParamsAccept defines parameters for ListRoleAssignments.
type ListRoleAssignmentsParamsAccept string

// DeleteRoleAssignmentParams defines parameters for DeleteRoleAssignment.
type DeleteRoleAssignmentParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateRoleAssignmentParams defines parameters for CreateOrUpdateRoleAssignment.
type CreateOrUpdateRoleAssignmentParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListRolesParams defines parameters for ListRoles.
type ListRolesParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - `"application/json"`: Returns only non-deleted resources
	// - `"application/json; deleted=true"`: Returns both deleted and non-deleted resources
	// - `"application/json; deleted=only"`: Returns only deleted resources
	Accept *ListRolesParamsAccept `json:"Accept,omitempty"`
}

// ListRolesParamsAccept defines parameters for ListRoles.
type ListRolesParamsAccept string

// DeleteRoleParams defines parameters for DeleteRole.
type DeleteRoleParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateRoleParams defines parameters for CreateOrUpdateRole.
type CreateOrUpdateRoleParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateRoleAssignmentJSONRequestBody defines body for CreateOrUpdateRoleAssignment for application/json ContentType.
type CreateOrUpdateRoleAssignmentJSONRequestBody = RoleAssignment

// CreateOrUpdateRoleJSONRequestBody defines body for CreateOrUpdateRole for application/json ContentType.
type CreateOrUpdateRoleJSONRequestBody = Role

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListRoleAssignments request
	ListRoleAssignments(ctx context.Context, id TenantID, params *ListRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRoleAssignment request
	DeleteRoleAssignment(ctx context.Context, id TenantID, name string, params *DeleteRoleAssignmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoleAssignment request
	GetRoleAssignment(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateRoleAssignmentWithBody request with any body
	CreateOrUpdateRoleAssignmentWithBody(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateRoleAssignment(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, body CreateOrUpdateRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRoles request
	ListRoles(ctx context.Context, id TenantID, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRole request
	DeleteRole(ctx context.Context, id TenantID, name string, params *DeleteRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRole request
	GetRole(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateRoleWithBody request with any body
	CreateOrUpdateRoleWithBody(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateRole(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, body CreateOrUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListRoleAssignments(ctx context.Context, id TenantID, params *ListRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRoleAssignmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoleAssignment(ctx context.Context, id TenantID, name string, params *DeleteRoleAssignmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleAssignmentRequest(c.Server, id, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoleAssignment(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleAssignmentRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateRoleAssignmentWithBody(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateRoleAssignmentRequestWithBody(c.Server, id, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateRoleAssignment(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, body CreateOrUpdateRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateRoleAssignmentRequest(c.Server, id, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRoles(ctx context.Context, id TenantID, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRole(ctx context.Context, id TenantID, name string, params *DeleteRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleRequest(c.Server, id, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRole(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateRoleWithBody(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateRoleRequestWithBody(c.Server, id, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateRole(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, body CreateOrUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateRoleRequest(c.Server, id, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListRoleAssignmentsRequest generates requests for ListRoleAssignments
func NewListRoleAssignmentsRequest(server string, id TenantID, params *ListRoleAssignmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/role-assignments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteRoleAssignmentRequest generates requests for DeleteRoleAssignment
func NewDeleteRoleAssignmentRequest(server string, id TenantID, name string, params *DeleteRoleAssignmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/role-assignments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewGetRoleAssignmentRequest generates requests for GetRoleAssignment
func NewGetRoleAssignmentRequest(server string, id TenantID, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/role-assignments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateRoleAssignmentRequest calls the generic CreateOrUpdateRoleAssignment builder with application/json body
func NewCreateOrUpdateRoleAssignmentRequest(server string, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, body CreateOrUpdateRoleAssignmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateRoleAssignmentRequestWithBody(server, id, name, params, "application/json", bodyReader)
}

// NewCreateOrUpdateRoleAssignmentRequestWithBody generates requests for CreateOrUpdateRoleAssignment with any type of body
func NewCreateOrUpdateRoleAssignmentRequestWithBody(server string, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/role-assignments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewListRolesRequest generates requests for ListRoles
func NewListRolesRequest(server string, id TenantID, params *ListRolesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteRoleRequest generates requests for DeleteRole
func NewDeleteRoleRequest(server string, id TenantID, name string, params *DeleteRoleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewGetRoleRequest generates requests for GetRole
func NewGetRoleRequest(server string, id TenantID, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateRoleRequest calls the generic CreateOrUpdateRole builder with application/json body
func NewCreateOrUpdateRoleRequest(server string, id TenantID, name string, params *CreateOrUpdateRoleParams, body CreateOrUpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateRoleRequestWithBody(server, id, name, params, "application/json", bodyReader)
}

// NewCreateOrUpdateRoleRequestWithBody generates requests for CreateOrUpdateRole with any type of body
func NewCreateOrUpdateRoleRequestWithBody(server string, id TenantID, name string, params *CreateOrUpdateRoleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListRoleAssignmentsWithResponse request
	ListRoleAssignmentsWithResponse(ctx context.Context, id TenantID, params *ListRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*ListRoleAssignmentsResponse, error)

	// DeleteRoleAssignmentWithResponse request
	DeleteRoleAssignmentWithResponse(ctx context.Context, id TenantID, name string, params *DeleteRoleAssignmentParams, reqEditors ...RequestEditorFn) (*DeleteRoleAssignmentResponse, error)

	// GetRoleAssignmentWithResponse request
	GetRoleAssignmentWithResponse(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*GetRoleAssignmentResponse, error)

	// CreateOrUpdateRoleAssignmentWithBodyWithResponse request with any body
	CreateOrUpdateRoleAssignmentWithBodyWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleAssignmentResponse, error)

	CreateOrUpdateRoleAssignmentWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, body CreateOrUpdateRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleAssignmentResponse, error)

	// ListRolesWithResponse request
	ListRolesWithResponse(ctx context.Context, id TenantID, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error)

	// DeleteRoleWithResponse request
	DeleteRoleWithResponse(ctx context.Context, id TenantID, name string, params *DeleteRoleParams, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error)

	// GetRoleWithResponse request
	GetRoleWithResponse(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error)

	// CreateOrUpdateRoleWithBodyWithResponse request with any body
	CreateOrUpdateRoleWithBodyWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleResponse, error)

	CreateOrUpdateRoleWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, body CreateOrUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleResponse, error)
}

type ListRoleAssignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]RoleAssignment `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListRoleAssignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRoleAssignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteRoleAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleAssignment
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetRoleAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateRoleAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleAssignment
	JSON201      *RoleAssignment
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateRoleAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateRoleAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]Role           `json:"items,omitempty"`
		Metadata *ResponseMetadata `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSON201      *Role
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListRoleAssignmentsWithResponse request returning *ListRoleAssignmentsResponse
func (c *ClientWithResponses) ListRoleAssignmentsWithResponse(ctx context.Context, id TenantID, params *ListRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*ListRoleAssignmentsResponse, error) {
	rsp, err := c.ListRoleAssignments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRoleAssignmentsResponse(rsp)
}

// DeleteRoleAssignmentWithResponse request returning *DeleteRoleAssignmentResponse
func (c *ClientWithResponses) DeleteRoleAssignmentWithResponse(ctx context.Context, id TenantID, name string, params *DeleteRoleAssignmentParams, reqEditors ...RequestEditorFn) (*DeleteRoleAssignmentResponse, error) {
	rsp, err := c.DeleteRoleAssignment(ctx, id, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleAssignmentResponse(rsp)
}

// GetRoleAssignmentWithResponse request returning *GetRoleAssignmentResponse
func (c *ClientWithResponses) GetRoleAssignmentWithResponse(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*GetRoleAssignmentResponse, error) {
	rsp, err := c.GetRoleAssignment(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleAssignmentResponse(rsp)
}

// CreateOrUpdateRoleAssignmentWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateRoleAssignmentResponse
func (c *ClientWithResponses) CreateOrUpdateRoleAssignmentWithBodyWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleAssignmentResponse, error) {
	rsp, err := c.CreateOrUpdateRoleAssignmentWithBody(ctx, id, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateRoleAssignmentResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateRoleAssignmentWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, body CreateOrUpdateRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleAssignmentResponse, error) {
	rsp, err := c.CreateOrUpdateRoleAssignment(ctx, id, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateRoleAssignmentResponse(rsp)
}

// ListRolesWithResponse request returning *ListRolesResponse
func (c *ClientWithResponses) ListRolesWithResponse(ctx context.Context, id TenantID, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error) {
	rsp, err := c.ListRoles(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesResponse(rsp)
}

// DeleteRoleWithResponse request returning *DeleteRoleResponse
func (c *ClientWithResponses) DeleteRoleWithResponse(ctx context.Context, id TenantID, name string, params *DeleteRoleParams, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error) {
	rsp, err := c.DeleteRole(ctx, id, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleResponse(rsp)
}

// GetRoleWithResponse request returning *GetRoleResponse
func (c *ClientWithResponses) GetRoleWithResponse(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error) {
	rsp, err := c.GetRole(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleResponse(rsp)
}

// CreateOrUpdateRoleWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateRoleResponse
func (c *ClientWithResponses) CreateOrUpdateRoleWithBodyWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleResponse, error) {
	rsp, err := c.CreateOrUpdateRoleWithBody(ctx, id, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateRoleWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, body CreateOrUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleResponse, error) {
	rsp, err := c.CreateOrUpdateRole(ctx, id, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateRoleResponse(rsp)
}

// ParseListRoleAssignmentsResponse parses an HTTP response from a ListRoleAssignmentsWithResponse call
func ParseListRoleAssignmentsResponse(rsp *http.Response) (*ListRoleAssignmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRoleAssignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]RoleAssignment `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRoleAssignmentResponse parses an HTTP response from a DeleteRoleAssignmentWithResponse call
func ParseDeleteRoleAssignmentResponse(rsp *http.Response) (*DeleteRoleAssignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleAssignmentResponse parses an HTTP response from a GetRoleAssignmentWithResponse call
func ParseGetRoleAssignmentResponse(rsp *http.Response) (*GetRoleAssignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateRoleAssignmentResponse parses an HTTP response from a CreateOrUpdateRoleAssignmentWithResponse call
func ParseCreateOrUpdateRoleAssignmentResponse(rsp *http.Response) (*CreateOrUpdateRoleAssignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateRoleAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RoleAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRolesResponse parses an HTTP response from a ListRolesWithResponse call
func ParseListRolesResponse(rsp *http.Response) (*ListRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]Role           `json:"items,omitempty"`
			Metadata *ResponseMetadata `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRoleResponse parses an HTTP response from a DeleteRoleWithResponse call
func ParseDeleteRoleResponse(rsp *http.Response) (*DeleteRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleResponse parses an HTTP response from a GetRoleWithResponse call
func ParseGetRoleResponse(rsp *http.Response) (*GetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateRoleResponse parses an HTTP response from a CreateOrUpdateRoleWithResponse call
func ParseCreateOrUpdateRoleResponse(rsp *http.Response) (*CreateOrUpdateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all role assignments
	// (GET /v1/tenants/{id}/role-assignments)
	ListRoleAssignments(w http.ResponseWriter, r *http.Request, id TenantID, params ListRoleAssignmentsParams)
	// Delete a role assignment group
	// (DELETE /v1/tenants/{id}/role-assignments/{name})
	DeleteRoleAssignment(w http.ResponseWriter, r *http.Request, id TenantID, name string, params DeleteRoleAssignmentParams)
	// Get a specific role assignment group
	// (GET /v1/tenants/{id}/role-assignments/{name})
	GetRoleAssignment(w http.ResponseWriter, r *http.Request, id TenantID, name string)
	// Create or update role assignments for a group
	// (PUT /v1/tenants/{id}/role-assignments/{name})
	CreateOrUpdateRoleAssignment(w http.ResponseWriter, r *http.Request, id TenantID, name string, params CreateOrUpdateRoleAssignmentParams)
	// List all roles
	// (GET /v1/tenants/{id}/roles)
	ListRoles(w http.ResponseWriter, r *http.Request, id TenantID, params ListRolesParams)
	// Delete a specific role
	// (DELETE /v1/tenants/{id}/roles/{name})
	DeleteRole(w http.ResponseWriter, r *http.Request, id TenantID, name string, params DeleteRoleParams)
	// Get a specific role
	// (GET /v1/tenants/{id}/roles/{name})
	GetRole(w http.ResponseWriter, r *http.Request, id TenantID, name string)
	// Create or update a specific role
	// (PUT /v1/tenants/{id}/roles/{name})
	CreateOrUpdateRole(w http.ResponseWriter, r *http.Request, id TenantID, name string, params CreateOrUpdateRoleParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListRoleAssignments operation middleware
func (siw *ServerInterfaceWrapper) ListRoleAssignments(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRoleAssignmentsParams

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListRoleAssignmentsParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRoleAssignments(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteRoleAssignment operation middleware
func (siw *ServerInterfaceWrapper) DeleteRoleAssignment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteRoleAssignmentParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRoleAssignment(w, r, id, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRoleAssignment operation middleware
func (siw *ServerInterfaceWrapper) GetRoleAssignment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRoleAssignment(w, r, id, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateRoleAssignment operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateRoleAssignment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateRoleAssignmentParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateRoleAssignment(w, r, id, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListRoles operation middleware
func (siw *ServerInterfaceWrapper) ListRoles(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRolesParams

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", r.URL.Query(), &params.Labels)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "labels", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", r.URL.Query(), &params.SkipToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skipToken", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept ListRolesParamsAccept
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRoles(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteRole operation middleware
func (siw *ServerInterfaceWrapper) DeleteRole(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteRoleParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRole(w, r, id, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRole operation middleware
func (siw *ServerInterfaceWrapper) GetRole(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRole(w, r, id, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrUpdateRole operation middleware
func (siw *ServerInterfaceWrapper) CreateOrUpdateRole(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateRoleParams

	headers := r.Header

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "if-unmodified-since", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "if-unmodified-since", Err: err})
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrUpdateRole(w, r, id, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/role-assignments", wrapper.ListRoleAssignments)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{id}/role-assignments/{name}", wrapper.DeleteRoleAssignment)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/role-assignments/{name}", wrapper.GetRoleAssignment)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/role-assignments/{name}", wrapper.CreateOrUpdateRoleAssignment)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/roles", wrapper.ListRoles)
	m.HandleFunc("DELETE "+options.BaseURL+"/v1/tenants/{id}/roles/{name}", wrapper.DeleteRole)
	m.HandleFunc("GET "+options.BaseURL+"/v1/tenants/{id}/roles/{name}", wrapper.GetRole)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/tenants/{id}/roles/{name}", wrapper.CreateOrUpdateRole)

	return m
}
