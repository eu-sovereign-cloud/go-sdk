// Package authorization provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package authorization

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for RoleKind.
const (
	RoleKindRole RoleKind = "role"
)

// Defines values for RoleAssignmentKind.
const (
	RoleAssignmentKindRoleAssignment RoleAssignmentKind = "role-assignment"
)

// Error A generic error response
type Error struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error400 defines model for Error400.
type Error400 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error401 defines model for Error401.
type Error401 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error403 defines model for Error403.
type Error403 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error404 defines model for Error404.
type Error404 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error412 defines model for Error412.
type Error412 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error422 defines model for Error422.
type Error422 struct {
	Errors []ErrorDetail `json:"errors"`
}

// Error500 defines model for Error500.
type Error500 struct {
	Errors []ErrorDetail `json:"errors"`
}

// ErrorDetail A detailed error response
type ErrorDetail struct {
	// Code An application-specific error code, expressed as a string value.
	Code string `json:"code"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Meta A meta object containing non-standard meta-information about the error.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Source An object containing references to the source of the error.
	Source *struct {
		// Parameter A string indicating which URI query parameter caused the error.
		Parameter *string `json:"parameter,omitempty"`

		// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
		Pointer *string `json:"pointer,omitempty"`
	} `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem.
	Title string `json:"title"`
}

// GlobalResourceMetadata defines model for GlobalResourceMetadata.
type GlobalResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels *map[string]interface{} `json:"labels,omitempty"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name *string `json:"name,omitempty"`
}

// ResourceMetadata Base metadata for all resources, with optional location references
type ResourceMetadata struct {
	// DeletionTimestamp If set, indicates the time when the resource was marked for deletion. Resources with this field set are considered pending deletion.
	DeletionTimestamp *time.Time `json:"deletionTimestamp,omitempty"`

	// Description user can add a description for other humans to understand why this resource exists
	Description *string `json:"description,omitempty"`

	// Labels User-defined key/value pairs that are mutable and can be used to organize and categorize resources.
	Labels *map[string]interface{} `json:"labels,omitempty"`

	// LastModifiedTimestamp Indicates the time when the resource was created or last modified. Field is used for "If-Unmodified-Since" logic for concurrency control. The provider guarantees that a modification on a single resource can happen only once every millisecond.
	LastModifiedTimestamp *time.Time `json:"lastModifiedTimestamp,omitempty"`

	// Name Resource identifier in dash-case (kebab-case) format. Must start and end with an alphanumeric character. Can contain lowercase letters, numbers, and hyphens. Multiple segments can be joined with dots. Each segment follows the same rules.
	Name *string `json:"name,omitempty"`
}

// Role defines model for Role.
type Role struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *RoleKind               `json:"kind,omitempty"`
	Metadata *GlobalResourceMetadata `json:"metadata,omitempty"`
	Spec     *struct {
		// Permissions List of permissions granted by this role
		Permissions *[]string `json:"permissions,omitempty"`
	} `json:"spec,omitempty"`

	// Status Current status of the resource
	Status *Status `json:"status,omitempty"`
}

// RoleKind Type of the resource
type RoleKind string

// RoleAssignment defines model for RoleAssignment.
type RoleAssignment struct {
	// ApiVersion API version of the resource
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Kind Type of the resource
	Kind     *RoleAssignmentKind     `json:"kind,omitempty"`
	Metadata *GlobalResourceMetadata `json:"metadata,omitempty"`
	Spec     *struct {
		// Roles List of assigned role names
		Roles *[]string `json:"roles,omitempty"`

		// Scopes List of Scopes to whom the roles are assigned
		Scopes *[]string `json:"scopes,omitempty"`

		// Subs List of subject IDs (from JWT) to whom the roles are assigned
		Subs *[]string `json:"subs,omitempty"`
	} `json:"spec,omitempty"`

	// Status Current status of the resource
	Status *Status `json:"status,omitempty"`
}

// RoleAssignmentKind Type of the resource
type RoleAssignmentKind string

// Status Current status of the resource
type Status struct {
	// Conditions Conditions represent the latest available observations of a resource's current state.
	// Conditions are provider-specific and can represent different states depending on the
	// resource type and provider implementation.
	Conditions *StatusConditions `json:"conditions,omitempty"`
}

// StatusConditions Conditions represent the latest available observations of a resource's current state.
// Conditions are provider-specific and can represent different states depending on the
// resource type and provider implementation.
type StatusConditions = []struct {
	// LastTransitionTime LastTransitionTime is the last time the condition transitioned from one
	// status to another. This should be when the underlying condition changed.
	// If that is not known, then using the time when the API field changed is
	// acceptable.
	LastTransitionTime time.Time `json:"lastTransitionTime"`

	// Message A human-readable message indicating details about the transition.
	Message *string `json:"message,omitempty"`

	// Reason The reason for the condition's last transition in CamelCase.
	// The specific set of reason values is provider-specific and should be
	// documented by the provider.
	Reason *string `json:"reason,omitempty"`

	// Status Status of the condition.
	Status string `json:"status"`

	// Type Type of condition. The condition type is provider-specific and should
	// reflect the specific states relevant to your resource.
	Type string `json:"type"`
}

// AcceptHeader defines model for acceptHeader.
type AcceptHeader = string

// IfUnmodifiedSince defines model for ifUnmodifiedSince.
type IfUnmodifiedSince = time.Time

// LabelSelector defines model for labelSelector.
type LabelSelector = string

// LimitParam defines model for limitParam.
type LimitParam = int

// SkipTokenParam defines model for skipTokenParam.
type SkipTokenParam = string

// TenantID defines model for tenantID.
type TenantID = string

// ListRoleAssignmentsParams defines parameters for ListRoleAssignments.
type ListRoleAssignmentsParams struct {
	// Name Filter assignments by role assignment group name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - application/json: Returns only non-deleted resources
	// - application/json; deleted=true: Returns both deleted and non-deleted resources
	// - application/json; deleted=only: Returns only deleted resources
	Accept *AcceptHeader `json:"Accept,omitempty"`
}

// DeleteRoleAssignmentParams defines parameters for DeleteRoleAssignment.
type DeleteRoleAssignmentParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateRoleAssignmentParams defines parameters for CreateOrUpdateRoleAssignment.
type CreateOrUpdateRoleAssignmentParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// ListRolesParams defines parameters for ListRoles.
type ListRolesParams struct {
	// Labels Filter resources by their labels. Multiple filters are combined with comma.
	// Filter syntax:
	//   - Equals: key=value
	//   - Not equals: key!=value
	//   - Wildcards: *key*=*value* - matches if at least one pair match
	//   - Numeric: key>value, key<value, key>=value, key<=value
	//   - Namespaced key examples: 'monitoring:alert-level=high' or 'billing:team=platform'
	Labels *LabelSelector `form:"labels,omitempty" json:"labels,omitempty"`

	// Limit Maximum number of resources to return in the response
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipToken Opaque cursor for pagination. Use the skipToken from the previous response to get the next page of results. Note that skipTokens do not guarantee consistency across pages if the underlying data changes between requests
	SkipToken *SkipTokenParam `form:"skipToken,omitempty" json:"skipToken,omitempty"`

	// Accept Controls whether deleted resources are included:
	// - application/json: Returns only non-deleted resources
	// - application/json; deleted=true: Returns both deleted and non-deleted resources
	// - application/json; deleted=only: Returns only deleted resources
	Accept *AcceptHeader `json:"Accept,omitempty"`
}

// DeleteRoleParams defines parameters for DeleteRole.
type DeleteRoleParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateRoleParams defines parameters for CreateOrUpdateRole.
type CreateOrUpdateRoleParams struct {
	// IfUnmodifiedSince Returns resources only if they have not been modified since the specified time.
	// Uses metadata.lastUpdatedTimestamp for comparison.
	IfUnmodifiedSince *IfUnmodifiedSince `json:"if-unmodified-since,omitempty"`
}

// CreateOrUpdateRoleAssignmentJSONRequestBody defines body for CreateOrUpdateRoleAssignment for application/json ContentType.
type CreateOrUpdateRoleAssignmentJSONRequestBody = RoleAssignment

// CreateOrUpdateRoleJSONRequestBody defines body for CreateOrUpdateRole for application/json ContentType.
type CreateOrUpdateRoleJSONRequestBody = Role

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListRoleAssignments request
	ListRoleAssignments(ctx context.Context, id TenantID, params *ListRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRoleAssignment request
	DeleteRoleAssignment(ctx context.Context, id TenantID, name string, params *DeleteRoleAssignmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoleAssignment request
	GetRoleAssignment(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateRoleAssignmentWithBody request with any body
	CreateOrUpdateRoleAssignmentWithBody(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateRoleAssignment(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, body CreateOrUpdateRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRoles request
	ListRoles(ctx context.Context, id TenantID, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRole request
	DeleteRole(ctx context.Context, id TenantID, name string, params *DeleteRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRole request
	GetRole(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateRoleWithBody request with any body
	CreateOrUpdateRoleWithBody(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateRole(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, body CreateOrUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListRoleAssignments(ctx context.Context, id TenantID, params *ListRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRoleAssignmentsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoleAssignment(ctx context.Context, id TenantID, name string, params *DeleteRoleAssignmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleAssignmentRequest(c.Server, id, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoleAssignment(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleAssignmentRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateRoleAssignmentWithBody(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateRoleAssignmentRequestWithBody(c.Server, id, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateRoleAssignment(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, body CreateOrUpdateRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateRoleAssignmentRequest(c.Server, id, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRoles(ctx context.Context, id TenantID, params *ListRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRole(ctx context.Context, id TenantID, name string, params *DeleteRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleRequest(c.Server, id, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRole(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateRoleWithBody(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateRoleRequestWithBody(c.Server, id, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateRole(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, body CreateOrUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateRoleRequest(c.Server, id, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListRoleAssignmentsRequest generates requests for ListRoleAssignments
func NewListRoleAssignmentsRequest(server string, id TenantID, params *ListRoleAssignmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/role-assignments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteRoleAssignmentRequest generates requests for DeleteRoleAssignment
func NewDeleteRoleAssignmentRequest(server string, id TenantID, name string, params *DeleteRoleAssignmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/role-assignments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewGetRoleAssignmentRequest generates requests for GetRoleAssignment
func NewGetRoleAssignmentRequest(server string, id TenantID, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/role-assignments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateRoleAssignmentRequest calls the generic CreateOrUpdateRoleAssignment builder with application/json body
func NewCreateOrUpdateRoleAssignmentRequest(server string, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, body CreateOrUpdateRoleAssignmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateRoleAssignmentRequestWithBody(server, id, name, params, "application/json", bodyReader)
}

// NewCreateOrUpdateRoleAssignmentRequestWithBody generates requests for CreateOrUpdateRoleAssignment with any type of body
func NewCreateOrUpdateRoleAssignmentRequestWithBody(server string, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/role-assignments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewListRolesRequest generates requests for ListRoles
func NewListRolesRequest(server string, id TenantID, params *ListRolesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Labels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipToken", runtime.ParamLocationQuery, *params.SkipToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteRoleRequest generates requests for DeleteRole
func NewDeleteRoleRequest(server string, id TenantID, name string, params *DeleteRoleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

// NewGetRoleRequest generates requests for GetRole
func NewGetRoleRequest(server string, id TenantID, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateRoleRequest calls the generic CreateOrUpdateRole builder with application/json body
func NewCreateOrUpdateRoleRequest(server string, id TenantID, name string, params *CreateOrUpdateRoleParams, body CreateOrUpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateRoleRequestWithBody(server, id, name, params, "application/json", bodyReader)
}

// NewCreateOrUpdateRoleRequestWithBody generates requests for CreateOrUpdateRole with any type of body
func NewCreateOrUpdateRoleRequestWithBody(server string, id TenantID, name string, params *CreateOrUpdateRoleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/tenants/%s/roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfUnmodifiedSince != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "if-unmodified-since", runtime.ParamLocationHeader, *params.IfUnmodifiedSince)
			if err != nil {
				return nil, err
			}

			req.Header.Set("if-unmodified-since", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListRoleAssignmentsWithResponse request
	ListRoleAssignmentsWithResponse(ctx context.Context, id TenantID, params *ListRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*ListRoleAssignmentsResponse, error)

	// DeleteRoleAssignmentWithResponse request
	DeleteRoleAssignmentWithResponse(ctx context.Context, id TenantID, name string, params *DeleteRoleAssignmentParams, reqEditors ...RequestEditorFn) (*DeleteRoleAssignmentResponse, error)

	// GetRoleAssignmentWithResponse request
	GetRoleAssignmentWithResponse(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*GetRoleAssignmentResponse, error)

	// CreateOrUpdateRoleAssignmentWithBodyWithResponse request with any body
	CreateOrUpdateRoleAssignmentWithBodyWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleAssignmentResponse, error)

	CreateOrUpdateRoleAssignmentWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, body CreateOrUpdateRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleAssignmentResponse, error)

	// ListRolesWithResponse request
	ListRolesWithResponse(ctx context.Context, id TenantID, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error)

	// DeleteRoleWithResponse request
	DeleteRoleWithResponse(ctx context.Context, id TenantID, name string, params *DeleteRoleParams, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error)

	// GetRoleWithResponse request
	GetRoleWithResponse(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error)

	// CreateOrUpdateRoleWithBodyWithResponse request with any body
	CreateOrUpdateRoleWithBodyWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleResponse, error)

	CreateOrUpdateRoleWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, body CreateOrUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleResponse, error)
}

type ListRoleAssignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]RoleAssignment `json:"items,omitempty"`
		Metadata *struct {
			// SkipToken Opaque cursor to get the next page
			SkipToken *string `json:"skipToken,omitempty"`
		} `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListRoleAssignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRoleAssignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteRoleAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleAssignment
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetRoleAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateRoleAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleAssignment
	JSON201      *RoleAssignment
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateRoleAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateRoleAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    *[]Role `json:"items,omitempty"`
		Metadata *struct {
			// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
			SkipToken *string `json:"skipToken,omitempty"`
		} `json:"metadata,omitempty"`
	}
	JSON400 *Error400
	JSON401 *Error401
	JSON403 *Error403
	JSON404 *Error404
	JSON500 *Error500
}

// Status returns HTTPResponse.Status
func (r ListRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r DeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r GetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Role
	JSON201      *Role
	JSON400      *Error400
	JSON401      *Error401
	JSON403      *Error403
	JSON404      *Error404
	JSON412      *Error412
	JSON422      *Error422
	JSON500      *Error500
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListRoleAssignmentsWithResponse request returning *ListRoleAssignmentsResponse
func (c *ClientWithResponses) ListRoleAssignmentsWithResponse(ctx context.Context, id TenantID, params *ListRoleAssignmentsParams, reqEditors ...RequestEditorFn) (*ListRoleAssignmentsResponse, error) {
	rsp, err := c.ListRoleAssignments(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRoleAssignmentsResponse(rsp)
}

// DeleteRoleAssignmentWithResponse request returning *DeleteRoleAssignmentResponse
func (c *ClientWithResponses) DeleteRoleAssignmentWithResponse(ctx context.Context, id TenantID, name string, params *DeleteRoleAssignmentParams, reqEditors ...RequestEditorFn) (*DeleteRoleAssignmentResponse, error) {
	rsp, err := c.DeleteRoleAssignment(ctx, id, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleAssignmentResponse(rsp)
}

// GetRoleAssignmentWithResponse request returning *GetRoleAssignmentResponse
func (c *ClientWithResponses) GetRoleAssignmentWithResponse(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*GetRoleAssignmentResponse, error) {
	rsp, err := c.GetRoleAssignment(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleAssignmentResponse(rsp)
}

// CreateOrUpdateRoleAssignmentWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateRoleAssignmentResponse
func (c *ClientWithResponses) CreateOrUpdateRoleAssignmentWithBodyWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleAssignmentResponse, error) {
	rsp, err := c.CreateOrUpdateRoleAssignmentWithBody(ctx, id, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateRoleAssignmentResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateRoleAssignmentWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleAssignmentParams, body CreateOrUpdateRoleAssignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleAssignmentResponse, error) {
	rsp, err := c.CreateOrUpdateRoleAssignment(ctx, id, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateRoleAssignmentResponse(rsp)
}

// ListRolesWithResponse request returning *ListRolesResponse
func (c *ClientWithResponses) ListRolesWithResponse(ctx context.Context, id TenantID, params *ListRolesParams, reqEditors ...RequestEditorFn) (*ListRolesResponse, error) {
	rsp, err := c.ListRoles(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesResponse(rsp)
}

// DeleteRoleWithResponse request returning *DeleteRoleResponse
func (c *ClientWithResponses) DeleteRoleWithResponse(ctx context.Context, id TenantID, name string, params *DeleteRoleParams, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error) {
	rsp, err := c.DeleteRole(ctx, id, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleResponse(rsp)
}

// GetRoleWithResponse request returning *GetRoleResponse
func (c *ClientWithResponses) GetRoleWithResponse(ctx context.Context, id TenantID, name string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error) {
	rsp, err := c.GetRole(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleResponse(rsp)
}

// CreateOrUpdateRoleWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateRoleResponse
func (c *ClientWithResponses) CreateOrUpdateRoleWithBodyWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleResponse, error) {
	rsp, err := c.CreateOrUpdateRoleWithBody(ctx, id, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateRoleWithResponse(ctx context.Context, id TenantID, name string, params *CreateOrUpdateRoleParams, body CreateOrUpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateRoleResponse, error) {
	rsp, err := c.CreateOrUpdateRole(ctx, id, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateRoleResponse(rsp)
}

// ParseListRoleAssignmentsResponse parses an HTTP response from a ListRoleAssignmentsWithResponse call
func ParseListRoleAssignmentsResponse(rsp *http.Response) (*ListRoleAssignmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRoleAssignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]RoleAssignment `json:"items,omitempty"`
			Metadata *struct {
				// SkipToken Opaque cursor to get the next page
				SkipToken *string `json:"skipToken,omitempty"`
			} `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRoleAssignmentResponse parses an HTTP response from a DeleteRoleAssignmentWithResponse call
func ParseDeleteRoleAssignmentResponse(rsp *http.Response) (*DeleteRoleAssignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleAssignmentResponse parses an HTTP response from a GetRoleAssignmentWithResponse call
func ParseGetRoleAssignmentResponse(rsp *http.Response) (*GetRoleAssignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateRoleAssignmentResponse parses an HTTP response from a CreateOrUpdateRoleAssignmentWithResponse call
func ParseCreateOrUpdateRoleAssignmentResponse(rsp *http.Response) (*CreateOrUpdateRoleAssignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateRoleAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RoleAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRolesResponse parses an HTTP response from a ListRolesWithResponse call
func ParseListRolesResponse(rsp *http.Response) (*ListRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    *[]Role `json:"items,omitempty"`
			Metadata *struct {
				// SkipToken Opaque cursor to get the next page. Field is omitted when there are no more pages available.
				SkipToken *string `json:"skipToken,omitempty"`
			} `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRoleResponse parses an HTTP response from a DeleteRoleWithResponse call
func ParseDeleteRoleResponse(rsp *http.Response) (*DeleteRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleResponse parses an HTTP response from a GetRoleWithResponse call
func ParseGetRoleResponse(rsp *http.Response) (*GetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateRoleResponse parses an HTTP response from a CreateOrUpdateRoleWithResponse call
func ParseCreateOrUpdateRoleResponse(rsp *http.Response) (*CreateOrUpdateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error422
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all role assignments
	// (GET /v1/tenants/{id}/role-assignments)
	ListRoleAssignments(ctx echo.Context, id TenantID, params ListRoleAssignmentsParams) error
	// Delete a role assignment group
	// (DELETE /v1/tenants/{id}/role-assignments/{name})
	DeleteRoleAssignment(ctx echo.Context, id TenantID, name string, params DeleteRoleAssignmentParams) error
	// Get a specific role assignment group
	// (GET /v1/tenants/{id}/role-assignments/{name})
	GetRoleAssignment(ctx echo.Context, id TenantID, name string) error
	// Create or update role assignments for a group
	// (PUT /v1/tenants/{id}/role-assignments/{name})
	CreateOrUpdateRoleAssignment(ctx echo.Context, id TenantID, name string, params CreateOrUpdateRoleAssignmentParams) error
	// List all roles
	// (GET /v1/tenants/{id}/roles)
	ListRoles(ctx echo.Context, id TenantID, params ListRolesParams) error
	// Delete a specific role
	// (DELETE /v1/tenants/{id}/roles/{name})
	DeleteRole(ctx echo.Context, id TenantID, name string, params DeleteRoleParams) error
	// Get a specific role
	// (GET /v1/tenants/{id}/roles/{name})
	GetRole(ctx echo.Context, id TenantID, name string) error
	// Create or update a specific role
	// (PUT /v1/tenants/{id}/roles/{name})
	CreateOrUpdateRole(ctx echo.Context, id TenantID, name string, params CreateOrUpdateRoleParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListRoleAssignments converts echo context to params.
func (w *ServerInterfaceWrapper) ListRoleAssignments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRoleAssignmentsParams
	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", ctx.QueryParams(), &params.Labels)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter labels: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", ctx.QueryParams(), &params.SkipToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skipToken: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept: %s", err))
		}

		params.Accept = &Accept
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRoleAssignments(ctx, id, params)
	return err
}

// DeleteRoleAssignment converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRoleAssignment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteRoleAssignmentParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for if-unmodified-since, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter if-unmodified-since: %s", err))
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteRoleAssignment(ctx, id, name, params)
	return err
}

// GetRoleAssignment converts echo context to params.
func (w *ServerInterfaceWrapper) GetRoleAssignment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRoleAssignment(ctx, id, name)
	return err
}

// CreateOrUpdateRoleAssignment converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOrUpdateRoleAssignment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateRoleAssignmentParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for if-unmodified-since, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter if-unmodified-since: %s", err))
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOrUpdateRoleAssignment(ctx, id, name, params)
	return err
}

// ListRoles converts echo context to params.
func (w *ServerInterfaceWrapper) ListRoles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRolesParams
	// ------------- Optional query parameter "labels" -------------

	err = runtime.BindQueryParameter("form", true, false, "labels", ctx.QueryParams(), &params.Labels)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter labels: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "skipToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "skipToken", ctx.QueryParams(), &params.SkipToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter skipToken: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Accept, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Accept: %s", err))
		}

		params.Accept = &Accept
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRoles(ctx, id, params)
	return err
}

// DeleteRole converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteRoleParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for if-unmodified-since, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter if-unmodified-since: %s", err))
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteRole(ctx, id, name, params)
	return err
}

// GetRole converts echo context to params.
func (w *ServerInterfaceWrapper) GetRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRole(ctx, id, name)
	return err
}

// CreateOrUpdateRole converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOrUpdateRole(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id TenantID

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", ctx.Param("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrUpdateRoleParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince IfUnmodifiedSince
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for if-unmodified-since, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter if-unmodified-since: %s", err))
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOrUpdateRole(ctx, id, name, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v1/tenants/:id/role-assignments", wrapper.ListRoleAssignments)
	router.DELETE(baseURL+"/v1/tenants/:id/role-assignments/:name", wrapper.DeleteRoleAssignment)
	router.GET(baseURL+"/v1/tenants/:id/role-assignments/:name", wrapper.GetRoleAssignment)
	router.PUT(baseURL+"/v1/tenants/:id/role-assignments/:name", wrapper.CreateOrUpdateRoleAssignment)
	router.GET(baseURL+"/v1/tenants/:id/roles", wrapper.ListRoles)
	router.DELETE(baseURL+"/v1/tenants/:id/roles/:name", wrapper.DeleteRole)
	router.GET(baseURL+"/v1/tenants/:id/roles/:name", wrapper.GetRole)
	router.PUT(baseURL+"/v1/tenants/:id/roles/:name", wrapper.CreateOrUpdateRole)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
